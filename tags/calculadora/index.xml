<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Calculadora on Imlauer</title>
    <link>https://imlauera.github.io/tags/calculadora/</link>
    <description>Recent content in Calculadora on Imlauer</description>
    <generator>Hugo</generator>
    <language>es-es</language>
    <lastBuildDate>Tue, 27 Aug 2024 14:54:47 -0300</lastBuildDate>
    <atom:link href="https://imlauera.github.io/tags/calculadora/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Ricardo Narvaja (Exámen 22)</title>
      <link>https://imlauera.github.io/post/ricardo_narvaja_22/</link>
      <pubDate>Tue, 27 Aug 2024 14:54:47 -0300</pubDate>
      <guid>https://imlauera.github.io/post/ricardo_narvaja_22/</guid>
      <description>Este exámen tiene demasiado código como para pegarlo acá.</description>
    </item>
    <item>
      <title>Ricardo Narvaja: Exámen 17 (Servidor, zlib.dll)</title>
      <link>https://imlauera.github.io/post/ricardo_narvaja_17/</link>
      <pubDate>Tue, 27 Aug 2024 14:54:39 -0300</pubDate>
      <guid>https://imlauera.github.io/post/ricardo_narvaja_17/</guid>
      <description>int __cdecl main(int argc, const char **argv, const char **envp) { char v3; // al char v5; // al char v6; // al char v7; // al char v8; // [esp+0h] [ebp-12E0h] char v9; // [esp+0h] [ebp-12E0h] char v10; // [esp+0h] [ebp-12E0h] char v11; // [esp+0h] [ebp-12E0h] char v12[4096]; // [esp+8h] [ebp-12D8h] BYREF char v13[400]; // [esp+1008h] [ebp-2D8h] BYREF char Format[200]; // [esp+1198h] [ebp-148h] BYREF char v15[64]; // [esp+1260h] [ebp-80h] BYREF char v16[16]; // [esp+12A0h] [ebp-40h] BYREF __int16 v17[2]; // [esp+12B0h] [ebp-30h] BYREF int v18; // [esp+12B4h] [ebp-2Ch] int v19; // [esp+12C0h] [ebp-20h] int v20; // [esp+12C4h] [ebp-1Ch] BYREF char v21[4]; // [esp+12C8h] [ebp-18h] char v22[4]; // [esp+12CCh] [ebp-14h] int v23; // [esp+12D0h] [ebp-10h] int i; // [esp+12D4h] [ebp-Ch] int v25; // [esp+12D8h] [ebp-8h] char v26; // [esp+12DFh] [ebp-1h] strcpy(v15, &amp;#34;Hello Client , I have received your connection your key is %d.</description>
    </item>
    <item>
      <title>Ricardo Narvaja: Exámen 18 (Servidor, libw32pth-0.dll)</title>
      <link>https://imlauera.github.io/post/ricardo_narvaja_18/</link>
      <pubDate>Tue, 27 Aug 2024 14:54:39 -0300</pubDate>
      <guid>https://imlauera.github.io/post/ricardo_narvaja_18/</guid>
      <description>int sub_4014E0(char *Buffer, char *Format, ...) { va_list va; // [esp+18h] [ebp+10h] BYREF va_start(va, Format); sub_401010(); return sub_401450(Buffer, Format, 0, va); } int __cdecl sub_401020(int a1) { char v1; // al char v3; // al char v4; // al char v5; // al size_t v6; // eax char v7; // [esp+0h] [ebp-12DCh] char v8; // [esp+0h] [ebp-12DCh] char v9; // [esp+0h] [ebp-12DCh] char v10; // [esp+0h] [ebp-12DCh] char v11[4096]; // [esp+8h] [ebp-12D4h] BYREF char v12[400]; // [esp+1008h] [ebp-2D4h] BYREF char Format[64]; // [esp+1198h] [ebp-144h] BYREF char Str[200]; // [esp+11D8h] [ebp-104h] BYREF char v15[16]; // [esp+12A0h] [ebp-3Ch] BYREF __int16 v16[2]; // [esp+12B0h] [ebp-2Ch] BYREF int v17; // [esp+12B4h] [ebp-28h] int v18; // [esp+12C0h] [ebp-1Ch] int v19; // [esp+12C4h] [ebp-18h] BYREF char v20[4]; // [esp+12C8h] [ebp-14h] int i; // [esp+12CCh] [ebp-10h] int v22; // [esp+12D0h] [ebp-Ch] int v23; // [esp+12D4h] [ebp-8h] char v24; // [esp+12DBh] [ebp-1h] strcpy(Format, &amp;#34;Hello Client , I have received your connection your key is %d.</description>
    </item>
    <item>
      <title>Ricardo Narvaja: Exámen 19 (Servidor, WCMZIP32.DLL)</title>
      <link>https://imlauera.github.io/post/ricardo_narvaja_19/</link>
      <pubDate>Tue, 27 Aug 2024 14:54:39 -0300</pubDate>
      <guid>https://imlauera.github.io/post/ricardo_narvaja_19/</guid>
      <description>_DWORD *__thiscall sub_401020(_DWORD *this) { sub_4010C0(this); *this = off_403348; this[2] = 0; this[113] = 0; this[114] = 0; *((_BYTE *)this + 4756) = 0; memset(this + 115, 0, 0xC8u); memset(this + 165, 0, 0x1000u); memset((char *)this + 4757, 0, 0xC8u); return this; } _DWORD *__thiscall sub_401650(_DWORD *this, int a2) { _DWORD *result; // eax result = this; this[2] = a2; return result; } int __thiscall sub_4010E0(char *this) { char v1; // al char v2; // al size_t v3; // eax sub_4014D0(this); *((_DWORD *)this + 104) = WS2_32_1(*((_DWORD *)this + 103), this + 436, this + 452); if ( *((_DWORD *)this + 104) == -1 ) { v1 = WS2_32_111(); sub_4017F0(&amp;#34;accept failed with error code : %d&amp;#34;, v1); } puts(&amp;#34;Connection accepted\n&amp;#34;); memset(this + 4757, 0, 0xC8u); sub_4017F0(&amp;#34;number= %d\n&amp;#34;, *((_DWORD *)this + 2)); v2 = sub_401490(8888); sub_401830(this + 4757, &amp;#34;Nuevo Port is = %d\n&amp;#34;, v2); WS2_32_19(*((_DWORD *)this + 104), this + 4757, 200, 0); v3 = strlen(this + 4757); WS2_32_16(*((_DWORD *)this + 104), Src, v3, 0); if ( *(_DWORD *)Src == 1094861636 ) { WS2_32_3(*((_DWORD *)this + 103)); return 1; } else { puts(&amp;#34;Bye Bye love\n&amp;#34;); return 0; } } int __thiscall sub_401240(int this) { char v1; // al char v3; // [esp+0h] [ebp-Ch] int v4; // [esp+0h] [ebp-Ch] signed int i; // [esp+4h] [ebp-8h] sub_4014D0(this); *(_DWORD *)(this + 416) = WS2_32_1(*(_DWORD *)(this + 412), this + 436, this + 452); if ( *(_DWORD *)(this + 416) == -1 ) { v1 = WS2_32_111(); sub_4017F0(&amp;#34;accept failed with error code : %d&amp;#34;, v1); } puts(&amp;#34;Connection accepted\n&amp;#34;); memset((void *)(this + 4757), 0, 0xC8u); sub_4017F0(&amp;#34;number= %d\n&amp;#34;, *(_DWORD *)(this + 8)); sub_401830((char *)(this + 4757), (char *)(this + 460), dword_404080[0]); sub_4017F0((char *)(this + 4757), v3); WS2_32_19(*(_DWORD *)(this + 416), this + 4757, 200, 0); *(_DWORD *)(this + 456) = dword_404084; WS2_32_16(*(_DWORD *)(this + 416), Src, 12288, 0); v4 = *((_DWORD *)Src + 1) + *(_DWORD *)Src; sub_4017F0(&amp;#34;%x\n\n&amp;#34;, v4); if ( v4 == -1 ) { Size = *((_DWORD *)Src + 2); dword_404078 = *((_DWORD *)Src + 3); } memcpy((void *)(this + 660), Src, Size); for ( i = 0; i &amp;lt; (int)Size; ++i ) { *(_BYTE *)(this + 4756) = *(_BYTE *)(i + this + 660); if ( *(_BYTE *)(this + 4756) == 4 ) exit(1); if ( *(_BYTE *)(this + 4756) == 65 ) exit(1); } if ( dword_404078 !</description>
    </item>
    <item>
      <title>Ricardo Narvaja: Exámen 20 (Servidor, libiconv-2.dll, iconv.dll, intl.dll)</title>
      <link>https://imlauera.github.io/post/ricardo_narvaja_20/</link>
      <pubDate>Tue, 27 Aug 2024 14:54:39 -0300</pubDate>
      <guid>https://imlauera.github.io/post/ricardo_narvaja_20/</guid>
      <description>Hay 3 exámenes Examen a _BYTE *__cdecl sub_40ADB0(_BYTE *a1, _BYTE *a2) { _BYTE *v2; // edi _BYTE *v3; // ecx int v4; // edx int v5; // eax _BYTE *result; // eax v2 = a1; v3 = a2; if ( ((unsigned __int8)a2 &amp;amp; 3) == 0 ) { while ( 1 ) { LABEL_6: v5 = (*(_DWORD *)v3 + 2130640639) ^ ~*(_DWORD *)v3; v4 = *(_DWORD *)v3; v3 += 4; if ( (v5 &amp;amp; 0x81010100) !</description>
    </item>
    <item>
      <title>Ricardo Narvaja: Exámen 21 (Ejecutar la calculadora, con base de datos:ConsoleApplication4.pdb)</title>
      <link>https://imlauera.github.io/post/ricardo_narvaja_21/</link>
      <pubDate>Tue, 27 Aug 2024 14:54:39 -0300</pubDate>
      <guid>https://imlauera.github.io/post/ricardo_narvaja_21/</guid>
      <description>int __thiscall sub_401050(_DWORD *this, int a2, int a3, int *a4, int *a5) { int v6[256]; // [esp+0h] [ebp-404h] BYREF _DWORD *v7; // [esp+400h] [ebp-4h] v7 = this; sub_401010(this, a2, a3, a4, a5); *v7 = &amp;amp;off_41A348; a2 = 0; a3 = 0; a4 = &amp;amp;a2; a5 = &amp;amp;a3; *(v7 + 1024) = 0; *(v7 + 1025) = 0; *(v7 + 1026) = 0; sub_401010(v6, a2, a3, a4, a5); return v7; } _DWORD *__thiscall sub_401010(_DWORD *this, int a2, int a3, int a4, int a5) { *this = &amp;amp;off_41A33C; this[2] = a2; this[3] = a3; this[5] = a5; this[4] = a4; return this; } LPVOID __cdecl sub_40C2D8(SIZE_T dwBytes) { SIZE_T v1; // esi LPVOID result; // eax v1 = dwBytes; if ( dwBytes &amp;gt; 0xFFFFFFE0 ) { LABEL_8: *(_DWORD *)sub_40CBC6() = 12; return 0; } else { if ( !</description>
    </item>
    <item>
      <title>Ricardo Narvaja: Exámen 23 (kernel32.dll) 64 bits</title>
      <link>https://imlauera.github.io/post/ricardo_narvaja_23/</link>
      <pubDate>Tue, 27 Aug 2024 14:54:39 -0300</pubDate>
      <guid>https://imlauera.github.io/post/ricardo_narvaja_23/</guid>
      <description>int __fastcall main(int argc, const char **argv, const char **envp) { FILE *v3; // rax int v4; // ebx char Buffer[4]; // [rsp+20h] [rbp-E8h] BYREF qword_140003628 = GetModuleHandleA(&amp;#34;kernel32.dll&amp;#34;); while ( 1 ) { Stream = fopen(&amp;#34;fichero.dat&amp;#34;, &amp;#34;a+&amp;#34;); if ( !Stream ) break; v3 = _acrt_iob_func(0); fgets(Buffer, 450, v3); fwrite(Buffer, 1uLL, 450uLL, Stream); v4 = *Buffer; fclose(Stream); if ( v4 == 0x41424344 ) return 0; } perror(&amp;#34;No se puede escribir fichero.dat&amp;#34;); printf(&amp;#34;%x&amp;#34;); return -1; } </description>
    </item>
    <item>
      <title>Ricardo Narvaja: Exámen 16 (Servidor, MObexDll.dll)</title>
      <link>https://imlauera.github.io/post/ricardo_narvaja_16/</link>
      <pubDate>Tue, 27 Aug 2024 14:54:38 -0300</pubDate>
      <guid>https://imlauera.github.io/post/ricardo_narvaja_16/</guid>
      <description>int __cdecl main(int argc, const char **argv, const char **envp) { char v3; // al char v5; // al char v6; // al char v7; // al char v8; // [esp+0h] [ebp-12D0h] char v9; // [esp+0h] [ebp-12D0h] char v10; // [esp+0h] [ebp-12D0h] char v11[4096]; // [esp+8h] [ebp-12C8h] BYREF char v12[400]; // [esp+1008h] [ebp-2C8h] BYREF char Destination[200]; // [esp+1198h] [ebp-138h] BYREF char Source[52]; // [esp+1260h] [ebp-70h] BYREF char v15[16]; // [esp+1294h] [ebp-3Ch] BYREF __int16 v16[2]; // [esp+12A4h] [ebp-2Ch] BYREF int v17; // [esp+12A8h] [ebp-28h] int v18; // [esp+12B4h] [ebp-1Ch] int v19; // [esp+12B8h] [ebp-18h] BYREF char v20[4]; // [esp+12BCh] [ebp-14h] int v21; // [esp+12C0h] [ebp-10h] int i; // [esp+12C4h] [ebp-Ch] int v23; // [esp+12C8h] [ebp-8h] strcpy(Source, &amp;#34;Hello Client , I have received your connection.</description>
    </item>
    <item>
      <title>Ricardo Narvaja: Exámen 15 (Servidor, MObexDll.dll)</title>
      <link>https://imlauera.github.io/post/ricardo_narvaja_15/</link>
      <pubDate>Tue, 27 Aug 2024 14:54:36 -0300</pubDate>
      <guid>https://imlauera.github.io/post/ricardo_narvaja_15/</guid>
      <description>int __cdecl main(int argc, const char **argv, const char **envp) { char v3; // al char v5; // al char v6; // al char v7; // al size_t v8; // eax char v9[4096]; // [esp+0h] [ebp-11D8h] BYREF char v10[400]; // [esp+1000h] [ebp-1D8h] BYREF char v11[16]; // [esp+1190h] [ebp-48h] BYREF __int16 v12[2]; // [esp+11A0h] [ebp-38h] BYREF int v13; // [esp+11A4h] [ebp-34h] int v14; // [esp+11B0h] [ebp-28h] int v15; // [esp+11B4h] [ebp-24h] BYREF size_t Size; // [esp+11B8h] [ebp-20h] char v17[4]; // [esp+11BCh] [ebp-1Ch] char *Str; // [esp+11C0h] [ebp-18h] int v19; // [esp+11C4h] [ebp-14h] int i; // [esp+11C8h] [ebp-10h] int v21; // [esp+11CCh] [ebp-Ch] void *Src; // [esp+11D4h] [ebp-4h] Size = 4096; Src = malloc(0x2000u); LoadLibraryA(&amp;#34;MObexDll.</description>
    </item>
    <item>
      <title>Ricardo Narvaja: Exámen 14 (Servidor, helixprodctrl.dll)</title>
      <link>https://imlauera.github.io/post/ricardo_narvaja_14/</link>
      <pubDate>Tue, 27 Aug 2024 14:54:34 -0300</pubDate>
      <guid>https://imlauera.github.io/post/ricardo_narvaja_14/</guid>
      <description>int __cdecl main(int argc, const char **argv, const char **envp) { char v3; // al char v5; // al char v6; // al char v7; // al size_t v8; // eax char v9[400]; // [esp+0h] [ebp-28Ch] BYREF char v10[200]; // [esp+190h] [ebp-FCh] BYREF char v11[16]; // [esp+258h] [ebp-34h] BYREF __int16 v12[2]; // [esp+268h] [ebp-24h] BYREF int v13; // [esp+26Ch] [ebp-20h] int v14; // [esp+278h] [ebp-14h] int v15[2]; // [esp+27Ch] [ebp-10h] BYREF int v16; // [esp+284h] [ebp-8h] int v17; // [esp+288h] [ebp-4h] LoadLibraryA(&amp;#34;helixprodctrl.</description>
    </item>
    <item>
      <title>Ricardo Narvaja: Exámen 13 (Ejecutar calculadora)</title>
      <link>https://imlauera.github.io/post/ricardo_narvaja_13/</link>
      <pubDate>Tue, 27 Aug 2024 14:54:32 -0300</pubDate>
      <guid>https://imlauera.github.io/post/ricardo_narvaja_13/</guid>
      <description>_DWORD *__thiscall this_50(_DWORD *this) { this[50] = &amp;#34;A ejecutar la calculadora de nuevo...\n&amp;#34;; return this; } int __cdecl sub_401040(int a1, int a2, char *FileName) { FILE *Stream; // [esp+0h] [ebp-4h] Stream = fopen(FileName, &amp;#34;rb&amp;#34;); fread(FileName + 204, 300u, 1u, Stream); printf(&amp;#34;Salida %s\n&amp;#34;, a2); dword_403020 = dword_403024 + *(FileName + 102); (dword_403020)(a2); return 0; } int __cdecl main(int argc, const char **argv, const char **envp) { char Buffer[200]; // [esp+0h] [ebp-268h] BYREF char Destination[404]; // [esp+C8h] [ebp-1A0h] BYREF FILE *Stream; // [esp+25Ch] [ebp-Ch] int (__cdecl *v7)(char *, char); // [esp+260h] [ebp-8h] char v8[4]; // [esp+264h] [ebp-4h] if ( argc &amp;lt; 2 ) { printf(&amp;#34;bye: \n&amp;#34;, Buffer[0]); exit(1); } this_50(Destination); v7 = (&amp;amp;system + 110); dword_403024 = &amp;amp;system + 110; memset(Destination, 0, 0xC8u); memset(&amp;amp;Destination[204], 0, 0xC8u); memset(Buffer, 0, sizeof(Buffer)); strcpy(Destination, argv[1]); Stream = fopen(Destination, &amp;#34;r&amp;#34;); if ( !</description>
    </item>
    <item>
      <title>Ricardo narvaja: Exámen 12 (Ejecutar calculadora)</title>
      <link>https://imlauera.github.io/post/ricardo_narvaja_12/</link>
      <pubDate>Tue, 27 Aug 2024 14:54:22 -0300</pubDate>
      <guid>https://imlauera.github.io/post/ricardo_narvaja_12/</guid>
      <description>Este tiene bufferoverflow en el nombre del archivo. Tenés que crear un archivo con un nombre muy largo y desborda y pisa el EIP. Ejemplo:&#xA;└─$ wine ConsoleApplication11.exe AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA AAAAAAAAAAAAAAAAAAA wine: Unhandled page fault on read access to 41414141 at address 7B3630C6 (thread 00 24), starting debugger... Unhandled exception: page fault on read access to 0x41414141 in wow64 32-bit code (0 x7b3630c6). 0114:err:dbghelp_msc:pe_load_debug_directory Got a page fault while loading symbols winedbg: Internal crash at 7AC68CF4 Lo que me decompila el IDA:</description>
    </item>
    <item>
      <title>Reversing: Exámen 11 (Ricardo Narvaja)</title>
      <link>https://imlauera.github.io/post/ricardo_narvaja_11/</link>
      <pubDate>Tue, 27 Aug 2024 01:56:28 -0300</pubDate>
      <guid>https://imlauera.github.io/post/ricardo_narvaja_11/</guid>
      <description>Los retos los hice usando vim con la siguiente configuracion:&#xA;&amp;#34; vim -b : edit binary using xxd-format! augroup Binary au! au BufReadPre *.bin let &amp;amp;bin=1 au BufReadPost *.bin if &amp;amp;bin | %!xxd au BufReadPost *.bin set ft=xxd | endif au BufWritePre *.bin if &amp;amp;bin | %!xxd -r au BufWritePre *.bin endif au BufWritePost *.bin if &amp;amp;bin | %!xxd au BufWritePost *.bin set nomod | endif augroup END autocmd BufWritePost *.</description>
    </item>
  </channel>
</rss>
