<!DOCTYPE html>
<html lang="es">





<head>
  <meta property="og:url" content="https://imlauera.github.io/claude_make_short/">
  <meta property="og:site_name" content="Imlauer">
  <meta property="og:title" content="Claude make short">
  <meta property="og:description" content="#!/bin/bash # Script para dividir video horizontal en 4 cuadros verticales, concatenar segmentos y quemar subtÃ­tulos # Uso: ./concat.sh &#34;persona:inicio:duracion persona:inicio:duracion ...&#34; video.mp4 [subtitulos.srt] if [ $# -lt 2 ]; then echo &#34;Uso: $0 \&#34;segmentos\&#34; video.mp4 [subtitulos.srt]&#34; echo &#34;&#34; echo &#34;Formato de segmentos: \&#34;persona:inicio:duracion persona:inicio:duracion ...\&#34;&#34; echo &#34; persona: 1-4 (de izquierda a derecha)&#34; echo &#34; inicio: segundo de inicio&#34; echo &#34; duracion: duraciÃ³n en segundos del corte&#34; echo &#34;&#34; echo &#34;Ejemplo SIN subtÃ­tulos:&#34; echo &#34; $0 \&#34;1:1140:3 3:1144:2\&#34; video.mp4&#34; echo &#34;&#34; echo &#34;Ejemplo CON subtÃ­tulos:&#34; echo &#34; $0 \&#34;1:1140:3 3:1144:2\&#34; video.mp4 subtitulos.srt&#34; exit 1 fi SEGMENTS=&#34;$1&#34; INPUT_VIDEO=&#34;$2&#34; INPUT_SRT=&#34;$3&#34; OUTPUT_VIDEO=&#34;output_vertical_$(date &#43;%s).mp4&#34; TEMP_DIR=&#34;temp_segments_$$&#34; if [ ! -f &#34;$INPUT_VIDEO&#34; ]; then echo &#34;Error: El archivo &#39;$INPUT_VIDEO&#39; no existe&#34; exit 1 fi USE_SUBTITLES=0 if [ -n &#34;$INPUT_SRT&#34; ]; then if [ ! -f &#34;$INPUT_SRT&#34; ]; then echo &#34;Error: El archivo de subtÃ­tulos &#39;$INPUT_SRT&#39; no existe&#34; exit 1 fi USE_SUBTITLES=1 echo &#34;âœ“ Se quemarÃ¡n subtÃ­tulos desde: $INPUT_SRT&#34; fi # Verificar ffmpeg if ! command -v ffmpeg &amp;&gt; /dev/null; then echo &#34;Error: ffmpeg no estÃ¡ instalado&#34; exit 1 fi # Verificar bc if ! command -v bc &amp;&gt; /dev/null; then echo &#34;Error: bc no estÃ¡ instalado (necesario para cÃ¡lculos)&#34; exit 1 fi echo &#34;========================================&#34; echo &#34;Cortador y Concatenador de Videos&#34; echo &#34;========================================&#34; echo &#34;Video: $INPUT_VIDEO&#34; echo &#34;Segmentos: $SEGMENTS&#34; echo &#34;&#34; # Crear directorio temporal mkdir -p &#34;$TEMP_DIR&#34; # Obtener dimensiones del video echo &#34;Analizando video...&#34; VIDEO_INFO=$(ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 &#34;$INPUT_VIDEO&#34;) WIDTH=$(echo &#34;$VIDEO_INFO&#34; | cut -d&#39;x&#39; -f1) HEIGHT=$(echo &#34;$VIDEO_INFO&#34; | cut -d&#39;x&#39; -f2) echo &#34;Dimensiones originales: ${WIDTH}x${HEIGHT}&#34; # Calcular dimensiones de cada cuadro QUAD_WIDTH=$((WIDTH / 4)) echo &#34;Ancho de cada cuadro: ${QUAD_WIDTH}px&#34; # Dimensiones verticales para redes sociales (9:16) VERTICAL_WIDTH=1080 VERTICAL_HEIGHT=1920 echo &#34;&#34; echo &#34;Formato de salida: ${VERTICAL_WIDTH}x${VERTICAL_HEIGHT} (9:16 - vertical)&#34; echo &#34;&#34; # FunciÃ³n para convertir timestamp SRT a segundos timestamp_to_seconds() { local timestamp=&#34;$1&#34; local hours=$(echo &#34;$timestamp&#34; | cut -d&#39;:&#39; -f1 | sed &#39;s/^0*//&#39;) local minutes=$(echo &#34;$timestamp&#34; | cut -d&#39;:&#39; -f2 | sed &#39;s/^0*//&#39;) local seconds=$(echo &#34;$timestamp&#34; | cut -d&#39;:&#39; -f3 | cut -d&#39;,&#39; -f1 | sed &#39;s/^0*//&#39;) local milliseconds=$(echo &#34;$timestamp&#34; | cut -d&#39;,&#39; -f2 | sed &#39;s/^0*//&#39;) [ -z &#34;$hours&#34; ] &amp;&amp; hours=0 [ -z &#34;$minutes&#34; ] &amp;&amp; minutes=0 [ -z &#34;$seconds&#34; ] &amp;&amp; seconds=0 [ -z &#34;$milliseconds&#34; ] &amp;&amp; milliseconds=0 echo &#34;$hours * 3600 &#43; $minutes * 60 &#43; $seconds &#43; $milliseconds / 1000&#34; | bc -l } # FunciÃ³n para convertir segundos a timestamp SRT seconds_to_timestamp() { local total_seconds=&#34;$1&#34; if (( $(echo &#34;$total_seconds &lt; 0&#34; | bc -l) )); then echo &#34;00:00:00,000&#34; return fi local hours=$(printf &#34;%.0f&#34; $(echo &#34;$total_seconds / 3600&#34; | bc -l)) local remainder=$(echo &#34;$total_seconds - ($hours * 3600)&#34; | bc -l) local minutes=$(printf &#34;%.0f&#34; $(echo &#34;$remainder / 60&#34; | bc -l)) local seconds_decimal=$(echo &#34;$remainder - ($minutes * 60)&#34; | bc -l) local secs_int=$(printf &#34;%.0f&#34; $(echo &#34;$seconds_decimal&#34; | bc -l)) local milliseconds=$(printf &#34;%.0f&#34; $(echo &#34;($seconds_decimal - $secs_int) * 1000&#34; | bc -l)) printf &#34;%02d:%02d:%02d,%03d&#34; &#34;$hours&#34; &#34;$minutes&#34; &#34;$secs_int&#34; &#34;$milliseconds&#34; } # Procesar segmentos y crear SRT ajustado si es necesario segment_num=0 concat_file=&#34;$TEMP_DIR/concat_list.txt&#34; &gt; &#34;$concat_file&#34; if [ $USE_SUBTITLES -eq 1 ]; then ADJUSTED_SRT=&#34;$TEMP_DIR/adjusted_subtitles.srt&#34; &gt; &#34;$ADJUSTED_SRT&#34; subtitle_counter=1 echo &#34;Procesando subtÃ­tulos globalmente...&#34; # Parsear todos los segmentos primero declare -a seg_starts declare -a seg_durations seg_count=0 for seg in $SEGMENTS; do IFS=&#39;:&#39; read -r p s d &lt;&lt;&lt; &#34;$seg&#34; seg_starts[$seg_count]=$s seg_durations[$seg_count]=$d ((seg_count&#43;&#43;)) done # Procesar el SRT UNA SOLA VEZ y ELIMINAR SOLAPAMIENTOS in_subtitle=0 current_offset=0 current_text=&#34;&#34; last_end_time=0 while IFS= read -r line; do if [[ $line =~ ([0-9]{2}:[0-9]{2}:[0-9]{2},[0-9]{3})\ --\&gt;\ ([0-9]{2}:[0-9]{2}:[0-9]{2},[0-9]{3}) ]]; then start_ts=&#34;${BASH_REMATCH[1]}&#34; end_ts=&#34;${BASH_REMATCH[2]}&#34; start_sec=$(timestamp_to_seconds &#34;$start_ts&#34;) end_sec=$(timestamp_to_seconds &#34;$end_ts&#34;) # Buscar en quÃ© segmento(s) cae este subtÃ­tulo current_offset=0 found=0 for ((i=0; i&lt;seg_count; i&#43;&#43;)); do seg_start=${seg_starts[$i]} seg_dur=${seg_durations[$i]} seg_end=$(echo &#34;$seg_start &#43; $seg_dur&#34; | bc) # Si el subtÃ­tulo cruza este segmento if (( $(echo &#34;$start_sec &lt; $seg_end &amp;&amp; $end_sec &gt; $seg_start&#34; | bc -l) )); then new_start=$(echo &#34;$start_sec - $seg_start &#43; $current_offset&#34; | bc -l) new_end=$(echo &#34;$end_sec - $seg_start &#43; $current_offset&#34; | bc -l) if (( $(echo &#34;$new_start &lt; $current_offset&#34; | bc -l) )); then new_start=$current_offset fi # EVITAR SOLAPAMIENTO: Si empieza antes de que termine el anterior, ajustar if (( $(echo &#34;$new_start &lt; $last_end_time&#34; | bc -l) )); then new_start=$last_end_time fi if (( $(echo &#34;$new_end &gt; $new_start &#43; 0.1&#34; | bc -l) )); then new_start_ts=$(seconds_to_timestamp &#34;$new_start&#34;) new_end_ts=$(seconds_to_timestamp &#34;$new_end&#34;) in_subtitle=1 found=1 current_text=&#34;$subtitle_counter $new_start_ts --&gt; $new_end_ts &#34; ((subtitle_counter&#43;&#43;)) last_end_time=$new_end break fi fi current_offset=$(echo &#34;$current_offset &#43; $seg_dur&#34; | bc -l) done if [ $found -eq 0 ]; then in_subtitle=0 current_text=&#34;&#34; fi elif [ -n &#34;$line&#34; ]; then if [ $in_subtitle -eq 1 ] &amp;&amp; [[ ! $line =~ ^[0-9]&#43;$ ]]; then current_text=&#34;${current_text}${line} &#34; fi elif [ -z &#34;$line&#34; ] &amp;&amp; [ $in_subtitle -eq 1 ]; then echo -n &#34;$current_text&#34; &gt;&gt; &#34;$ADJUSTED_SRT&#34; echo &#34;&#34; &gt;&gt; &#34;$ADJUSTED_SRT&#34; in_subtitle=0 current_text=&#34;&#34; fi done &lt; &#34;$INPUT_SRT&#34; echo &#34;âœ“ SubtÃ­tulos procesados (sin solapamientos)&#34; fi # Arrays para guardar info de segmentos declare -a segment_starts declare -a segment_durations for segment in $SEGMENTS; do IFS=&#39;:&#39; read -r person start_time duration &lt;&lt;&lt; &#34;$segment&#34; if [ &#34;$person&#34; -lt 1 ] || [ &#34;$person&#34; -gt 4 ]; then echo &#34;Error: Persona debe estar entre 1 y 4&#34; exit 1 fi if [ &#34;$duration&#34; -le 0 ]; then echo &#34;Error: DuraciÃ³n debe ser positiva (segmento: $segment)&#34; exit 1 fi segment_starts[$segment_num]=$start_time segment_durations[$segment_num]=$duration end_time=$(echo &#34;$start_time &#43; $duration&#34; | bc) case $person in 1) crop_x=0 ;; 2) crop_x=$QUAD_WIDTH ;; 3) crop_x=$((QUAD_WIDTH * 2)) ;; 4) crop_x=$((QUAD_WIDTH * 3)) ;; esac output_segment=&#34;$TEMP_DIR/segment_${segment_num}.mp4&#34; echo &#34;----------------------------------------&#34; echo &#34;Segmento $((segment_num &#43; 1)):&#34; echo &#34; Persona: $person&#34; echo &#34; Inicio: ${start_time}s | DuraciÃ³n: ${duration}s | Fin: ${end_time}s&#34; echo &#34; Crop X: $crop_x&#34; echo &#34; Procesando video...&#34; # Construir filtro de video vf_filter=&#34;crop=${QUAD_WIDTH}:${HEIGHT}:${crop_x}:0,scale=${VERTICAL_WIDTH}:${VERTICAL_HEIGHT}:force_original_aspect_ratio=decrease,pad=${VERTICAL_WIDTH}:${VERTICAL_HEIGHT}:(ow-iw)/2:(oh-ih)/2:black,setsar=1&#34; ffmpeg -y -ss &#34;$start_time&#34; -t &#34;$duration&#34; -i &#34;$INPUT_VIDEO&#34; \ -vf &#34;$vf_filter&#34; \ -c:v libx264 -preset fast -crf 18 \ -c:a aac -b:a 192k \ -movflags &#43;faststart \ &#34;$output_segment&#34; 2&gt;&amp;1 | grep -E &#34;(time=|Duration|error|Error)&#34; | tail -3 || true if [ $? -eq 0 ] &amp;&amp; [ -f &#34;$output_segment&#34; ]; then file_size=$(stat -c%s &#34;$output_segment&#34; 2&gt;/dev/null || stat -f%z &#34;$output_segment&#34; 2&gt;/dev/null) if [ &#34;$file_size&#34; -gt 1000 ]; then echo &#34; âœ“ Segmento creado (${file_size} bytes)&#34; echo &#34;file &#39;$(basename &#34;$output_segment&#34;)&#39;&#34; &gt;&gt; &#34;$concat_file&#34; else echo &#34; âœ— Error: Segmento vacÃ­o&#34; exit 1 fi else echo &#34; âœ— Error al crear segmento&#34; exit 1 fi ((segment_num&#43;&#43;)) done echo &#34;&#34; echo &#34;========================================&#34; echo &#34;Concatenando $segment_num segmentos...&#34; echo &#34;========================================&#34; if [ ! -s &#34;$concat_file&#34; ]; then echo &#34;âœ— Error: No hay segmentos para concatenar&#34; exit 1 fi # Concatenar segmentos TEMP_OUTPUT=&#34;$TEMP_DIR/temp_concatenated.mp4&#34; cd &#34;$TEMP_DIR&#34; ffmpeg -y -f concat -safe 0 -i &#34;concat_list.txt&#34; \ -c copy \ -movflags &#43;faststart \ &#34;temp_concatenated.mp4&#34; 2&gt;&amp;1 | grep -E &#34;(time=|Duration|error|Error)&#34; | tail -3 || true cd .. if [ ! -f &#34;$TEMP_OUTPUT&#34; ]; then echo &#34;âœ— Error al concatenar segmentos&#34; exit 1 fi # Quemar subtÃ­tulos si existen if [ $USE_SUBTITLES -eq 1 ] &amp;&amp; [ -f &#34;$ADJUSTED_SRT&#34; ]; then echo &#34;&#34; echo &#34;========================================&#34; echo &#34;Quemando subtÃ­tulos...&#34; echo &#34;========================================&#34; # Escapar ruta del SRT para ffmpeg ESCAPED_SRT=$(echo &#34;$ADJUSTED_SRT&#34; | sed &#39;s/\\/\\\\/g; s/:/\\:/g; s/&#39;\&#39;&#39;/&#39;\&#39;\\\\\\\&#39;\&#39;&#39;/g&#39;) ffmpeg -y -i &#34;$TEMP_OUTPUT&#34; \ -vf &#34;subtitles=&#39;$ESCAPED_SRT&#39;:force_style=&#39;FontName=Arial,FontSize=11,Bold=1,PrimaryColour=&amp;H00FFFFFF,OutlineColour=&amp;H00000000,BackColour=&amp;H99000000,BorderStyle=4,Outline=1,Shadow=0,MarginV=50,Alignment=2&#39;&#34; \ -c:v libx264 -preset medium -crf 18 \ -c:a copy \ -movflags &#43;faststart \ &#34;$OUTPUT_VIDEO&#34; 2&gt;&amp;1 | grep -E &#34;(time=|Duration|error|Error)&#34; | tail -5 || true else # Sin subtÃ­tulos, solo mover el archivo mv &#34;$TEMP_OUTPUT&#34; &#34;$OUTPUT_VIDEO&#34; fi if [ -f &#34;$OUTPUT_VIDEO&#34; ]; then echo &#34;&#34; echo &#34;âœ“âœ“âœ“ VIDEO COMPLETADO âœ“âœ“âœ“&#34; echo &#34;========================================&#34; echo &#34;Archivo: $OUTPUT_VIDEO&#34; TOTAL_DURATION=$(ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 &#34;$OUTPUT_VIDEO&#34; 2&gt;/dev/null | cut -d&#39;.&#39; -f1) [ -n &#34;$TOTAL_DURATION&#34; ] &amp;&amp; echo &#34;DuraciÃ³n total: ${TOTAL_DURATION}s&#34; FILE_SIZE=$(du -h &#34;$OUTPUT_VIDEO&#34; | cut -f1) echo &#34;TamaÃ±o: $FILE_SIZE&#34; if [ $USE_SUBTITLES -eq 1 ]; then echo &#34;âœ“ SubtÃ­tulos quemados en el video&#34; fi echo &#34;&#34; echo &#34;Â¿Eliminar archivos temporales? (S/n)&#34; read -t 5 -r response || response=&#34;s&#34; if [[ &#34;$response&#34; != &#34;n&#34; &amp;&amp; &#34;$response&#34; != &#34;N&#34; ]]; then rm -rf &#34;$TEMP_DIR&#34; echo &#34;âœ“ Archivos temporales eliminados&#34; else echo &#34;â†’ Temporales en: $TEMP_DIR&#34; [ -f &#34;$ADJUSTED_SRT&#34; ] &amp;&amp; echo &#34;â†’ SRT ajustado: $ADJUSTED_SRT&#34; fi else echo &#34;âœ— Error al crear video final&#34; exit 1 fi echo &#34;&#34; echo &#34;Â¡Listo para subir a las redes! ðŸš€ðŸ”¥&#34;">
  <meta property="og:locale" content="es_es">
  <meta property="og:type" content="article">
    <meta property="article:published_time" content="2025-12-21T01:06:58-03:00">
    <meta property="article:modified_time" content="2025-12-21T01:06:58-03:00">

  
  <meta itemprop="name" content="Claude make short">
  <meta itemprop="description" content="#!/bin/bash # Script para dividir video horizontal en 4 cuadros verticales, concatenar segmentos y quemar subtÃ­tulos # Uso: ./concat.sh &#34;persona:inicio:duracion persona:inicio:duracion ...&#34; video.mp4 [subtitulos.srt] if [ $# -lt 2 ]; then echo &#34;Uso: $0 \&#34;segmentos\&#34; video.mp4 [subtitulos.srt]&#34; echo &#34;&#34; echo &#34;Formato de segmentos: \&#34;persona:inicio:duracion persona:inicio:duracion ...\&#34;&#34; echo &#34; persona: 1-4 (de izquierda a derecha)&#34; echo &#34; inicio: segundo de inicio&#34; echo &#34; duracion: duraciÃ³n en segundos del corte&#34; echo &#34;&#34; echo &#34;Ejemplo SIN subtÃ­tulos:&#34; echo &#34; $0 \&#34;1:1140:3 3:1144:2\&#34; video.mp4&#34; echo &#34;&#34; echo &#34;Ejemplo CON subtÃ­tulos:&#34; echo &#34; $0 \&#34;1:1140:3 3:1144:2\&#34; video.mp4 subtitulos.srt&#34; exit 1 fi SEGMENTS=&#34;$1&#34; INPUT_VIDEO=&#34;$2&#34; INPUT_SRT=&#34;$3&#34; OUTPUT_VIDEO=&#34;output_vertical_$(date &#43;%s).mp4&#34; TEMP_DIR=&#34;temp_segments_$$&#34; if [ ! -f &#34;$INPUT_VIDEO&#34; ]; then echo &#34;Error: El archivo &#39;$INPUT_VIDEO&#39; no existe&#34; exit 1 fi USE_SUBTITLES=0 if [ -n &#34;$INPUT_SRT&#34; ]; then if [ ! -f &#34;$INPUT_SRT&#34; ]; then echo &#34;Error: El archivo de subtÃ­tulos &#39;$INPUT_SRT&#39; no existe&#34; exit 1 fi USE_SUBTITLES=1 echo &#34;âœ“ Se quemarÃ¡n subtÃ­tulos desde: $INPUT_SRT&#34; fi # Verificar ffmpeg if ! command -v ffmpeg &amp;&gt; /dev/null; then echo &#34;Error: ffmpeg no estÃ¡ instalado&#34; exit 1 fi # Verificar bc if ! command -v bc &amp;&gt; /dev/null; then echo &#34;Error: bc no estÃ¡ instalado (necesario para cÃ¡lculos)&#34; exit 1 fi echo &#34;========================================&#34; echo &#34;Cortador y Concatenador de Videos&#34; echo &#34;========================================&#34; echo &#34;Video: $INPUT_VIDEO&#34; echo &#34;Segmentos: $SEGMENTS&#34; echo &#34;&#34; # Crear directorio temporal mkdir -p &#34;$TEMP_DIR&#34; # Obtener dimensiones del video echo &#34;Analizando video...&#34; VIDEO_INFO=$(ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 &#34;$INPUT_VIDEO&#34;) WIDTH=$(echo &#34;$VIDEO_INFO&#34; | cut -d&#39;x&#39; -f1) HEIGHT=$(echo &#34;$VIDEO_INFO&#34; | cut -d&#39;x&#39; -f2) echo &#34;Dimensiones originales: ${WIDTH}x${HEIGHT}&#34; # Calcular dimensiones de cada cuadro QUAD_WIDTH=$((WIDTH / 4)) echo &#34;Ancho de cada cuadro: ${QUAD_WIDTH}px&#34; # Dimensiones verticales para redes sociales (9:16) VERTICAL_WIDTH=1080 VERTICAL_HEIGHT=1920 echo &#34;&#34; echo &#34;Formato de salida: ${VERTICAL_WIDTH}x${VERTICAL_HEIGHT} (9:16 - vertical)&#34; echo &#34;&#34; # FunciÃ³n para convertir timestamp SRT a segundos timestamp_to_seconds() { local timestamp=&#34;$1&#34; local hours=$(echo &#34;$timestamp&#34; | cut -d&#39;:&#39; -f1 | sed &#39;s/^0*//&#39;) local minutes=$(echo &#34;$timestamp&#34; | cut -d&#39;:&#39; -f2 | sed &#39;s/^0*//&#39;) local seconds=$(echo &#34;$timestamp&#34; | cut -d&#39;:&#39; -f3 | cut -d&#39;,&#39; -f1 | sed &#39;s/^0*//&#39;) local milliseconds=$(echo &#34;$timestamp&#34; | cut -d&#39;,&#39; -f2 | sed &#39;s/^0*//&#39;) [ -z &#34;$hours&#34; ] &amp;&amp; hours=0 [ -z &#34;$minutes&#34; ] &amp;&amp; minutes=0 [ -z &#34;$seconds&#34; ] &amp;&amp; seconds=0 [ -z &#34;$milliseconds&#34; ] &amp;&amp; milliseconds=0 echo &#34;$hours * 3600 &#43; $minutes * 60 &#43; $seconds &#43; $milliseconds / 1000&#34; | bc -l } # FunciÃ³n para convertir segundos a timestamp SRT seconds_to_timestamp() { local total_seconds=&#34;$1&#34; if (( $(echo &#34;$total_seconds &lt; 0&#34; | bc -l) )); then echo &#34;00:00:00,000&#34; return fi local hours=$(printf &#34;%.0f&#34; $(echo &#34;$total_seconds / 3600&#34; | bc -l)) local remainder=$(echo &#34;$total_seconds - ($hours * 3600)&#34; | bc -l) local minutes=$(printf &#34;%.0f&#34; $(echo &#34;$remainder / 60&#34; | bc -l)) local seconds_decimal=$(echo &#34;$remainder - ($minutes * 60)&#34; | bc -l) local secs_int=$(printf &#34;%.0f&#34; $(echo &#34;$seconds_decimal&#34; | bc -l)) local milliseconds=$(printf &#34;%.0f&#34; $(echo &#34;($seconds_decimal - $secs_int) * 1000&#34; | bc -l)) printf &#34;%02d:%02d:%02d,%03d&#34; &#34;$hours&#34; &#34;$minutes&#34; &#34;$secs_int&#34; &#34;$milliseconds&#34; } # Procesar segmentos y crear SRT ajustado si es necesario segment_num=0 concat_file=&#34;$TEMP_DIR/concat_list.txt&#34; &gt; &#34;$concat_file&#34; if [ $USE_SUBTITLES -eq 1 ]; then ADJUSTED_SRT=&#34;$TEMP_DIR/adjusted_subtitles.srt&#34; &gt; &#34;$ADJUSTED_SRT&#34; subtitle_counter=1 echo &#34;Procesando subtÃ­tulos globalmente...&#34; # Parsear todos los segmentos primero declare -a seg_starts declare -a seg_durations seg_count=0 for seg in $SEGMENTS; do IFS=&#39;:&#39; read -r p s d &lt;&lt;&lt; &#34;$seg&#34; seg_starts[$seg_count]=$s seg_durations[$seg_count]=$d ((seg_count&#43;&#43;)) done # Procesar el SRT UNA SOLA VEZ y ELIMINAR SOLAPAMIENTOS in_subtitle=0 current_offset=0 current_text=&#34;&#34; last_end_time=0 while IFS= read -r line; do if [[ $line =~ ([0-9]{2}:[0-9]{2}:[0-9]{2},[0-9]{3})\ --\&gt;\ ([0-9]{2}:[0-9]{2}:[0-9]{2},[0-9]{3}) ]]; then start_ts=&#34;${BASH_REMATCH[1]}&#34; end_ts=&#34;${BASH_REMATCH[2]}&#34; start_sec=$(timestamp_to_seconds &#34;$start_ts&#34;) end_sec=$(timestamp_to_seconds &#34;$end_ts&#34;) # Buscar en quÃ© segmento(s) cae este subtÃ­tulo current_offset=0 found=0 for ((i=0; i&lt;seg_count; i&#43;&#43;)); do seg_start=${seg_starts[$i]} seg_dur=${seg_durations[$i]} seg_end=$(echo &#34;$seg_start &#43; $seg_dur&#34; | bc) # Si el subtÃ­tulo cruza este segmento if (( $(echo &#34;$start_sec &lt; $seg_end &amp;&amp; $end_sec &gt; $seg_start&#34; | bc -l) )); then new_start=$(echo &#34;$start_sec - $seg_start &#43; $current_offset&#34; | bc -l) new_end=$(echo &#34;$end_sec - $seg_start &#43; $current_offset&#34; | bc -l) if (( $(echo &#34;$new_start &lt; $current_offset&#34; | bc -l) )); then new_start=$current_offset fi # EVITAR SOLAPAMIENTO: Si empieza antes de que termine el anterior, ajustar if (( $(echo &#34;$new_start &lt; $last_end_time&#34; | bc -l) )); then new_start=$last_end_time fi if (( $(echo &#34;$new_end &gt; $new_start &#43; 0.1&#34; | bc -l) )); then new_start_ts=$(seconds_to_timestamp &#34;$new_start&#34;) new_end_ts=$(seconds_to_timestamp &#34;$new_end&#34;) in_subtitle=1 found=1 current_text=&#34;$subtitle_counter $new_start_ts --&gt; $new_end_ts &#34; ((subtitle_counter&#43;&#43;)) last_end_time=$new_end break fi fi current_offset=$(echo &#34;$current_offset &#43; $seg_dur&#34; | bc -l) done if [ $found -eq 0 ]; then in_subtitle=0 current_text=&#34;&#34; fi elif [ -n &#34;$line&#34; ]; then if [ $in_subtitle -eq 1 ] &amp;&amp; [[ ! $line =~ ^[0-9]&#43;$ ]]; then current_text=&#34;${current_text}${line} &#34; fi elif [ -z &#34;$line&#34; ] &amp;&amp; [ $in_subtitle -eq 1 ]; then echo -n &#34;$current_text&#34; &gt;&gt; &#34;$ADJUSTED_SRT&#34; echo &#34;&#34; &gt;&gt; &#34;$ADJUSTED_SRT&#34; in_subtitle=0 current_text=&#34;&#34; fi done &lt; &#34;$INPUT_SRT&#34; echo &#34;âœ“ SubtÃ­tulos procesados (sin solapamientos)&#34; fi # Arrays para guardar info de segmentos declare -a segment_starts declare -a segment_durations for segment in $SEGMENTS; do IFS=&#39;:&#39; read -r person start_time duration &lt;&lt;&lt; &#34;$segment&#34; if [ &#34;$person&#34; -lt 1 ] || [ &#34;$person&#34; -gt 4 ]; then echo &#34;Error: Persona debe estar entre 1 y 4&#34; exit 1 fi if [ &#34;$duration&#34; -le 0 ]; then echo &#34;Error: DuraciÃ³n debe ser positiva (segmento: $segment)&#34; exit 1 fi segment_starts[$segment_num]=$start_time segment_durations[$segment_num]=$duration end_time=$(echo &#34;$start_time &#43; $duration&#34; | bc) case $person in 1) crop_x=0 ;; 2) crop_x=$QUAD_WIDTH ;; 3) crop_x=$((QUAD_WIDTH * 2)) ;; 4) crop_x=$((QUAD_WIDTH * 3)) ;; esac output_segment=&#34;$TEMP_DIR/segment_${segment_num}.mp4&#34; echo &#34;----------------------------------------&#34; echo &#34;Segmento $((segment_num &#43; 1)):&#34; echo &#34; Persona: $person&#34; echo &#34; Inicio: ${start_time}s | DuraciÃ³n: ${duration}s | Fin: ${end_time}s&#34; echo &#34; Crop X: $crop_x&#34; echo &#34; Procesando video...&#34; # Construir filtro de video vf_filter=&#34;crop=${QUAD_WIDTH}:${HEIGHT}:${crop_x}:0,scale=${VERTICAL_WIDTH}:${VERTICAL_HEIGHT}:force_original_aspect_ratio=decrease,pad=${VERTICAL_WIDTH}:${VERTICAL_HEIGHT}:(ow-iw)/2:(oh-ih)/2:black,setsar=1&#34; ffmpeg -y -ss &#34;$start_time&#34; -t &#34;$duration&#34; -i &#34;$INPUT_VIDEO&#34; \ -vf &#34;$vf_filter&#34; \ -c:v libx264 -preset fast -crf 18 \ -c:a aac -b:a 192k \ -movflags &#43;faststart \ &#34;$output_segment&#34; 2&gt;&amp;1 | grep -E &#34;(time=|Duration|error|Error)&#34; | tail -3 || true if [ $? -eq 0 ] &amp;&amp; [ -f &#34;$output_segment&#34; ]; then file_size=$(stat -c%s &#34;$output_segment&#34; 2&gt;/dev/null || stat -f%z &#34;$output_segment&#34; 2&gt;/dev/null) if [ &#34;$file_size&#34; -gt 1000 ]; then echo &#34; âœ“ Segmento creado (${file_size} bytes)&#34; echo &#34;file &#39;$(basename &#34;$output_segment&#34;)&#39;&#34; &gt;&gt; &#34;$concat_file&#34; else echo &#34; âœ— Error: Segmento vacÃ­o&#34; exit 1 fi else echo &#34; âœ— Error al crear segmento&#34; exit 1 fi ((segment_num&#43;&#43;)) done echo &#34;&#34; echo &#34;========================================&#34; echo &#34;Concatenando $segment_num segmentos...&#34; echo &#34;========================================&#34; if [ ! -s &#34;$concat_file&#34; ]; then echo &#34;âœ— Error: No hay segmentos para concatenar&#34; exit 1 fi # Concatenar segmentos TEMP_OUTPUT=&#34;$TEMP_DIR/temp_concatenated.mp4&#34; cd &#34;$TEMP_DIR&#34; ffmpeg -y -f concat -safe 0 -i &#34;concat_list.txt&#34; \ -c copy \ -movflags &#43;faststart \ &#34;temp_concatenated.mp4&#34; 2&gt;&amp;1 | grep -E &#34;(time=|Duration|error|Error)&#34; | tail -3 || true cd .. if [ ! -f &#34;$TEMP_OUTPUT&#34; ]; then echo &#34;âœ— Error al concatenar segmentos&#34; exit 1 fi # Quemar subtÃ­tulos si existen if [ $USE_SUBTITLES -eq 1 ] &amp;&amp; [ -f &#34;$ADJUSTED_SRT&#34; ]; then echo &#34;&#34; echo &#34;========================================&#34; echo &#34;Quemando subtÃ­tulos...&#34; echo &#34;========================================&#34; # Escapar ruta del SRT para ffmpeg ESCAPED_SRT=$(echo &#34;$ADJUSTED_SRT&#34; | sed &#39;s/\\/\\\\/g; s/:/\\:/g; s/&#39;\&#39;&#39;/&#39;\&#39;\\\\\\\&#39;\&#39;&#39;/g&#39;) ffmpeg -y -i &#34;$TEMP_OUTPUT&#34; \ -vf &#34;subtitles=&#39;$ESCAPED_SRT&#39;:force_style=&#39;FontName=Arial,FontSize=11,Bold=1,PrimaryColour=&amp;H00FFFFFF,OutlineColour=&amp;H00000000,BackColour=&amp;H99000000,BorderStyle=4,Outline=1,Shadow=0,MarginV=50,Alignment=2&#39;&#34; \ -c:v libx264 -preset medium -crf 18 \ -c:a copy \ -movflags &#43;faststart \ &#34;$OUTPUT_VIDEO&#34; 2&gt;&amp;1 | grep -E &#34;(time=|Duration|error|Error)&#34; | tail -5 || true else # Sin subtÃ­tulos, solo mover el archivo mv &#34;$TEMP_OUTPUT&#34; &#34;$OUTPUT_VIDEO&#34; fi if [ -f &#34;$OUTPUT_VIDEO&#34; ]; then echo &#34;&#34; echo &#34;âœ“âœ“âœ“ VIDEO COMPLETADO âœ“âœ“âœ“&#34; echo &#34;========================================&#34; echo &#34;Archivo: $OUTPUT_VIDEO&#34; TOTAL_DURATION=$(ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 &#34;$OUTPUT_VIDEO&#34; 2&gt;/dev/null | cut -d&#39;.&#39; -f1) [ -n &#34;$TOTAL_DURATION&#34; ] &amp;&amp; echo &#34;DuraciÃ³n total: ${TOTAL_DURATION}s&#34; FILE_SIZE=$(du -h &#34;$OUTPUT_VIDEO&#34; | cut -f1) echo &#34;TamaÃ±o: $FILE_SIZE&#34; if [ $USE_SUBTITLES -eq 1 ]; then echo &#34;âœ“ SubtÃ­tulos quemados en el video&#34; fi echo &#34;&#34; echo &#34;Â¿Eliminar archivos temporales? (S/n)&#34; read -t 5 -r response || response=&#34;s&#34; if [[ &#34;$response&#34; != &#34;n&#34; &amp;&amp; &#34;$response&#34; != &#34;N&#34; ]]; then rm -rf &#34;$TEMP_DIR&#34; echo &#34;âœ“ Archivos temporales eliminados&#34; else echo &#34;â†’ Temporales en: $TEMP_DIR&#34; [ -f &#34;$ADJUSTED_SRT&#34; ] &amp;&amp; echo &#34;â†’ SRT ajustado: $ADJUSTED_SRT&#34; fi else echo &#34;âœ— Error al crear video final&#34; exit 1 fi echo &#34;&#34; echo &#34;Â¡Listo para subir a las redes! ðŸš€ðŸ”¥&#34;">
  <meta itemprop="datePublished" content="2025-12-21T01:06:58-03:00">
  <meta itemprop="dateModified" content="2025-12-21T01:06:58-03:00">
  <meta itemprop="wordCount" content="1316">
  
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Claude make short">
  <meta name="twitter:description" content="#!/bin/bash # Script para dividir video horizontal en 4 cuadros verticales, concatenar segmentos y quemar subtÃ­tulos # Uso: ./concat.sh &#34;persona:inicio:duracion persona:inicio:duracion ...&#34; video.mp4 [subtitulos.srt] if [ $# -lt 2 ]; then echo &#34;Uso: $0 \&#34;segmentos\&#34; video.mp4 [subtitulos.srt]&#34; echo &#34;&#34; echo &#34;Formato de segmentos: \&#34;persona:inicio:duracion persona:inicio:duracion ...\&#34;&#34; echo &#34; persona: 1-4 (de izquierda a derecha)&#34; echo &#34; inicio: segundo de inicio&#34; echo &#34; duracion: duraciÃ³n en segundos del corte&#34; echo &#34;&#34; echo &#34;Ejemplo SIN subtÃ­tulos:&#34; echo &#34; $0 \&#34;1:1140:3 3:1144:2\&#34; video.mp4&#34; echo &#34;&#34; echo &#34;Ejemplo CON subtÃ­tulos:&#34; echo &#34; $0 \&#34;1:1140:3 3:1144:2\&#34; video.mp4 subtitulos.srt&#34; exit 1 fi SEGMENTS=&#34;$1&#34; INPUT_VIDEO=&#34;$2&#34; INPUT_SRT=&#34;$3&#34; OUTPUT_VIDEO=&#34;output_vertical_$(date &#43;%s).mp4&#34; TEMP_DIR=&#34;temp_segments_$$&#34; if [ ! -f &#34;$INPUT_VIDEO&#34; ]; then echo &#34;Error: El archivo &#39;$INPUT_VIDEO&#39; no existe&#34; exit 1 fi USE_SUBTITLES=0 if [ -n &#34;$INPUT_SRT&#34; ]; then if [ ! -f &#34;$INPUT_SRT&#34; ]; then echo &#34;Error: El archivo de subtÃ­tulos &#39;$INPUT_SRT&#39; no existe&#34; exit 1 fi USE_SUBTITLES=1 echo &#34;âœ“ Se quemarÃ¡n subtÃ­tulos desde: $INPUT_SRT&#34; fi # Verificar ffmpeg if ! command -v ffmpeg &amp;&gt; /dev/null; then echo &#34;Error: ffmpeg no estÃ¡ instalado&#34; exit 1 fi # Verificar bc if ! command -v bc &amp;&gt; /dev/null; then echo &#34;Error: bc no estÃ¡ instalado (necesario para cÃ¡lculos)&#34; exit 1 fi echo &#34;========================================&#34; echo &#34;Cortador y Concatenador de Videos&#34; echo &#34;========================================&#34; echo &#34;Video: $INPUT_VIDEO&#34; echo &#34;Segmentos: $SEGMENTS&#34; echo &#34;&#34; # Crear directorio temporal mkdir -p &#34;$TEMP_DIR&#34; # Obtener dimensiones del video echo &#34;Analizando video...&#34; VIDEO_INFO=$(ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 &#34;$INPUT_VIDEO&#34;) WIDTH=$(echo &#34;$VIDEO_INFO&#34; | cut -d&#39;x&#39; -f1) HEIGHT=$(echo &#34;$VIDEO_INFO&#34; | cut -d&#39;x&#39; -f2) echo &#34;Dimensiones originales: ${WIDTH}x${HEIGHT}&#34; # Calcular dimensiones de cada cuadro QUAD_WIDTH=$((WIDTH / 4)) echo &#34;Ancho de cada cuadro: ${QUAD_WIDTH}px&#34; # Dimensiones verticales para redes sociales (9:16) VERTICAL_WIDTH=1080 VERTICAL_HEIGHT=1920 echo &#34;&#34; echo &#34;Formato de salida: ${VERTICAL_WIDTH}x${VERTICAL_HEIGHT} (9:16 - vertical)&#34; echo &#34;&#34; # FunciÃ³n para convertir timestamp SRT a segundos timestamp_to_seconds() { local timestamp=&#34;$1&#34; local hours=$(echo &#34;$timestamp&#34; | cut -d&#39;:&#39; -f1 | sed &#39;s/^0*//&#39;) local minutes=$(echo &#34;$timestamp&#34; | cut -d&#39;:&#39; -f2 | sed &#39;s/^0*//&#39;) local seconds=$(echo &#34;$timestamp&#34; | cut -d&#39;:&#39; -f3 | cut -d&#39;,&#39; -f1 | sed &#39;s/^0*//&#39;) local milliseconds=$(echo &#34;$timestamp&#34; | cut -d&#39;,&#39; -f2 | sed &#39;s/^0*//&#39;) [ -z &#34;$hours&#34; ] &amp;&amp; hours=0 [ -z &#34;$minutes&#34; ] &amp;&amp; minutes=0 [ -z &#34;$seconds&#34; ] &amp;&amp; seconds=0 [ -z &#34;$milliseconds&#34; ] &amp;&amp; milliseconds=0 echo &#34;$hours * 3600 &#43; $minutes * 60 &#43; $seconds &#43; $milliseconds / 1000&#34; | bc -l } # FunciÃ³n para convertir segundos a timestamp SRT seconds_to_timestamp() { local total_seconds=&#34;$1&#34; if (( $(echo &#34;$total_seconds &lt; 0&#34; | bc -l) )); then echo &#34;00:00:00,000&#34; return fi local hours=$(printf &#34;%.0f&#34; $(echo &#34;$total_seconds / 3600&#34; | bc -l)) local remainder=$(echo &#34;$total_seconds - ($hours * 3600)&#34; | bc -l) local minutes=$(printf &#34;%.0f&#34; $(echo &#34;$remainder / 60&#34; | bc -l)) local seconds_decimal=$(echo &#34;$remainder - ($minutes * 60)&#34; | bc -l) local secs_int=$(printf &#34;%.0f&#34; $(echo &#34;$seconds_decimal&#34; | bc -l)) local milliseconds=$(printf &#34;%.0f&#34; $(echo &#34;($seconds_decimal - $secs_int) * 1000&#34; | bc -l)) printf &#34;%02d:%02d:%02d,%03d&#34; &#34;$hours&#34; &#34;$minutes&#34; &#34;$secs_int&#34; &#34;$milliseconds&#34; } # Procesar segmentos y crear SRT ajustado si es necesario segment_num=0 concat_file=&#34;$TEMP_DIR/concat_list.txt&#34; &gt; &#34;$concat_file&#34; if [ $USE_SUBTITLES -eq 1 ]; then ADJUSTED_SRT=&#34;$TEMP_DIR/adjusted_subtitles.srt&#34; &gt; &#34;$ADJUSTED_SRT&#34; subtitle_counter=1 echo &#34;Procesando subtÃ­tulos globalmente...&#34; # Parsear todos los segmentos primero declare -a seg_starts declare -a seg_durations seg_count=0 for seg in $SEGMENTS; do IFS=&#39;:&#39; read -r p s d &lt;&lt;&lt; &#34;$seg&#34; seg_starts[$seg_count]=$s seg_durations[$seg_count]=$d ((seg_count&#43;&#43;)) done # Procesar el SRT UNA SOLA VEZ y ELIMINAR SOLAPAMIENTOS in_subtitle=0 current_offset=0 current_text=&#34;&#34; last_end_time=0 while IFS= read -r line; do if [[ $line =~ ([0-9]{2}:[0-9]{2}:[0-9]{2},[0-9]{3})\ --\&gt;\ ([0-9]{2}:[0-9]{2}:[0-9]{2},[0-9]{3}) ]]; then start_ts=&#34;${BASH_REMATCH[1]}&#34; end_ts=&#34;${BASH_REMATCH[2]}&#34; start_sec=$(timestamp_to_seconds &#34;$start_ts&#34;) end_sec=$(timestamp_to_seconds &#34;$end_ts&#34;) # Buscar en quÃ© segmento(s) cae este subtÃ­tulo current_offset=0 found=0 for ((i=0; i&lt;seg_count; i&#43;&#43;)); do seg_start=${seg_starts[$i]} seg_dur=${seg_durations[$i]} seg_end=$(echo &#34;$seg_start &#43; $seg_dur&#34; | bc) # Si el subtÃ­tulo cruza este segmento if (( $(echo &#34;$start_sec &lt; $seg_end &amp;&amp; $end_sec &gt; $seg_start&#34; | bc -l) )); then new_start=$(echo &#34;$start_sec - $seg_start &#43; $current_offset&#34; | bc -l) new_end=$(echo &#34;$end_sec - $seg_start &#43; $current_offset&#34; | bc -l) if (( $(echo &#34;$new_start &lt; $current_offset&#34; | bc -l) )); then new_start=$current_offset fi # EVITAR SOLAPAMIENTO: Si empieza antes de que termine el anterior, ajustar if (( $(echo &#34;$new_start &lt; $last_end_time&#34; | bc -l) )); then new_start=$last_end_time fi if (( $(echo &#34;$new_end &gt; $new_start &#43; 0.1&#34; | bc -l) )); then new_start_ts=$(seconds_to_timestamp &#34;$new_start&#34;) new_end_ts=$(seconds_to_timestamp &#34;$new_end&#34;) in_subtitle=1 found=1 current_text=&#34;$subtitle_counter $new_start_ts --&gt; $new_end_ts &#34; ((subtitle_counter&#43;&#43;)) last_end_time=$new_end break fi fi current_offset=$(echo &#34;$current_offset &#43; $seg_dur&#34; | bc -l) done if [ $found -eq 0 ]; then in_subtitle=0 current_text=&#34;&#34; fi elif [ -n &#34;$line&#34; ]; then if [ $in_subtitle -eq 1 ] &amp;&amp; [[ ! $line =~ ^[0-9]&#43;$ ]]; then current_text=&#34;${current_text}${line} &#34; fi elif [ -z &#34;$line&#34; ] &amp;&amp; [ $in_subtitle -eq 1 ]; then echo -n &#34;$current_text&#34; &gt;&gt; &#34;$ADJUSTED_SRT&#34; echo &#34;&#34; &gt;&gt; &#34;$ADJUSTED_SRT&#34; in_subtitle=0 current_text=&#34;&#34; fi done &lt; &#34;$INPUT_SRT&#34; echo &#34;âœ“ SubtÃ­tulos procesados (sin solapamientos)&#34; fi # Arrays para guardar info de segmentos declare -a segment_starts declare -a segment_durations for segment in $SEGMENTS; do IFS=&#39;:&#39; read -r person start_time duration &lt;&lt;&lt; &#34;$segment&#34; if [ &#34;$person&#34; -lt 1 ] || [ &#34;$person&#34; -gt 4 ]; then echo &#34;Error: Persona debe estar entre 1 y 4&#34; exit 1 fi if [ &#34;$duration&#34; -le 0 ]; then echo &#34;Error: DuraciÃ³n debe ser positiva (segmento: $segment)&#34; exit 1 fi segment_starts[$segment_num]=$start_time segment_durations[$segment_num]=$duration end_time=$(echo &#34;$start_time &#43; $duration&#34; | bc) case $person in 1) crop_x=0 ;; 2) crop_x=$QUAD_WIDTH ;; 3) crop_x=$((QUAD_WIDTH * 2)) ;; 4) crop_x=$((QUAD_WIDTH * 3)) ;; esac output_segment=&#34;$TEMP_DIR/segment_${segment_num}.mp4&#34; echo &#34;----------------------------------------&#34; echo &#34;Segmento $((segment_num &#43; 1)):&#34; echo &#34; Persona: $person&#34; echo &#34; Inicio: ${start_time}s | DuraciÃ³n: ${duration}s | Fin: ${end_time}s&#34; echo &#34; Crop X: $crop_x&#34; echo &#34; Procesando video...&#34; # Construir filtro de video vf_filter=&#34;crop=${QUAD_WIDTH}:${HEIGHT}:${crop_x}:0,scale=${VERTICAL_WIDTH}:${VERTICAL_HEIGHT}:force_original_aspect_ratio=decrease,pad=${VERTICAL_WIDTH}:${VERTICAL_HEIGHT}:(ow-iw)/2:(oh-ih)/2:black,setsar=1&#34; ffmpeg -y -ss &#34;$start_time&#34; -t &#34;$duration&#34; -i &#34;$INPUT_VIDEO&#34; \ -vf &#34;$vf_filter&#34; \ -c:v libx264 -preset fast -crf 18 \ -c:a aac -b:a 192k \ -movflags &#43;faststart \ &#34;$output_segment&#34; 2&gt;&amp;1 | grep -E &#34;(time=|Duration|error|Error)&#34; | tail -3 || true if [ $? -eq 0 ] &amp;&amp; [ -f &#34;$output_segment&#34; ]; then file_size=$(stat -c%s &#34;$output_segment&#34; 2&gt;/dev/null || stat -f%z &#34;$output_segment&#34; 2&gt;/dev/null) if [ &#34;$file_size&#34; -gt 1000 ]; then echo &#34; âœ“ Segmento creado (${file_size} bytes)&#34; echo &#34;file &#39;$(basename &#34;$output_segment&#34;)&#39;&#34; &gt;&gt; &#34;$concat_file&#34; else echo &#34; âœ— Error: Segmento vacÃ­o&#34; exit 1 fi else echo &#34; âœ— Error al crear segmento&#34; exit 1 fi ((segment_num&#43;&#43;)) done echo &#34;&#34; echo &#34;========================================&#34; echo &#34;Concatenando $segment_num segmentos...&#34; echo &#34;========================================&#34; if [ ! -s &#34;$concat_file&#34; ]; then echo &#34;âœ— Error: No hay segmentos para concatenar&#34; exit 1 fi # Concatenar segmentos TEMP_OUTPUT=&#34;$TEMP_DIR/temp_concatenated.mp4&#34; cd &#34;$TEMP_DIR&#34; ffmpeg -y -f concat -safe 0 -i &#34;concat_list.txt&#34; \ -c copy \ -movflags &#43;faststart \ &#34;temp_concatenated.mp4&#34; 2&gt;&amp;1 | grep -E &#34;(time=|Duration|error|Error)&#34; | tail -3 || true cd .. if [ ! -f &#34;$TEMP_OUTPUT&#34; ]; then echo &#34;âœ— Error al concatenar segmentos&#34; exit 1 fi # Quemar subtÃ­tulos si existen if [ $USE_SUBTITLES -eq 1 ] &amp;&amp; [ -f &#34;$ADJUSTED_SRT&#34; ]; then echo &#34;&#34; echo &#34;========================================&#34; echo &#34;Quemando subtÃ­tulos...&#34; echo &#34;========================================&#34; # Escapar ruta del SRT para ffmpeg ESCAPED_SRT=$(echo &#34;$ADJUSTED_SRT&#34; | sed &#39;s/\\/\\\\/g; s/:/\\:/g; s/&#39;\&#39;&#39;/&#39;\&#39;\\\\\\\&#39;\&#39;&#39;/g&#39;) ffmpeg -y -i &#34;$TEMP_OUTPUT&#34; \ -vf &#34;subtitles=&#39;$ESCAPED_SRT&#39;:force_style=&#39;FontName=Arial,FontSize=11,Bold=1,PrimaryColour=&amp;H00FFFFFF,OutlineColour=&amp;H00000000,BackColour=&amp;H99000000,BorderStyle=4,Outline=1,Shadow=0,MarginV=50,Alignment=2&#39;&#34; \ -c:v libx264 -preset medium -crf 18 \ -c:a copy \ -movflags &#43;faststart \ &#34;$OUTPUT_VIDEO&#34; 2&gt;&amp;1 | grep -E &#34;(time=|Duration|error|Error)&#34; | tail -5 || true else # Sin subtÃ­tulos, solo mover el archivo mv &#34;$TEMP_OUTPUT&#34; &#34;$OUTPUT_VIDEO&#34; fi if [ -f &#34;$OUTPUT_VIDEO&#34; ]; then echo &#34;&#34; echo &#34;âœ“âœ“âœ“ VIDEO COMPLETADO âœ“âœ“âœ“&#34; echo &#34;========================================&#34; echo &#34;Archivo: $OUTPUT_VIDEO&#34; TOTAL_DURATION=$(ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 &#34;$OUTPUT_VIDEO&#34; 2&gt;/dev/null | cut -d&#39;.&#39; -f1) [ -n &#34;$TOTAL_DURATION&#34; ] &amp;&amp; echo &#34;DuraciÃ³n total: ${TOTAL_DURATION}s&#34; FILE_SIZE=$(du -h &#34;$OUTPUT_VIDEO&#34; | cut -f1) echo &#34;TamaÃ±o: $FILE_SIZE&#34; if [ $USE_SUBTITLES -eq 1 ]; then echo &#34;âœ“ SubtÃ­tulos quemados en el video&#34; fi echo &#34;&#34; echo &#34;Â¿Eliminar archivos temporales? (S/n)&#34; read -t 5 -r response || response=&#34;s&#34; if [[ &#34;$response&#34; != &#34;n&#34; &amp;&amp; &#34;$response&#34; != &#34;N&#34; ]]; then rm -rf &#34;$TEMP_DIR&#34; echo &#34;âœ“ Archivos temporales eliminados&#34; else echo &#34;â†’ Temporales en: $TEMP_DIR&#34; [ -f &#34;$ADJUSTED_SRT&#34; ] &amp;&amp; echo &#34;â†’ SRT ajustado: $ADJUSTED_SRT&#34; fi else echo &#34;âœ— Error al crear video final&#34; exit 1 fi echo &#34;&#34; echo &#34;Â¡Listo para subir a las redes! ðŸš€ðŸ”¥&#34;">

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>
    
    Claude make short
    
  </title>
  <link rel="stylesheet" href='https://imlauera.github.io/css/site.min.css'>
  <link rel="canonical" href="https://imlauera.github.io/claude_make_short/">
  <link rel="alternate" type="application/rss&#43;xml" href="https://imlauera.github.io/index.xml" title="Imlauer">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="referrer" content="no-referrer">
  <meta name="author" content="Imlauer.">
  <meta name="description" content="#!/bin/bash

# Script para dividir video horizontal en 4 cuadros verticales, concatenar segmentos y quemar subtÃ­tulos
# Uso: ./concat.sh &#34;persona:inicio:duracion persona:inicio:duracion ...&#34; video.mp4 [subtitulos.srt]

if [ $# -lt 2 ]; then
    echo &#34;Uso: $0 \&#34;segmentos\&#34; video.mp4 [subtitulos.srt]&#34;
    echo &#34;&#34;
    echo &#34;Formato de segmentos: \&#34;persona:inicio:duracion persona:inicio:duracion ...\&#34;&#34;
    echo &#34;  persona: 1-4 (de izquierda a derecha)&#34;
    echo &#34;  inicio: segundo de inicio&#34;
    echo &#34;  duracion: duraciÃ³n en segundos del corte&#34;
    echo &#34;&#34;
    echo &#34;Ejemplo SIN subtÃ­tulos:&#34;
    echo &#34;  $0 \&#34;1:1140:3 3:1144:2\&#34; video.mp4&#34;
    echo &#34;&#34;
    echo &#34;Ejemplo CON subtÃ­tulos:&#34;
    echo &#34;  $0 \&#34;1:1140:3 3:1144:2\&#34; video.mp4 subtitulos.srt&#34;
    exit 1
fi

SEGMENTS=&#34;$1&#34;
INPUT_VIDEO=&#34;$2&#34;
INPUT_SRT=&#34;$3&#34;
OUTPUT_VIDEO=&#34;output_vertical_$(date &#43;%s).mp4&#34;
TEMP_DIR=&#34;temp_segments_$$&#34;

if [ ! -f &#34;$INPUT_VIDEO&#34; ]; then
    echo &#34;Error: El archivo &#39;$INPUT_VIDEO&#39; no existe&#34;
    exit 1
fi

USE_SUBTITLES=0
if [ -n &#34;$INPUT_SRT&#34; ]; then
    if [ ! -f &#34;$INPUT_SRT&#34; ]; then
        echo &#34;Error: El archivo de subtÃ­tulos &#39;$INPUT_SRT&#39; no existe&#34;
        exit 1
    fi
    USE_SUBTITLES=1
    echo &#34;âœ“ Se quemarÃ¡n subtÃ­tulos desde: $INPUT_SRT&#34;
fi

# Verificar ffmpeg
if ! command -v ffmpeg &amp;&gt; /dev/null; then
    echo &#34;Error: ffmpeg no estÃ¡ instalado&#34;
    exit 1
fi

# Verificar bc
if ! command -v bc &amp;&gt; /dev/null; then
    echo &#34;Error: bc no estÃ¡ instalado (necesario para cÃ¡lculos)&#34;
    exit 1
fi

echo &#34;========================================&#34;
echo &#34;Cortador y Concatenador de Videos&#34;
echo &#34;========================================&#34;
echo &#34;Video: $INPUT_VIDEO&#34;
echo &#34;Segmentos: $SEGMENTS&#34;
echo &#34;&#34;

# Crear directorio temporal
mkdir -p &#34;$TEMP_DIR&#34;

# Obtener dimensiones del video
echo &#34;Analizando video...&#34;
VIDEO_INFO=$(ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 &#34;$INPUT_VIDEO&#34;)
WIDTH=$(echo &#34;$VIDEO_INFO&#34; | cut -d&#39;x&#39; -f1)
HEIGHT=$(echo &#34;$VIDEO_INFO&#34; | cut -d&#39;x&#39; -f2)

echo &#34;Dimensiones originales: ${WIDTH}x${HEIGHT}&#34;

# Calcular dimensiones de cada cuadro
QUAD_WIDTH=$((WIDTH / 4))
echo &#34;Ancho de cada cuadro: ${QUAD_WIDTH}px&#34;

# Dimensiones verticales para redes sociales (9:16)
VERTICAL_WIDTH=1080
VERTICAL_HEIGHT=1920

echo &#34;&#34;
echo &#34;Formato de salida: ${VERTICAL_WIDTH}x${VERTICAL_HEIGHT} (9:16 - vertical)&#34;
echo &#34;&#34;

# FunciÃ³n para convertir timestamp SRT a segundos
timestamp_to_seconds() {
    local timestamp=&#34;$1&#34;
    local hours=$(echo &#34;$timestamp&#34; | cut -d&#39;:&#39; -f1 | sed &#39;s/^0*//&#39;)
    local minutes=$(echo &#34;$timestamp&#34; | cut -d&#39;:&#39; -f2 | sed &#39;s/^0*//&#39;)
    local seconds=$(echo &#34;$timestamp&#34; | cut -d&#39;:&#39; -f3 | cut -d&#39;,&#39; -f1 | sed &#39;s/^0*//&#39;)
    local milliseconds=$(echo &#34;$timestamp&#34; | cut -d&#39;,&#39; -f2 | sed &#39;s/^0*//&#39;)
    
    [ -z &#34;$hours&#34; ] &amp;&amp; hours=0
    [ -z &#34;$minutes&#34; ] &amp;&amp; minutes=0
    [ -z &#34;$seconds&#34; ] &amp;&amp; seconds=0
    [ -z &#34;$milliseconds&#34; ] &amp;&amp; milliseconds=0
    
    echo &#34;$hours * 3600 &#43; $minutes * 60 &#43; $seconds &#43; $milliseconds / 1000&#34; | bc -l
}

# FunciÃ³n para convertir segundos a timestamp SRT
seconds_to_timestamp() {
    local total_seconds=&#34;$1&#34;
    
    if (( $(echo &#34;$total_seconds &lt; 0&#34; | bc -l) )); then
        echo &#34;00:00:00,000&#34;
        return
    fi
    
    local hours=$(printf &#34;%.0f&#34; $(echo &#34;$total_seconds / 3600&#34; | bc -l))
    local remainder=$(echo &#34;$total_seconds - ($hours * 3600)&#34; | bc -l)
    local minutes=$(printf &#34;%.0f&#34; $(echo &#34;$remainder / 60&#34; | bc -l))
    local seconds_decimal=$(echo &#34;$remainder - ($minutes * 60)&#34; | bc -l)
    local secs_int=$(printf &#34;%.0f&#34; $(echo &#34;$seconds_decimal&#34; | bc -l))
    local milliseconds=$(printf &#34;%.0f&#34; $(echo &#34;($seconds_decimal - $secs_int) * 1000&#34; | bc -l))
    
    printf &#34;%02d:%02d:%02d,%03d&#34; &#34;$hours&#34; &#34;$minutes&#34; &#34;$secs_int&#34; &#34;$milliseconds&#34;
}

# Procesar segmentos y crear SRT ajustado si es necesario
segment_num=0
concat_file=&#34;$TEMP_DIR/concat_list.txt&#34;
&gt; &#34;$concat_file&#34;

if [ $USE_SUBTITLES -eq 1 ]; then
    ADJUSTED_SRT=&#34;$TEMP_DIR/adjusted_subtitles.srt&#34;
    &gt; &#34;$ADJUSTED_SRT&#34;
    subtitle_counter=1
    
    echo &#34;Procesando subtÃ­tulos globalmente...&#34;
    
    # Parsear todos los segmentos primero
    declare -a seg_starts
    declare -a seg_durations
    seg_count=0
    for seg in $SEGMENTS; do
        IFS=&#39;:&#39; read -r p s d &lt;&lt;&lt; &#34;$seg&#34;
        seg_starts[$seg_count]=$s
        seg_durations[$seg_count]=$d
        ((seg_count&#43;&#43;))
    done
    
    # Procesar el SRT UNA SOLA VEZ y ELIMINAR SOLAPAMIENTOS
    in_subtitle=0
    current_offset=0
    current_text=&#34;&#34;
    last_end_time=0
    
    while IFS= read -r line; do
        if [[ $line =~ ([0-9]{2}:[0-9]{2}:[0-9]{2},[0-9]{3})\ --\&gt;\ ([0-9]{2}:[0-9]{2}:[0-9]{2},[0-9]{3}) ]]; then
            start_ts=&#34;${BASH_REMATCH[1]}&#34;
            end_ts=&#34;${BASH_REMATCH[2]}&#34;
            
            start_sec=$(timestamp_to_seconds &#34;$start_ts&#34;)
            end_sec=$(timestamp_to_seconds &#34;$end_ts&#34;)
            
            # Buscar en quÃ© segmento(s) cae este subtÃ­tulo
            current_offset=0
            found=0
            for ((i=0; i&lt;seg_count; i&#43;&#43;)); do
                seg_start=${seg_starts[$i]}
                seg_dur=${seg_durations[$i]}
                seg_end=$(echo &#34;$seg_start &#43; $seg_dur&#34; | bc)
                
                # Si el subtÃ­tulo cruza este segmento
                if (( $(echo &#34;$start_sec &lt; $seg_end &amp;&amp; $end_sec &gt; $seg_start&#34; | bc -l) )); then
                    new_start=$(echo &#34;$start_sec - $seg_start &#43; $current_offset&#34; | bc -l)
                    new_end=$(echo &#34;$end_sec - $seg_start &#43; $current_offset&#34; | bc -l)
                    
                    if (( $(echo &#34;$new_start &lt; $current_offset&#34; | bc -l) )); then
                        new_start=$current_offset
                    fi
                    
                    # EVITAR SOLAPAMIENTO: Si empieza antes de que termine el anterior, ajustar
                    if (( $(echo &#34;$new_start &lt; $last_end_time&#34; | bc -l) )); then
                        new_start=$last_end_time
                    fi
                    
                    if (( $(echo &#34;$new_end &gt; $new_start &#43; 0.1&#34; | bc -l) )); then
                        new_start_ts=$(seconds_to_timestamp &#34;$new_start&#34;)
                        new_end_ts=$(seconds_to_timestamp &#34;$new_end&#34;)
                        in_subtitle=1
                        found=1
                        current_text=&#34;$subtitle_counter
$new_start_ts --&gt; $new_end_ts
&#34;
                        ((subtitle_counter&#43;&#43;))
                        last_end_time=$new_end
                        break
                    fi
                fi
                current_offset=$(echo &#34;$current_offset &#43; $seg_dur&#34; | bc -l)
            done
            
            if [ $found -eq 0 ]; then
                in_subtitle=0
                current_text=&#34;&#34;
            fi
        elif [ -n &#34;$line&#34; ]; then
            if [ $in_subtitle -eq 1 ] &amp;&amp; [[ ! $line =~ ^[0-9]&#43;$ ]]; then
                current_text=&#34;${current_text}${line}
&#34;
            fi
        elif [ -z &#34;$line&#34; ] &amp;&amp; [ $in_subtitle -eq 1 ]; then
            echo -n &#34;$current_text&#34; &gt;&gt; &#34;$ADJUSTED_SRT&#34;
            echo &#34;&#34; &gt;&gt; &#34;$ADJUSTED_SRT&#34;
            in_subtitle=0
            current_text=&#34;&#34;
        fi
    done &lt; &#34;$INPUT_SRT&#34;
    
    echo &#34;âœ“ SubtÃ­tulos procesados (sin solapamientos)&#34;
fi

# Arrays para guardar info de segmentos
declare -a segment_starts
declare -a segment_durations

for segment in $SEGMENTS; do
    IFS=&#39;:&#39; read -r person start_time duration &lt;&lt;&lt; &#34;$segment&#34;
    
    if [ &#34;$person&#34; -lt 1 ] || [ &#34;$person&#34; -gt 4 ]; then
        echo &#34;Error: Persona debe estar entre 1 y 4&#34;
        exit 1
    fi
    
    if [ &#34;$duration&#34; -le 0 ]; then
        echo &#34;Error: DuraciÃ³n debe ser positiva (segmento: $segment)&#34;
        exit 1
    fi
    
    segment_starts[$segment_num]=$start_time
    segment_durations[$segment_num]=$duration
    
    end_time=$(echo &#34;$start_time &#43; $duration&#34; | bc)
    
    case $person in
        1) crop_x=0 ;;
        2) crop_x=$QUAD_WIDTH ;;
        3) crop_x=$((QUAD_WIDTH * 2)) ;;
        4) crop_x=$((QUAD_WIDTH * 3)) ;;
    esac
    
    output_segment=&#34;$TEMP_DIR/segment_${segment_num}.mp4&#34;
    
    echo &#34;----------------------------------------&#34;
    echo &#34;Segmento $((segment_num &#43; 1)):&#34;
    echo &#34;  Persona: $person&#34;
    echo &#34;  Inicio: ${start_time}s | DuraciÃ³n: ${duration}s | Fin: ${end_time}s&#34;
    echo &#34;  Crop X: $crop_x&#34;
    echo &#34;  Procesando video...&#34;
    
    # Construir filtro de video
    vf_filter=&#34;crop=${QUAD_WIDTH}:${HEIGHT}:${crop_x}:0,scale=${VERTICAL_WIDTH}:${VERTICAL_HEIGHT}:force_original_aspect_ratio=decrease,pad=${VERTICAL_WIDTH}:${VERTICAL_HEIGHT}:(ow-iw)/2:(oh-ih)/2:black,setsar=1&#34;
    
    ffmpeg -y -ss &#34;$start_time&#34; -t &#34;$duration&#34; -i &#34;$INPUT_VIDEO&#34; \
        -vf &#34;$vf_filter&#34; \
        -c:v libx264 -preset fast -crf 18 \
        -c:a aac -b:a 192k \
        -movflags &#43;faststart \
        &#34;$output_segment&#34; 2&gt;&amp;1 | grep -E &#34;(time=|Duration|error|Error)&#34; | tail -3 || true
    
    if [ $? -eq 0 ] &amp;&amp; [ -f &#34;$output_segment&#34; ]; then
        file_size=$(stat -c%s &#34;$output_segment&#34; 2&gt;/dev/null || stat -f%z &#34;$output_segment&#34; 2&gt;/dev/null)
        if [ &#34;$file_size&#34; -gt 1000 ]; then
            echo &#34;  âœ“ Segmento creado (${file_size} bytes)&#34;
            echo &#34;file &#39;$(basename &#34;$output_segment&#34;)&#39;&#34; &gt;&gt; &#34;$concat_file&#34;
        else
            echo &#34;  âœ— Error: Segmento vacÃ­o&#34;
            exit 1
        fi
    else
        echo &#34;  âœ— Error al crear segmento&#34;
        exit 1
    fi
    
    ((segment_num&#43;&#43;))
done

echo &#34;&#34;
echo &#34;========================================&#34;
echo &#34;Concatenando $segment_num segmentos...&#34;
echo &#34;========================================&#34;

if [ ! -s &#34;$concat_file&#34; ]; then
    echo &#34;âœ— Error: No hay segmentos para concatenar&#34;
    exit 1
fi

# Concatenar segmentos
TEMP_OUTPUT=&#34;$TEMP_DIR/temp_concatenated.mp4&#34;
cd &#34;$TEMP_DIR&#34;
ffmpeg -y -f concat -safe 0 -i &#34;concat_list.txt&#34; \
    -c copy \
    -movflags &#43;faststart \
    &#34;temp_concatenated.mp4&#34; 2&gt;&amp;1 | grep -E &#34;(time=|Duration|error|Error)&#34; | tail -3 || true
cd ..

if [ ! -f &#34;$TEMP_OUTPUT&#34; ]; then
    echo &#34;âœ— Error al concatenar segmentos&#34;
    exit 1
fi

# Quemar subtÃ­tulos si existen
if [ $USE_SUBTITLES -eq 1 ] &amp;&amp; [ -f &#34;$ADJUSTED_SRT&#34; ]; then
    echo &#34;&#34;
    echo &#34;========================================&#34;
    echo &#34;Quemando subtÃ­tulos...&#34;
    echo &#34;========================================&#34;
    
    # Escapar ruta del SRT para ffmpeg
    ESCAPED_SRT=$(echo &#34;$ADJUSTED_SRT&#34; | sed &#39;s/\\/\\\\/g; s/:/\\:/g; s/&#39;\&#39;&#39;/&#39;\&#39;\\\\\\\&#39;\&#39;&#39;/g&#39;)
    
    ffmpeg -y -i &#34;$TEMP_OUTPUT&#34; \
        -vf &#34;subtitles=&#39;$ESCAPED_SRT&#39;:force_style=&#39;FontName=Arial,FontSize=11,Bold=1,PrimaryColour=&amp;H00FFFFFF,OutlineColour=&amp;H00000000,BackColour=&amp;H99000000,BorderStyle=4,Outline=1,Shadow=0,MarginV=50,Alignment=2&#39;&#34; \
        -c:v libx264 -preset medium -crf 18 \
        -c:a copy \
        -movflags &#43;faststart \
        &#34;$OUTPUT_VIDEO&#34; 2&gt;&amp;1 | grep -E &#34;(time=|Duration|error|Error)&#34; | tail -5 || true
else
    # Sin subtÃ­tulos, solo mover el archivo
    mv &#34;$TEMP_OUTPUT&#34; &#34;$OUTPUT_VIDEO&#34;
fi

if [ -f &#34;$OUTPUT_VIDEO&#34; ]; then
    echo &#34;&#34;
    echo &#34;âœ“âœ“âœ“ VIDEO COMPLETADO âœ“âœ“âœ“&#34;
    echo &#34;========================================&#34;
    echo &#34;Archivo: $OUTPUT_VIDEO&#34;
    
    TOTAL_DURATION=$(ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 &#34;$OUTPUT_VIDEO&#34; 2&gt;/dev/null | cut -d&#39;.&#39; -f1)
    [ -n &#34;$TOTAL_DURATION&#34; ] &amp;&amp; echo &#34;DuraciÃ³n total: ${TOTAL_DURATION}s&#34;
    
    FILE_SIZE=$(du -h &#34;$OUTPUT_VIDEO&#34; | cut -f1)
    echo &#34;TamaÃ±o: $FILE_SIZE&#34;
    
    if [ $USE_SUBTITLES -eq 1 ]; then
        echo &#34;âœ“ SubtÃ­tulos quemados en el video&#34;
    fi
    
    echo &#34;&#34;
    echo &#34;Â¿Eliminar archivos temporales? (S/n)&#34;
    read -t 5 -r response || response=&#34;s&#34;
    if [[ &#34;$response&#34; != &#34;n&#34; &amp;&amp; &#34;$response&#34; != &#34;N&#34; ]]; then
        rm -rf &#34;$TEMP_DIR&#34;
        echo &#34;âœ“ Archivos temporales eliminados&#34;
    else
        echo &#34;â†’ Temporales en: $TEMP_DIR&#34;
        [ -f &#34;$ADJUSTED_SRT&#34; ] &amp;&amp; echo &#34;â†’ SRT ajustado: $ADJUSTED_SRT&#34;
    fi
else
    echo &#34;âœ— Error al crear video final&#34;
    exit 1
fi

echo &#34;&#34;
echo &#34;Â¡Listo para subir a las redes! ðŸš€ðŸ”¥&#34;
">
</head>
<body><nav class="navbar is-transparent " role="navigation" aria-label="main navigation">
  <div class="navbar-brand">
    <a class="navbar-item" href="https://imlauera.github.io/">
      <figure class="image">
        <img alt="" class="is-rounded" src="/img/memememe.jpg">
      </figure>
    </a>
    <a class="navbar-item" href="https://imlauera.github.io/">
      Imlauer
    </a>
    <a class="navbar-item" href="/acerca/">
      Acerca de Mi
    </a>
  </div>
  
  
</nav>

  <section>
    <section class='hero is-small is-link is-fullwidth'>
      <div class="hero-body">
<div class="container">
  <h1 class="title">
    Claude make short
  </h1>
  <h2 class="subtitle">
    <time datetime='2025-12-21T01:06:58-03:00'>
      December 21, 2025
    </time>
    
  </h2>
</div>

      </div>
    </section>
    <section class="section">
      <div class="container">
<div class="content is-medium">
  <div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e">#!/bin/bash
</span></span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Script para dividir video horizontal en 4 cuadros verticales, concatenar segmentos y quemar subtÃ­tulos</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Uso: ./concat.sh &#34;persona:inicio:duracion persona:inicio:duracion ...&#34; video.mp4 [subtitulos.srt]</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> <span style="color:#f92672">[</span> $# -lt <span style="color:#ae81ff">2</span> <span style="color:#f92672">]</span>; <span style="color:#66d9ef">then</span>
</span></span><span style="display:flex;"><span>    echo <span style="color:#e6db74">&#34;Uso: </span>$0<span style="color:#e6db74"> \&#34;segmentos\&#34; video.mp4 [subtitulos.srt]&#34;</span>
</span></span><span style="display:flex;"><span>    echo <span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    echo <span style="color:#e6db74">&#34;Formato de segmentos: \&#34;persona:inicio:duracion persona:inicio:duracion ...\&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    echo <span style="color:#e6db74">&#34;  persona: 1-4 (de izquierda a derecha)&#34;</span>
</span></span><span style="display:flex;"><span>    echo <span style="color:#e6db74">&#34;  inicio: segundo de inicio&#34;</span>
</span></span><span style="display:flex;"><span>    echo <span style="color:#e6db74">&#34;  duracion: duraciÃ³n en segundos del corte&#34;</span>
</span></span><span style="display:flex;"><span>    echo <span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    echo <span style="color:#e6db74">&#34;Ejemplo SIN subtÃ­tulos:&#34;</span>
</span></span><span style="display:flex;"><span>    echo <span style="color:#e6db74">&#34;  </span>$0<span style="color:#e6db74"> \&#34;1:1140:3 3:1144:2\&#34; video.mp4&#34;</span>
</span></span><span style="display:flex;"><span>    echo <span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    echo <span style="color:#e6db74">&#34;Ejemplo CON subtÃ­tulos:&#34;</span>
</span></span><span style="display:flex;"><span>    echo <span style="color:#e6db74">&#34;  </span>$0<span style="color:#e6db74"> \&#34;1:1140:3 3:1144:2\&#34; video.mp4 subtitulos.srt&#34;</span>
</span></span><span style="display:flex;"><span>    exit <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fi</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>SEGMENTS<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;</span>$1<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>INPUT_VIDEO<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;</span>$2<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>INPUT_SRT<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;</span>$3<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>OUTPUT_VIDEO<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;output_vertical_</span><span style="color:#66d9ef">$(</span>date +%s<span style="color:#66d9ef">)</span><span style="color:#e6db74">.mp4&#34;</span>
</span></span><span style="display:flex;"><span>TEMP_DIR<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;temp_segments_</span>$$<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> <span style="color:#f92672">[</span> ! -f <span style="color:#e6db74">&#34;</span>$INPUT_VIDEO<span style="color:#e6db74">&#34;</span> <span style="color:#f92672">]</span>; <span style="color:#66d9ef">then</span>
</span></span><span style="display:flex;"><span>    echo <span style="color:#e6db74">&#34;Error: El archivo &#39;</span>$INPUT_VIDEO<span style="color:#e6db74">&#39; no existe&#34;</span>
</span></span><span style="display:flex;"><span>    exit <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fi</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>USE_SUBTITLES<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> <span style="color:#f92672">[</span> -n <span style="color:#e6db74">&#34;</span>$INPUT_SRT<span style="color:#e6db74">&#34;</span> <span style="color:#f92672">]</span>; <span style="color:#66d9ef">then</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">[</span> ! -f <span style="color:#e6db74">&#34;</span>$INPUT_SRT<span style="color:#e6db74">&#34;</span> <span style="color:#f92672">]</span>; <span style="color:#66d9ef">then</span>
</span></span><span style="display:flex;"><span>        echo <span style="color:#e6db74">&#34;Error: El archivo de subtÃ­tulos &#39;</span>$INPUT_SRT<span style="color:#e6db74">&#39; no existe&#34;</span>
</span></span><span style="display:flex;"><span>        exit <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fi</span>
</span></span><span style="display:flex;"><span>    USE_SUBTITLES<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    echo <span style="color:#e6db74">&#34;âœ“ Se quemarÃ¡n subtÃ­tulos desde: </span>$INPUT_SRT<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fi</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Verificar ffmpeg</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> ! command -v ffmpeg &amp;&gt; /dev/null; <span style="color:#66d9ef">then</span>
</span></span><span style="display:flex;"><span>    echo <span style="color:#e6db74">&#34;Error: ffmpeg no estÃ¡ instalado&#34;</span>
</span></span><span style="display:flex;"><span>    exit <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fi</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Verificar bc</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> ! command -v bc &amp;&gt; /dev/null; <span style="color:#66d9ef">then</span>
</span></span><span style="display:flex;"><span>    echo <span style="color:#e6db74">&#34;Error: bc no estÃ¡ instalado (necesario para cÃ¡lculos)&#34;</span>
</span></span><span style="display:flex;"><span>    exit <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fi</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;========================================&#34;</span>
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;Cortador y Concatenador de Videos&#34;</span>
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;========================================&#34;</span>
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;Video: </span>$INPUT_VIDEO<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;Segmentos: </span>$SEGMENTS<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Crear directorio temporal</span>
</span></span><span style="display:flex;"><span>mkdir -p <span style="color:#e6db74">&#34;</span>$TEMP_DIR<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Obtener dimensiones del video</span>
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;Analizando video...&#34;</span>
</span></span><span style="display:flex;"><span>VIDEO_INFO<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>ffprobe -v error -select_streams v:0 -show_entries stream<span style="color:#f92672">=</span>width,height -of csv<span style="color:#f92672">=</span>s<span style="color:#f92672">=</span>x:p<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span> <span style="color:#e6db74">&#34;</span>$INPUT_VIDEO<span style="color:#e6db74">&#34;</span><span style="color:#66d9ef">)</span>
</span></span><span style="display:flex;"><span>WIDTH<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>echo <span style="color:#e6db74">&#34;</span>$VIDEO_INFO<span style="color:#e6db74">&#34;</span> | cut -d<span style="color:#e6db74">&#39;x&#39;</span> -f1<span style="color:#66d9ef">)</span>
</span></span><span style="display:flex;"><span>HEIGHT<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>echo <span style="color:#e6db74">&#34;</span>$VIDEO_INFO<span style="color:#e6db74">&#34;</span> | cut -d<span style="color:#e6db74">&#39;x&#39;</span> -f2<span style="color:#66d9ef">)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;Dimensiones originales: </span><span style="color:#e6db74">${</span>WIDTH<span style="color:#e6db74">}</span><span style="color:#e6db74">x</span><span style="color:#e6db74">${</span>HEIGHT<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Calcular dimensiones de cada cuadro</span>
</span></span><span style="display:flex;"><span>QUAD_WIDTH<span style="color:#f92672">=</span><span style="color:#66d9ef">$((</span>WIDTH <span style="color:#f92672">/</span> <span style="color:#ae81ff">4</span><span style="color:#66d9ef">))</span>
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;Ancho de cada cuadro: </span><span style="color:#e6db74">${</span>QUAD_WIDTH<span style="color:#e6db74">}</span><span style="color:#e6db74">px&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Dimensiones verticales para redes sociales (9:16)</span>
</span></span><span style="display:flex;"><span>VERTICAL_WIDTH<span style="color:#f92672">=</span><span style="color:#ae81ff">1080</span>
</span></span><span style="display:flex;"><span>VERTICAL_HEIGHT<span style="color:#f92672">=</span><span style="color:#ae81ff">1920</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;Formato de salida: </span><span style="color:#e6db74">${</span>VERTICAL_WIDTH<span style="color:#e6db74">}</span><span style="color:#e6db74">x</span><span style="color:#e6db74">${</span>VERTICAL_HEIGHT<span style="color:#e6db74">}</span><span style="color:#e6db74"> (9:16 - vertical)&#34;</span>
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># FunciÃ³n para convertir timestamp SRT a segundos</span>
</span></span><span style="display:flex;"><span>timestamp_to_seconds<span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    local timestamp<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;</span>$1<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>    local hours<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>echo <span style="color:#e6db74">&#34;</span>$timestamp<span style="color:#e6db74">&#34;</span> | cut -d<span style="color:#e6db74">&#39;:&#39;</span> -f1 | sed <span style="color:#e6db74">&#39;s/^0*//&#39;</span><span style="color:#66d9ef">)</span>
</span></span><span style="display:flex;"><span>    local minutes<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>echo <span style="color:#e6db74">&#34;</span>$timestamp<span style="color:#e6db74">&#34;</span> | cut -d<span style="color:#e6db74">&#39;:&#39;</span> -f2 | sed <span style="color:#e6db74">&#39;s/^0*//&#39;</span><span style="color:#66d9ef">)</span>
</span></span><span style="display:flex;"><span>    local seconds<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>echo <span style="color:#e6db74">&#34;</span>$timestamp<span style="color:#e6db74">&#34;</span> | cut -d<span style="color:#e6db74">&#39;:&#39;</span> -f3 | cut -d<span style="color:#e6db74">&#39;,&#39;</span> -f1 | sed <span style="color:#e6db74">&#39;s/^0*//&#39;</span><span style="color:#66d9ef">)</span>
</span></span><span style="display:flex;"><span>    local milliseconds<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>echo <span style="color:#e6db74">&#34;</span>$timestamp<span style="color:#e6db74">&#34;</span> | cut -d<span style="color:#e6db74">&#39;,&#39;</span> -f2 | sed <span style="color:#e6db74">&#39;s/^0*//&#39;</span><span style="color:#66d9ef">)</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">[</span> -z <span style="color:#e6db74">&#34;</span>$hours<span style="color:#e6db74">&#34;</span> <span style="color:#f92672">]</span> <span style="color:#f92672">&amp;&amp;</span> hours<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">[</span> -z <span style="color:#e6db74">&#34;</span>$minutes<span style="color:#e6db74">&#34;</span> <span style="color:#f92672">]</span> <span style="color:#f92672">&amp;&amp;</span> minutes<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">[</span> -z <span style="color:#e6db74">&#34;</span>$seconds<span style="color:#e6db74">&#34;</span> <span style="color:#f92672">]</span> <span style="color:#f92672">&amp;&amp;</span> seconds<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">[</span> -z <span style="color:#e6db74">&#34;</span>$milliseconds<span style="color:#e6db74">&#34;</span> <span style="color:#f92672">]</span> <span style="color:#f92672">&amp;&amp;</span> milliseconds<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    echo <span style="color:#e6db74">&#34;</span>$hours<span style="color:#e6db74"> * 3600 + </span>$minutes<span style="color:#e6db74"> * 60 + </span>$seconds<span style="color:#e6db74"> + </span>$milliseconds<span style="color:#e6db74"> / 1000&#34;</span> | bc -l
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># FunciÃ³n para convertir segundos a timestamp SRT</span>
</span></span><span style="display:flex;"><span>seconds_to_timestamp<span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    local total_seconds<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;</span>$1<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span> <span style="color:#66d9ef">$(</span>echo <span style="color:#e6db74">&#34;</span>$total_seconds<span style="color:#e6db74"> &lt; 0&#34;</span> | bc -l<span style="color:#66d9ef">)</span> <span style="color:#f92672">))</span>; <span style="color:#66d9ef">then</span>
</span></span><span style="display:flex;"><span>        echo <span style="color:#e6db74">&#34;00:00:00,000&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fi</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    local hours<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>printf <span style="color:#e6db74">&#34;%.0f&#34;</span> <span style="color:#66d9ef">$(</span>echo <span style="color:#e6db74">&#34;</span>$total_seconds<span style="color:#e6db74"> / 3600&#34;</span> | bc -l<span style="color:#66d9ef">))</span>
</span></span><span style="display:flex;"><span>    local remainder<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>echo <span style="color:#e6db74">&#34;</span>$total_seconds<span style="color:#e6db74"> - (</span>$hours<span style="color:#e6db74"> * 3600)&#34;</span> | bc -l<span style="color:#66d9ef">)</span>
</span></span><span style="display:flex;"><span>    local minutes<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>printf <span style="color:#e6db74">&#34;%.0f&#34;</span> <span style="color:#66d9ef">$(</span>echo <span style="color:#e6db74">&#34;</span>$remainder<span style="color:#e6db74"> / 60&#34;</span> | bc -l<span style="color:#66d9ef">))</span>
</span></span><span style="display:flex;"><span>    local seconds_decimal<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>echo <span style="color:#e6db74">&#34;</span>$remainder<span style="color:#e6db74"> - (</span>$minutes<span style="color:#e6db74"> * 60)&#34;</span> | bc -l<span style="color:#66d9ef">)</span>
</span></span><span style="display:flex;"><span>    local secs_int<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>printf <span style="color:#e6db74">&#34;%.0f&#34;</span> <span style="color:#66d9ef">$(</span>echo <span style="color:#e6db74">&#34;</span>$seconds_decimal<span style="color:#e6db74">&#34;</span> | bc -l<span style="color:#66d9ef">))</span>
</span></span><span style="display:flex;"><span>    local milliseconds<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>printf <span style="color:#e6db74">&#34;%.0f&#34;</span> <span style="color:#66d9ef">$(</span>echo <span style="color:#e6db74">&#34;(</span>$seconds_decimal<span style="color:#e6db74"> - </span>$secs_int<span style="color:#e6db74">) * 1000&#34;</span> | bc -l<span style="color:#66d9ef">))</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    printf <span style="color:#e6db74">&#34;%02d:%02d:%02d,%03d&#34;</span> <span style="color:#e6db74">&#34;</span>$hours<span style="color:#e6db74">&#34;</span> <span style="color:#e6db74">&#34;</span>$minutes<span style="color:#e6db74">&#34;</span> <span style="color:#e6db74">&#34;</span>$secs_int<span style="color:#e6db74">&#34;</span> <span style="color:#e6db74">&#34;</span>$milliseconds<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Procesar segmentos y crear SRT ajustado si es necesario</span>
</span></span><span style="display:flex;"><span>segment_num<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>concat_file<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;</span>$TEMP_DIR<span style="color:#e6db74">/concat_list.txt&#34;</span>
</span></span><span style="display:flex;"><span>&gt; <span style="color:#e6db74">&#34;</span>$concat_file<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> <span style="color:#f92672">[</span> $USE_SUBTITLES -eq <span style="color:#ae81ff">1</span> <span style="color:#f92672">]</span>; <span style="color:#66d9ef">then</span>
</span></span><span style="display:flex;"><span>    ADJUSTED_SRT<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;</span>$TEMP_DIR<span style="color:#e6db74">/adjusted_subtitles.srt&#34;</span>
</span></span><span style="display:flex;"><span>    &gt; <span style="color:#e6db74">&#34;</span>$ADJUSTED_SRT<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>    subtitle_counter<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    echo <span style="color:#e6db74">&#34;Procesando subtÃ­tulos globalmente...&#34;</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Parsear todos los segmentos primero</span>
</span></span><span style="display:flex;"><span>    declare -a seg_starts
</span></span><span style="display:flex;"><span>    declare -a seg_durations
</span></span><span style="display:flex;"><span>    seg_count<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> seg in $SEGMENTS; <span style="color:#66d9ef">do</span>
</span></span><span style="display:flex;"><span>        IFS<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;:&#39;</span> read -r p s d <span style="color:#f92672">&lt;&lt;&lt;</span> <span style="color:#e6db74">&#34;</span>$seg<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>        seg_starts<span style="color:#f92672">[</span>$seg_count<span style="color:#f92672">]=</span>$s
</span></span><span style="display:flex;"><span>        seg_durations<span style="color:#f92672">[</span>$seg_count<span style="color:#f92672">]=</span>$d
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">((</span>seg_count++<span style="color:#f92672">))</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">done</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Procesar el SRT UNA SOLA VEZ y ELIMINAR SOLAPAMIENTOS</span>
</span></span><span style="display:flex;"><span>    in_subtitle<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    current_offset<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    current_text<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    last_end_time<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> IFS<span style="color:#f92672">=</span> read -r line; <span style="color:#66d9ef">do</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">[[</span> $line <span style="color:#f92672">=</span>~ <span style="color:#f92672">([</span>0-9<span style="color:#f92672">]{</span>2<span style="color:#f92672">}</span>:<span style="color:#f92672">[</span>0-9<span style="color:#f92672">]{</span>2<span style="color:#f92672">}</span>:<span style="color:#f92672">[</span>0-9<span style="color:#f92672">]{</span>2<span style="color:#f92672">}</span>,<span style="color:#f92672">[</span>0-9<span style="color:#f92672">]{</span>3<span style="color:#f92672">})</span><span style="color:#ae81ff">\ </span>--<span style="color:#ae81ff">\&gt;\ </span><span style="color:#f92672">([</span>0-9<span style="color:#f92672">]{</span>2<span style="color:#f92672">}</span>:<span style="color:#f92672">[</span>0-9<span style="color:#f92672">]{</span>2<span style="color:#f92672">}</span>:<span style="color:#f92672">[</span>0-9<span style="color:#f92672">]{</span>2<span style="color:#f92672">}</span>,<span style="color:#f92672">[</span>0-9<span style="color:#f92672">]{</span>3<span style="color:#f92672">})</span> <span style="color:#f92672">]]</span>; <span style="color:#66d9ef">then</span>
</span></span><span style="display:flex;"><span>            start_ts<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>BASH_REMATCH[1]<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>            end_ts<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>BASH_REMATCH[2]<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>            start_sec<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>timestamp_to_seconds <span style="color:#e6db74">&#34;</span>$start_ts<span style="color:#e6db74">&#34;</span><span style="color:#66d9ef">)</span>
</span></span><span style="display:flex;"><span>            end_sec<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>timestamp_to_seconds <span style="color:#e6db74">&#34;</span>$end_ts<span style="color:#e6db74">&#34;</span><span style="color:#66d9ef">)</span>
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># Buscar en quÃ© segmento(s) cae este subtÃ­tulo</span>
</span></span><span style="display:flex;"><span>            current_offset<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>            found<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> <span style="color:#f92672">((</span>i<span style="color:#f92672">=</span>0; i&lt;seg_count; i++<span style="color:#f92672">))</span>; <span style="color:#66d9ef">do</span>
</span></span><span style="display:flex;"><span>                seg_start<span style="color:#f92672">=</span><span style="color:#e6db74">${</span>seg_starts[$i]<span style="color:#e6db74">}</span>
</span></span><span style="display:flex;"><span>                seg_dur<span style="color:#f92672">=</span><span style="color:#e6db74">${</span>seg_durations[$i]<span style="color:#e6db74">}</span>
</span></span><span style="display:flex;"><span>                seg_end<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>echo <span style="color:#e6db74">&#34;</span>$seg_start<span style="color:#e6db74"> + </span>$seg_dur<span style="color:#e6db74">&#34;</span> | bc<span style="color:#66d9ef">)</span>
</span></span><span style="display:flex;"><span>                
</span></span><span style="display:flex;"><span>                <span style="color:#75715e"># Si el subtÃ­tulo cruza este segmento</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span> <span style="color:#66d9ef">$(</span>echo <span style="color:#e6db74">&#34;</span>$start_sec<span style="color:#e6db74"> &lt; </span>$seg_end<span style="color:#e6db74"> &amp;&amp; </span>$end_sec<span style="color:#e6db74"> &gt; </span>$seg_start<span style="color:#e6db74">&#34;</span> | bc -l<span style="color:#66d9ef">)</span> <span style="color:#f92672">))</span>; <span style="color:#66d9ef">then</span>
</span></span><span style="display:flex;"><span>                    new_start<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>echo <span style="color:#e6db74">&#34;</span>$start_sec<span style="color:#e6db74"> - </span>$seg_start<span style="color:#e6db74"> + </span>$current_offset<span style="color:#e6db74">&#34;</span> | bc -l<span style="color:#66d9ef">)</span>
</span></span><span style="display:flex;"><span>                    new_end<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>echo <span style="color:#e6db74">&#34;</span>$end_sec<span style="color:#e6db74"> - </span>$seg_start<span style="color:#e6db74"> + </span>$current_offset<span style="color:#e6db74">&#34;</span> | bc -l<span style="color:#66d9ef">)</span>
</span></span><span style="display:flex;"><span>                    
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span> <span style="color:#66d9ef">$(</span>echo <span style="color:#e6db74">&#34;</span>$new_start<span style="color:#e6db74"> &lt; </span>$current_offset<span style="color:#e6db74">&#34;</span> | bc -l<span style="color:#66d9ef">)</span> <span style="color:#f92672">))</span>; <span style="color:#66d9ef">then</span>
</span></span><span style="display:flex;"><span>                        new_start<span style="color:#f92672">=</span>$current_offset
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">fi</span>
</span></span><span style="display:flex;"><span>                    
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e"># EVITAR SOLAPAMIENTO: Si empieza antes de que termine el anterior, ajustar</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span> <span style="color:#66d9ef">$(</span>echo <span style="color:#e6db74">&#34;</span>$new_start<span style="color:#e6db74"> &lt; </span>$last_end_time<span style="color:#e6db74">&#34;</span> | bc -l<span style="color:#66d9ef">)</span> <span style="color:#f92672">))</span>; <span style="color:#66d9ef">then</span>
</span></span><span style="display:flex;"><span>                        new_start<span style="color:#f92672">=</span>$last_end_time
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">fi</span>
</span></span><span style="display:flex;"><span>                    
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span> <span style="color:#66d9ef">$(</span>echo <span style="color:#e6db74">&#34;</span>$new_end<span style="color:#e6db74"> &gt; </span>$new_start<span style="color:#e6db74"> + 0.1&#34;</span> | bc -l<span style="color:#66d9ef">)</span> <span style="color:#f92672">))</span>; <span style="color:#66d9ef">then</span>
</span></span><span style="display:flex;"><span>                        new_start_ts<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>seconds_to_timestamp <span style="color:#e6db74">&#34;</span>$new_start<span style="color:#e6db74">&#34;</span><span style="color:#66d9ef">)</span>
</span></span><span style="display:flex;"><span>                        new_end_ts<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>seconds_to_timestamp <span style="color:#e6db74">&#34;</span>$new_end<span style="color:#e6db74">&#34;</span><span style="color:#66d9ef">)</span>
</span></span><span style="display:flex;"><span>                        in_subtitle<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>                        found<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>                        current_text<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;</span>$subtitle_counter<span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span>$new_start_ts<span style="color:#e6db74"> --&gt; </span>$new_end_ts<span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>                        <span style="color:#f92672">((</span>subtitle_counter++<span style="color:#f92672">))</span>
</span></span><span style="display:flex;"><span>                        last_end_time<span style="color:#f92672">=</span>$new_end
</span></span><span style="display:flex;"><span>                        break
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">fi</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">fi</span>
</span></span><span style="display:flex;"><span>                current_offset<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>echo <span style="color:#e6db74">&#34;</span>$current_offset<span style="color:#e6db74"> + </span>$seg_dur<span style="color:#e6db74">&#34;</span> | bc -l<span style="color:#66d9ef">)</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">done</span>
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">[</span> $found -eq <span style="color:#ae81ff">0</span> <span style="color:#f92672">]</span>; <span style="color:#66d9ef">then</span>
</span></span><span style="display:flex;"><span>                in_subtitle<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>                current_text<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">fi</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">elif</span> <span style="color:#f92672">[</span> -n <span style="color:#e6db74">&#34;</span>$line<span style="color:#e6db74">&#34;</span> <span style="color:#f92672">]</span>; <span style="color:#66d9ef">then</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">[</span> $in_subtitle -eq <span style="color:#ae81ff">1</span> <span style="color:#f92672">]</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">[[</span> ! $line <span style="color:#f92672">=</span>~ ^<span style="color:#f92672">[</span>0-9<span style="color:#f92672">]</span>+$ <span style="color:#f92672">]]</span>; <span style="color:#66d9ef">then</span>
</span></span><span style="display:flex;"><span>                current_text<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>current_text<span style="color:#e6db74">}${</span>line<span style="color:#e6db74">}</span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">fi</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">elif</span> <span style="color:#f92672">[</span> -z <span style="color:#e6db74">&#34;</span>$line<span style="color:#e6db74">&#34;</span> <span style="color:#f92672">]</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">[</span> $in_subtitle -eq <span style="color:#ae81ff">1</span> <span style="color:#f92672">]</span>; <span style="color:#66d9ef">then</span>
</span></span><span style="display:flex;"><span>            echo -n <span style="color:#e6db74">&#34;</span>$current_text<span style="color:#e6db74">&#34;</span> &gt;&gt; <span style="color:#e6db74">&#34;</span>$ADJUSTED_SRT<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>            echo <span style="color:#e6db74">&#34;&#34;</span> &gt;&gt; <span style="color:#e6db74">&#34;</span>$ADJUSTED_SRT<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>            in_subtitle<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>            current_text<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">fi</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">done</span> &lt; <span style="color:#e6db74">&#34;</span>$INPUT_SRT<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    echo <span style="color:#e6db74">&#34;âœ“ SubtÃ­tulos procesados (sin solapamientos)&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fi</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Arrays para guardar info de segmentos</span>
</span></span><span style="display:flex;"><span>declare -a segment_starts
</span></span><span style="display:flex;"><span>declare -a segment_durations
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> segment in $SEGMENTS; <span style="color:#66d9ef">do</span>
</span></span><span style="display:flex;"><span>    IFS<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;:&#39;</span> read -r person start_time duration <span style="color:#f92672">&lt;&lt;&lt;</span> <span style="color:#e6db74">&#34;</span>$segment<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">[</span> <span style="color:#e6db74">&#34;</span>$person<span style="color:#e6db74">&#34;</span> -lt <span style="color:#ae81ff">1</span> <span style="color:#f92672">]</span> <span style="color:#f92672">||</span> <span style="color:#f92672">[</span> <span style="color:#e6db74">&#34;</span>$person<span style="color:#e6db74">&#34;</span> -gt <span style="color:#ae81ff">4</span> <span style="color:#f92672">]</span>; <span style="color:#66d9ef">then</span>
</span></span><span style="display:flex;"><span>        echo <span style="color:#e6db74">&#34;Error: Persona debe estar entre 1 y 4&#34;</span>
</span></span><span style="display:flex;"><span>        exit <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fi</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">[</span> <span style="color:#e6db74">&#34;</span>$duration<span style="color:#e6db74">&#34;</span> -le <span style="color:#ae81ff">0</span> <span style="color:#f92672">]</span>; <span style="color:#66d9ef">then</span>
</span></span><span style="display:flex;"><span>        echo <span style="color:#e6db74">&#34;Error: DuraciÃ³n debe ser positiva (segmento: </span>$segment<span style="color:#e6db74">)&#34;</span>
</span></span><span style="display:flex;"><span>        exit <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fi</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    segment_starts<span style="color:#f92672">[</span>$segment_num<span style="color:#f92672">]=</span>$start_time
</span></span><span style="display:flex;"><span>    segment_durations<span style="color:#f92672">[</span>$segment_num<span style="color:#f92672">]=</span>$duration
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    end_time<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>echo <span style="color:#e6db74">&#34;</span>$start_time<span style="color:#e6db74"> + </span>$duration<span style="color:#e6db74">&#34;</span> | bc<span style="color:#66d9ef">)</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> $person in
</span></span><span style="display:flex;"><span>        1<span style="color:#f92672">)</span> crop_x<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span> ;;
</span></span><span style="display:flex;"><span>        2<span style="color:#f92672">)</span> crop_x<span style="color:#f92672">=</span>$QUAD_WIDTH ;;
</span></span><span style="display:flex;"><span>        3<span style="color:#f92672">)</span> crop_x<span style="color:#f92672">=</span><span style="color:#66d9ef">$((</span>QUAD_WIDTH <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span><span style="color:#66d9ef">))</span> ;;
</span></span><span style="display:flex;"><span>        4<span style="color:#f92672">)</span> crop_x<span style="color:#f92672">=</span><span style="color:#66d9ef">$((</span>QUAD_WIDTH <span style="color:#f92672">*</span> <span style="color:#ae81ff">3</span><span style="color:#66d9ef">))</span> ;;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">esac</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    output_segment<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;</span>$TEMP_DIR<span style="color:#e6db74">/segment_</span><span style="color:#e6db74">${</span>segment_num<span style="color:#e6db74">}</span><span style="color:#e6db74">.mp4&#34;</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    echo <span style="color:#e6db74">&#34;----------------------------------------&#34;</span>
</span></span><span style="display:flex;"><span>    echo <span style="color:#e6db74">&#34;Segmento </span><span style="color:#66d9ef">$((</span>segment_num <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span><span style="color:#66d9ef">))</span><span style="color:#e6db74">:&#34;</span>
</span></span><span style="display:flex;"><span>    echo <span style="color:#e6db74">&#34;  Persona: </span>$person<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>    echo <span style="color:#e6db74">&#34;  Inicio: </span><span style="color:#e6db74">${</span>start_time<span style="color:#e6db74">}</span><span style="color:#e6db74">s | DuraciÃ³n: </span><span style="color:#e6db74">${</span>duration<span style="color:#e6db74">}</span><span style="color:#e6db74">s | Fin: </span><span style="color:#e6db74">${</span>end_time<span style="color:#e6db74">}</span><span style="color:#e6db74">s&#34;</span>
</span></span><span style="display:flex;"><span>    echo <span style="color:#e6db74">&#34;  Crop X: </span>$crop_x<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>    echo <span style="color:#e6db74">&#34;  Procesando video...&#34;</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Construir filtro de video</span>
</span></span><span style="display:flex;"><span>    vf_filter<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;crop=</span><span style="color:#e6db74">${</span>QUAD_WIDTH<span style="color:#e6db74">}</span><span style="color:#e6db74">:</span><span style="color:#e6db74">${</span>HEIGHT<span style="color:#e6db74">}</span><span style="color:#e6db74">:</span><span style="color:#e6db74">${</span>crop_x<span style="color:#e6db74">}</span><span style="color:#e6db74">:0,scale=</span><span style="color:#e6db74">${</span>VERTICAL_WIDTH<span style="color:#e6db74">}</span><span style="color:#e6db74">:</span><span style="color:#e6db74">${</span>VERTICAL_HEIGHT<span style="color:#e6db74">}</span><span style="color:#e6db74">:force_original_aspect_ratio=decrease,pad=</span><span style="color:#e6db74">${</span>VERTICAL_WIDTH<span style="color:#e6db74">}</span><span style="color:#e6db74">:</span><span style="color:#e6db74">${</span>VERTICAL_HEIGHT<span style="color:#e6db74">}</span><span style="color:#e6db74">:(ow-iw)/2:(oh-ih)/2:black,setsar=1&#34;</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    ffmpeg -y -ss <span style="color:#e6db74">&#34;</span>$start_time<span style="color:#e6db74">&#34;</span> -t <span style="color:#e6db74">&#34;</span>$duration<span style="color:#e6db74">&#34;</span> -i <span style="color:#e6db74">&#34;</span>$INPUT_VIDEO<span style="color:#e6db74">&#34;</span> <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span>        -vf <span style="color:#e6db74">&#34;</span>$vf_filter<span style="color:#e6db74">&#34;</span> <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span>        -c:v libx264 -preset fast -crf <span style="color:#ae81ff">18</span> <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span>        -c:a aac -b:a 192k <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span>        -movflags +faststart <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;</span>$output_segment<span style="color:#e6db74">&#34;</span> 2&gt;&amp;<span style="color:#ae81ff">1</span> | grep -E <span style="color:#e6db74">&#34;(time=|Duration|error|Error)&#34;</span> | tail -3 <span style="color:#f92672">||</span> true
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">[</span> $? -eq <span style="color:#ae81ff">0</span> <span style="color:#f92672">]</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">[</span> -f <span style="color:#e6db74">&#34;</span>$output_segment<span style="color:#e6db74">&#34;</span> <span style="color:#f92672">]</span>; <span style="color:#66d9ef">then</span>
</span></span><span style="display:flex;"><span>        file_size<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>stat -c%s <span style="color:#e6db74">&#34;</span>$output_segment<span style="color:#e6db74">&#34;</span> 2&gt;/dev/null <span style="color:#f92672">||</span> stat -f%z <span style="color:#e6db74">&#34;</span>$output_segment<span style="color:#e6db74">&#34;</span> 2&gt;/dev/null<span style="color:#66d9ef">)</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">[</span> <span style="color:#e6db74">&#34;</span>$file_size<span style="color:#e6db74">&#34;</span> -gt <span style="color:#ae81ff">1000</span> <span style="color:#f92672">]</span>; <span style="color:#66d9ef">then</span>
</span></span><span style="display:flex;"><span>            echo <span style="color:#e6db74">&#34;  âœ“ Segmento creado (</span><span style="color:#e6db74">${</span>file_size<span style="color:#e6db74">}</span><span style="color:#e6db74"> bytes)&#34;</span>
</span></span><span style="display:flex;"><span>            echo <span style="color:#e6db74">&#34;file &#39;</span><span style="color:#66d9ef">$(</span>basename <span style="color:#e6db74">&#34;</span>$output_segment<span style="color:#e6db74">&#34;</span><span style="color:#66d9ef">)</span><span style="color:#e6db74">&#39;&#34;</span> &gt;&gt; <span style="color:#e6db74">&#34;</span>$concat_file<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>            echo <span style="color:#e6db74">&#34;  âœ— Error: Segmento vacÃ­o&#34;</span>
</span></span><span style="display:flex;"><span>            exit <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">fi</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>        echo <span style="color:#e6db74">&#34;  âœ— Error al crear segmento&#34;</span>
</span></span><span style="display:flex;"><span>        exit <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fi</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">((</span>segment_num++<span style="color:#f92672">))</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">done</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;========================================&#34;</span>
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;Concatenando </span>$segment_num<span style="color:#e6db74"> segmentos...&#34;</span>
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;========================================&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> <span style="color:#f92672">[</span> ! -s <span style="color:#e6db74">&#34;</span>$concat_file<span style="color:#e6db74">&#34;</span> <span style="color:#f92672">]</span>; <span style="color:#66d9ef">then</span>
</span></span><span style="display:flex;"><span>    echo <span style="color:#e6db74">&#34;âœ— Error: No hay segmentos para concatenar&#34;</span>
</span></span><span style="display:flex;"><span>    exit <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fi</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Concatenar segmentos</span>
</span></span><span style="display:flex;"><span>TEMP_OUTPUT<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;</span>$TEMP_DIR<span style="color:#e6db74">/temp_concatenated.mp4&#34;</span>
</span></span><span style="display:flex;"><span>cd <span style="color:#e6db74">&#34;</span>$TEMP_DIR<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>ffmpeg -y -f concat -safe <span style="color:#ae81ff">0</span> -i <span style="color:#e6db74">&#34;concat_list.txt&#34;</span> <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span>    -c copy <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span>    -movflags +faststart <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;temp_concatenated.mp4&#34;</span> 2&gt;&amp;<span style="color:#ae81ff">1</span> | grep -E <span style="color:#e6db74">&#34;(time=|Duration|error|Error)&#34;</span> | tail -3 <span style="color:#f92672">||</span> true
</span></span><span style="display:flex;"><span>cd ..
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> <span style="color:#f92672">[</span> ! -f <span style="color:#e6db74">&#34;</span>$TEMP_OUTPUT<span style="color:#e6db74">&#34;</span> <span style="color:#f92672">]</span>; <span style="color:#66d9ef">then</span>
</span></span><span style="display:flex;"><span>    echo <span style="color:#e6db74">&#34;âœ— Error al concatenar segmentos&#34;</span>
</span></span><span style="display:flex;"><span>    exit <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fi</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Quemar subtÃ­tulos si existen</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> <span style="color:#f92672">[</span> $USE_SUBTITLES -eq <span style="color:#ae81ff">1</span> <span style="color:#f92672">]</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">[</span> -f <span style="color:#e6db74">&#34;</span>$ADJUSTED_SRT<span style="color:#e6db74">&#34;</span> <span style="color:#f92672">]</span>; <span style="color:#66d9ef">then</span>
</span></span><span style="display:flex;"><span>    echo <span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    echo <span style="color:#e6db74">&#34;========================================&#34;</span>
</span></span><span style="display:flex;"><span>    echo <span style="color:#e6db74">&#34;Quemando subtÃ­tulos...&#34;</span>
</span></span><span style="display:flex;"><span>    echo <span style="color:#e6db74">&#34;========================================&#34;</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Escapar ruta del SRT para ffmpeg</span>
</span></span><span style="display:flex;"><span>    ESCAPED_SRT<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>echo <span style="color:#e6db74">&#34;</span>$ADJUSTED_SRT<span style="color:#e6db74">&#34;</span> | sed <span style="color:#e6db74">&#39;s/\\/\\\\/g; s/:/\\:/g; s/&#39;</span><span style="color:#ae81ff">\&#39;</span><span style="color:#e6db74">&#39;/&#39;</span><span style="color:#ae81ff">\&#39;\\\\\\\&#39;\&#39;</span><span style="color:#e6db74">&#39;/g&#39;</span><span style="color:#66d9ef">)</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    ffmpeg -y -i <span style="color:#e6db74">&#34;</span>$TEMP_OUTPUT<span style="color:#e6db74">&#34;</span> <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span>        -vf <span style="color:#e6db74">&#34;subtitles=&#39;</span>$ESCAPED_SRT<span style="color:#e6db74">&#39;:force_style=&#39;FontName=Arial,FontSize=11,Bold=1,PrimaryColour=&amp;H00FFFFFF,OutlineColour=&amp;H00000000,BackColour=&amp;H99000000,BorderStyle=4,Outline=1,Shadow=0,MarginV=50,Alignment=2&#39;&#34;</span> <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span>        -c:v libx264 -preset medium -crf <span style="color:#ae81ff">18</span> <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span>        -c:a copy <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span>        -movflags +faststart <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;</span>$OUTPUT_VIDEO<span style="color:#e6db74">&#34;</span> 2&gt;&amp;<span style="color:#ae81ff">1</span> | grep -E <span style="color:#e6db74">&#34;(time=|Duration|error|Error)&#34;</span> | tail -5 <span style="color:#f92672">||</span> true
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Sin subtÃ­tulos, solo mover el archivo</span>
</span></span><span style="display:flex;"><span>    mv <span style="color:#e6db74">&#34;</span>$TEMP_OUTPUT<span style="color:#e6db74">&#34;</span> <span style="color:#e6db74">&#34;</span>$OUTPUT_VIDEO<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fi</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> <span style="color:#f92672">[</span> -f <span style="color:#e6db74">&#34;</span>$OUTPUT_VIDEO<span style="color:#e6db74">&#34;</span> <span style="color:#f92672">]</span>; <span style="color:#66d9ef">then</span>
</span></span><span style="display:flex;"><span>    echo <span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    echo <span style="color:#e6db74">&#34;âœ“âœ“âœ“ VIDEO COMPLETADO âœ“âœ“âœ“&#34;</span>
</span></span><span style="display:flex;"><span>    echo <span style="color:#e6db74">&#34;========================================&#34;</span>
</span></span><span style="display:flex;"><span>    echo <span style="color:#e6db74">&#34;Archivo: </span>$OUTPUT_VIDEO<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    TOTAL_DURATION<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>ffprobe -v error -show_entries format<span style="color:#f92672">=</span>duration -of default<span style="color:#f92672">=</span>noprint_wrappers<span style="color:#f92672">=</span>1:nokey<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span> <span style="color:#e6db74">&#34;</span>$OUTPUT_VIDEO<span style="color:#e6db74">&#34;</span> 2&gt;/dev/null | cut -d<span style="color:#e6db74">&#39;.&#39;</span> -f1<span style="color:#66d9ef">)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">[</span> -n <span style="color:#e6db74">&#34;</span>$TOTAL_DURATION<span style="color:#e6db74">&#34;</span> <span style="color:#f92672">]</span> <span style="color:#f92672">&amp;&amp;</span> echo <span style="color:#e6db74">&#34;DuraciÃ³n total: </span><span style="color:#e6db74">${</span>TOTAL_DURATION<span style="color:#e6db74">}</span><span style="color:#e6db74">s&#34;</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    FILE_SIZE<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>du -h <span style="color:#e6db74">&#34;</span>$OUTPUT_VIDEO<span style="color:#e6db74">&#34;</span> | cut -f1<span style="color:#66d9ef">)</span>
</span></span><span style="display:flex;"><span>    echo <span style="color:#e6db74">&#34;TamaÃ±o: </span>$FILE_SIZE<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">[</span> $USE_SUBTITLES -eq <span style="color:#ae81ff">1</span> <span style="color:#f92672">]</span>; <span style="color:#66d9ef">then</span>
</span></span><span style="display:flex;"><span>        echo <span style="color:#e6db74">&#34;âœ“ SubtÃ­tulos quemados en el video&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fi</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    echo <span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    echo <span style="color:#e6db74">&#34;Â¿Eliminar archivos temporales? (S/n)&#34;</span>
</span></span><span style="display:flex;"><span>    read -t <span style="color:#ae81ff">5</span> -r response <span style="color:#f92672">||</span> response<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;s&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">[[</span> <span style="color:#e6db74">&#34;</span>$response<span style="color:#e6db74">&#34;</span> !<span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;n&#34;</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#e6db74">&#34;</span>$response<span style="color:#e6db74">&#34;</span> !<span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;N&#34;</span> <span style="color:#f92672">]]</span>; <span style="color:#66d9ef">then</span>
</span></span><span style="display:flex;"><span>        rm -rf <span style="color:#e6db74">&#34;</span>$TEMP_DIR<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>        echo <span style="color:#e6db74">&#34;âœ“ Archivos temporales eliminados&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>        echo <span style="color:#e6db74">&#34;â†’ Temporales en: </span>$TEMP_DIR<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">[</span> -f <span style="color:#e6db74">&#34;</span>$ADJUSTED_SRT<span style="color:#e6db74">&#34;</span> <span style="color:#f92672">]</span> <span style="color:#f92672">&amp;&amp;</span> echo <span style="color:#e6db74">&#34;â†’ SRT ajustado: </span>$ADJUSTED_SRT<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fi</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>    echo <span style="color:#e6db74">&#34;âœ— Error al crear video final&#34;</span>
</span></span><span style="display:flex;"><span>    exit <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fi</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;Â¡Listo para subir a las redes! ðŸš€ðŸ”¥&#34;</span>
</span></span></code></pre></div>
</div>


      </div>
    </section>
  </section><script 
src="/quiz/quizdown.js">
</script>
<script 
src="/quiz/quizdownKatex.js">
</script>
<script 
src="/quiz/quizdownHighlight.js">
</script>
<script>quizdown.register(quizdownHighlight).register(quizdownKatex).init()</script> 
<footer class="footer">
  <div class="content has-text-centered">
    
    
    <p>
      
      <a class="" href="https://imlauera.github.io/index.xml" target="_blank">
        <span>
          RSS
        </span>
      </a>
      
      | <a href="https://imlauera.github.io" target="_blank">Andres Imlauer.</a> 

      
      
    </p>
    
  </div>




<script type="text/javascript"
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({ tex2jax: {inlineMath: [["$","$"],["\\(","\\)"]]} })
</script>
</footer>


</body>
</html>
