<!DOCTYPE html>
<html lang="es">





<head>
  <meta property="og:url" content="https://imlauera.github.io/post/segmentation_fault_in_c/">
  <meta property="og:site_name" content="Imlauer">
  <meta property="og:title" content="Error de Segmentación (Segmentation Fault) en C">
  <meta property="og:description" content="Escenarios comunes de fallas de segmentación En una falla de segmentación, un programa intenta acceder a una memoria a la que no está autorizado o que no existe. Algunos escenarios comunes que pueden causar fallas de segmentación son:
Modificar una cadena de solo lectura Acceder a una dirección que está liberada Acceder a límites de índice fuera de la matriz Uso inadecuado de scanf() Desbordamiento de pila Desreferenciación de puntero no inicializado 1. Modificar una cadena de sólo lectura Los literales de cadena se almacenan en la sección de solo lectura de la memoria. Es por eso que el siguiente programa puede fallar (da un error de segmentación) porque la línea *(str&#43;1) = ’n’ intenta escribir una memoria de solo lectura.">
  <meta property="og:locale" content="es_es">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2023-10-05T05:22:12-03:00">
    <meta property="article:modified_time" content="2023-10-05T05:22:12-03:00">
    <meta property="article:tag" content="C">
    <meta property="article:tag" content="Programacion">

  
  <meta itemprop="name" content="Error de Segmentación (Segmentation Fault) en C">
  <meta itemprop="description" content="Escenarios comunes de fallas de segmentación En una falla de segmentación, un programa intenta acceder a una memoria a la que no está autorizado o que no existe. Algunos escenarios comunes que pueden causar fallas de segmentación son:
Modificar una cadena de solo lectura Acceder a una dirección que está liberada Acceder a límites de índice fuera de la matriz Uso inadecuado de scanf() Desbordamiento de pila Desreferenciación de puntero no inicializado 1. Modificar una cadena de sólo lectura Los literales de cadena se almacenan en la sección de solo lectura de la memoria. Es por eso que el siguiente programa puede fallar (da un error de segmentación) porque la línea *(str&#43;1) = ’n’ intenta escribir una memoria de solo lectura.">
  <meta itemprop="datePublished" content="2023-10-05T05:22:12-03:00">
  <meta itemprop="dateModified" content="2023-10-05T05:22:12-03:00">
  <meta itemprop="wordCount" content="837">
  <meta itemprop="keywords" content="C,Programacion">
  
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Error de Segmentación (Segmentation Fault) en C">
  <meta name="twitter:description" content="Escenarios comunes de fallas de segmentación En una falla de segmentación, un programa intenta acceder a una memoria a la que no está autorizado o que no existe. Algunos escenarios comunes que pueden causar fallas de segmentación son:
Modificar una cadena de solo lectura Acceder a una dirección que está liberada Acceder a límites de índice fuera de la matriz Uso inadecuado de scanf() Desbordamiento de pila Desreferenciación de puntero no inicializado 1. Modificar una cadena de sólo lectura Los literales de cadena se almacenan en la sección de solo lectura de la memoria. Es por eso que el siguiente programa puede fallar (da un error de segmentación) porque la línea *(str&#43;1) = ’n’ intenta escribir una memoria de solo lectura.">

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>
    
    Error de Segmentación (Segmentation Fault) en C
    
  </title>
  <link rel="stylesheet" href='https://imlauera.github.io/css/site.min.css'>
  <link rel="canonical" href="https://imlauera.github.io/post/segmentation_fault_in_c/">
  <link rel="alternate" type="application/rss&#43;xml" href="https://imlauera.github.io/index.xml" title="Imlauer">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="referrer" content="no-referrer">
  <meta name="author" content="Imlauer.">
  <meta name="description" content="Escenarios comunes de fallas de segmentación
En una falla de segmentación, un programa intenta acceder a una memoria a la que no está autorizado o que no existe. Algunos escenarios comunes que pueden causar fallas de segmentación son:

Modificar una cadena de solo lectura
Acceder a una dirección que está liberada
Acceder a límites de índice fuera de la matriz
Uso inadecuado de scanf()
Desbordamiento de pila
Desreferenciación de puntero no inicializado

1. Modificar una cadena de sólo lectura
Los literales de cadena se almacenan en la sección de solo lectura de la memoria. Es por eso que el siguiente programa puede fallar (da un error de segmentación) porque la línea *(str&#43;1) = &rsquo;n&rsquo; intenta escribir una memoria de solo lectura.">
</head>
<body><nav class="navbar is-transparent " role="navigation" aria-label="main navigation">
  <div class="navbar-brand">
    <a class="navbar-item" href="https://imlauera.github.io/">
      <figure class="image">
        <img alt="" class="is-rounded" src="/img/memememe.jpg">
      </figure>
    </a>
    <a class="navbar-item" href="https://imlauera.github.io/">
      Imlauer
    </a>
    <a class="navbar-item" href="/acerca/">
      Acerca de Mi
    </a>
  </div>
  
  
</nav>

  <section>
    <section class='hero is-small is-link is-fullwidth'>
      <div class="hero-body">
<div class="container">
  <h1 class="title">
    Error de Segmentación (Segmentation Fault) en C
  </h1>
  <h2 class="subtitle">
    <time datetime='2023-10-05T05:22:12-03:00'>
      October 05, 2023
    </time>
    
    <br>
    
    
    
    <a class="tag is-info" href="https://imlauera.github.io/tags/c/">C</a>
    
    
    
    
    <a class="tag is-info" href="https://imlauera.github.io/tags/programacion/">Programacion</a>
    
    
    
  </h2>
</div>

      </div>
    </section>
    <section class="section">
      <div class="container">
<div class="content is-medium">
  <h3 id="escenarios-comunes-de-fallas-de-segmentación">Escenarios comunes de fallas de segmentación</h3>
<p>En una falla de segmentación, un programa intenta acceder a una memoria a la que no está autorizado o que no existe. Algunos escenarios comunes que pueden causar fallas de segmentación son:</p>
<ol>
<li>Modificar una cadena de solo lectura</li>
<li>Acceder a una dirección que está liberada</li>
<li>Acceder a límites de índice fuera de la matriz</li>
<li>Uso inadecuado de scanf()</li>
<li>Desbordamiento de pila</li>
<li>Desreferenciación de puntero no inicializado</li>
</ol>
<h4 id="1-modificar-una-cadena-de-sólo-lectura">1. Modificar una cadena de sólo lectura</h4>
<p>Los literales de cadena se almacenan en la sección de solo lectura de la memoria. Es por eso que el siguiente programa puede fallar (da un error de segmentación) porque la línea *(str+1) = &rsquo;n&rsquo; intenta escribir una memoria de solo lectura.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// Programa de C para demostrar error de segmento (segmentation fault)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// modificando una cadena de sólo lectura
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> str;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Se almacena en la parte de solo lectura del segmento de datos
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	str <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;GfG&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Problema: intentando modificar memoria de sólo lectura
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#f92672">*</span>(str <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;n&#39;</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="2-acceder-a-una-dirección-liberada">2. Acceder a una dirección liberada</h3>
<p>Aquí, en el siguiente código, se elimina la referencia al puntero p después de liberar el bloque de memoria, lo cual no está permitido por el compilador. Estos punteros se denominan punteros colgantes y producen fallos de segmento o terminaciones anormales del programa en tiempo de ejecución.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// Programa C para demostrar el error de segmentación
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Accediendo a una dirección que está liberada
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#incluir &lt;stdio.h&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#incluir &lt;stdlib.h&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">void</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// asignando memoria a p
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> p <span style="color:#f92672">=</span> (<span style="color:#66d9ef">int</span><span style="color:#f92672">*</span>)<span style="color:#a6e22e">malloc</span>(<span style="color:#ae81ff">8</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> <span style="color:#ae81ff">100</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// se libera el espacio asignado a p
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">free</span>(p);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// core dump/segmentation fault
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> <span style="color:#ae81ff">110</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%d&#34;</span>, <span style="color:#f92672">*</span>p);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="3-acceder-al-índice-de-matriz-fuera-de-límites">3. Acceder al índice de matriz fuera de límites</h4>
<p>En C y C++, acceder a un índice de matriz fuera de límites puede provocar un error de segmentación u otro comportamiento indefinido. No hay verificación de límites para matrices en C y C++. Aunque en C++, el uso de contenedores, como con el método std::vector::at() o con una declaración if(), puede evitar errores fuera de límite.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// programa C para demostrar la segmentación
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// falla cuando se accede a la matriz fuera de límite.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#incluir &lt;stdio.h&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">void</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> arr[<span style="color:#ae81ff">2</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Accediendo fuera de límites
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	arr[<span style="color:#ae81ff">3</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> (<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="4-uso-inadecuado-de-scanf">4. Uso inadecuado de scanf()</h4>
<p>La función scanf() espera la dirección de una variable como entrada. Aquí, en este programa, n toma un valor de 2 y asume que su dirección es 1000. Si pasamos n a scanf(), la entrada obtenida de STDIN se coloca en la memoria 2 no válida, que debería ser 1000. Esto provoca daños en la memoria y provoca un error de segmentación.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// Programa C para demostrar la segmentación
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// error cuando se pasa valor a scanf
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#incluir &lt;stdio.h&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">scanf</span>(<span style="color:#e6db74">&#34;%d&#34;</span>, n);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="5-desbordamiento-de-pila">5. Desbordamiento de pila</h4>
<p>No es un problema relacionado con el puntero, incluso es posible que el código no tenga un solo puntero. Es por quedarse sin memoria en la pila. También es un tipo de corrupción de memoria que puede ocurrir debido a un gran tamaño de matriz, una gran cantidad de llamadas recursivas, muchas variables locales, etc.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// Programa en C para ilustrar el
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// error de segmentación debido a
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// desbordamiento de pila
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#incluir &lt;stdio.h&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> arr[<span style="color:#ae81ff">2000000000</span>];
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="6-desbordamiento-del-búfer">6. Desbordamiento del búfer</h4>
<p>Si los datos que se almacenan en el búfer son mayores que el tamaño asignado del búfer, se produce un desbordamiento del búfer que provoca un error de segmentación. La mayoría de los métodos en lenguaje C no realizan verificación de límites, por lo que el desbordamiento del búfer ocurre con frecuencia cuando olvidamos asignar el tamaño requerido al búfer.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// Programa en C para ilustrar el
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// fallo de segmentación debido a
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// desbordamiento del buffer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#incluir &lt;stdio.h&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">char</span> ref[<span style="color:#ae81ff">20</span>] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Esta es una cadena larga&#34;</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">char</span> buf[<span style="color:#ae81ff">10</span>];
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">sscanf</span>(ref, <span style="color:#e6db74">&#34;%s&#34;</span>, buf);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="7-desreferenciar-un-puntero-null-o-no-inicializado">7. Desreferenciar un puntero NULL o no inicializado</h4>
<p>Es un error de programación común eliminar la referencia a un puntero no inicializado (puntero salvaje), lo que puede dar como resultado un comportamiento indefinido. Cuando se utiliza un puntero en un contexto que lo trata como un puntero válido y accede a su valor subyacente, aunque no se haya inicializado para apuntar a una ubicación de memoria válida, se produce este error. Esto puede provocar daños en los datos, errores de programa o fallos de segmentación. Dependiendo de su entorno y estado al eliminar la referencia, los punteros no inicializados pueden producir resultados diferentes.</p>
<p>Como sabemos, el puntero NULL no apunta a ninguna ubicación de memoria, por lo que eliminar la referencia resultará en un error de segmentación.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// Programa C para demostrar la segmentación
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// error cuando el puntero no está inicializado
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// se accede
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#incluir &lt;stdio.h&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> ptr;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> nptr <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%d %d&#34;</span>, <span style="color:#f92672">*</span>ptr, <span style="color:#f92672">*</span>nptr);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
</div>


      </div>
    </section>
  </section><script 
src="/quiz/quizdown.js">
</script>
<script 
src="/quiz/quizdownKatex.js">
</script>
<script 
src="/quiz/quizdownHighlight.js">
</script>
<script>quizdown.register(quizdownHighlight).register(quizdownKatex).init()</script> 
<footer class="footer">
  <div class="content has-text-centered">
    
    
    <p>
      
      <a class="" href="https://imlauera.github.io/index.xml" target="_blank">
        <span>
          RSS
        </span>
      </a>
      
      | <a href="https://imlauera.github.io" target="_blank">Andres Imlauer.</a> 

      
      
    </p>
    
  </div>




<script type="text/javascript"
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({ tex2jax: {inlineMath: [["$","$"],["\\(","\\)"]]} })
</script>
</footer>


</body>
</html>
