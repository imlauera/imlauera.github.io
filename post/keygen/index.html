<!DOCTYPE html>
<html lang="es">





<head>
  <meta property="og:url" content="https://imlauera.github.io/post/keygen/">
  <meta property="og:site_name" content="Imlauer">
  <meta property="og:title" content="Keygen si puedes">
  <meta property="og:description" content="El keygen se encuentra en: https://drive.google.com/file/d/1QRIk3zBGGXH54nSZorX3jnuNmURCHw6K/view?pli=1
El c贸digo que me gener贸 el ida es:
#include &lt;windows.h&gt; #include &lt;defs.h&gt; #include &lt;stdarg.h&gt; //------------------------------------------------------------------------- // Function declarations void __fastcall _mingw_invalidParameterHandler(const wchar_t *expression, const wchar_t *function, const wchar_t *file, unsigned int line, uintptr_t pReserved); int __cdecl pre_c_init(); void __cdecl pre_cpp_init(); // int __cdecl _tmainCRTStartup(); // int __cdecl WinMainCRTStartup(); int __cdecl mainCRTStartup(); char *__fastcall generaLetras(int a1, char *a2); __int64 __fastcall generaNumero(char *a1); // idb int __fastcall generaSerial(char *a1, char *a2); int __fastcall checkSerial(char *a1, char *a2); INT_PTR __fastcall DialogProc(HWND a1, int a2, unsigned __int16 a3); int __stdcall WinMain(HINSTANCE hInst, HINSTANCE hPreInst, LPSTR lpszCmdLine, int nCmdShow); void *__fastcall decode_pointer(void *codedptr); void *__fastcall encode_pointer(void *ptr); int __cdecl setargv(); void __fastcall _mingw_raise_matherr(int typ, const char *name, double a3, double a1, double rslt); void __fastcall _mingw_setusermatherr(int (*f)(_exception *)); int __fastcall matherr(_exception *pexcept); void _report_error(const char *msg, ...); void __fastcall _write_memory_part_0(void *addr, const void *src, size_t len); void __cdecl pei386_runtime_relocator(); int __fastcall _mingw_SEH_error_handler(_EXCEPTION_RECORD *ExceptionRecord, void *EstablisherFrame, _CONTEXT *ContextRecord, void *DispatcherContext); int __cdecl _mingw_init_ehandler(); int __fastcall gnu_exception_handler(EXCEPTION_POINTERS *exception_data); void __cdecl fpreset(); void __cdecl _do_global_dtors(); void __cdecl _do_global_ctors(); void __cdecl _main(); void __cdecl _security_init_cookie(); void __fastcall _report_gsfailure(ULONG_PTR StackCookie); BOOL __fastcall _dyn_tls_dtor(HANDLE hDllHandle, DWORD dwReason, LPVOID lpreserved); BOOL __fastcall _dyn_tls_init(HANDLE hDllHandle, DWORD dwReason, LPVOID lpreserved); int __fastcall _tlregdtor(_PVFV func); _onexit_t __fastcall mingw_onexit(_onexit_t func); int __fastcall atexit(_PVFV func); int __cdecl my_lconv_init(); WINBOOL __fastcall ValidateImageBase_part_0(PBYTE pImageBase); WINBOOL __fastcall ValidateImageBase(PBYTE pImageBase); PIMAGE_SECTION_HEADER __fastcall FindPESection(PBYTE pImageBase, DWORD_PTR rva); PIMAGE_SECTION_HEADER __fastcall FindPESectionByName(const char *pName); PIMAGE_SECTION_HEADER __fastcall _mingw_GetSectionForAddress(LPVOID p); int __cdecl _mingw_GetSectionCount(); PIMAGE_SECTION_HEADER __fastcall FindPESectionExec(size_t eNo); PBYTE __cdecl GetPEImageBase(); WINBOOL __fastcall IsNonwritableInCurrentImage(PBYTE pTarget); const char *__fastcall _mingw_enum_import_library_names(int i); void __cdecl _mingwthr_run_key_dtors_part_0(); int __fastcall __w64_mingwthr_add_key_dtor(DWORD key, void (*dtor)(void *)); int __fastcall __w64_mingwthr_remove_key_dtor(DWORD key); WINBOOL __fastcall _mingw_TLScallback(HANDLE hDllHandle, DWORD reason, LPVOID reserved); // void __cdecl _set_app_type(_crt_app_type Type); // __int64 __fastcall _getmainargs(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak void (*__cdecl get_invalid_parameter_handler())(const wchar_t *, const wchar_t *, const wchar_t *, unsigned int, uintptr_t); void (*__fastcall set_invalid_parameter_handler(void (*new_handler)(const wchar_t *, const wchar_t *, const wchar_t *, unsigned int, uintptr_t)))(const wchar_t *, const wchar_t *, const wchar_t *, unsigned int, uintptr_t); // void *__cdecl malloc(size_t Size); // size_t __cdecl strlen(const char *Str); // void *__cdecl memcpy(void *, const void *Src, size_t Size); // void __cdecl cexit(); // __int64 __fastcall amsg_exit(_QWORD); weak // void __cdecl initterm(_PVFV *First, _PVFV *Last); // void __cdecl __noreturn exit(int Code); // int printf(const char *const Format, ...); // int sprintf(char *const Buffer, const char *const Format, ...); // void __cdecl _setusermatherr(_UserMathErrorFunctionPointer UserMathErrorFunction); // FILE *__cdecl _iob_func(); // int fprintf(FILE *const Stream, const char *const Format, ...); // size_t __cdecl fwrite(const void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream); // int __cdecl vfprintf(FILE *const Stream, const char *const Format, va_list ArgList); // void __cdecl __noreturn abort(); // _crt_signal_t __cdecl signal(int Signal, _crt_signal_t Function); // __int64 __fastcall lock(_QWORD); weak // __int64 __fastcall _dllonexit(_QWORD, _QWORD, _QWORD); weak // __int64 __fastcall unlock(_QWORD); weak // int __cdecl strncmp(const char *Str1, const char *Str2, size_t MaxCount); // void *__cdecl calloc(size_t Count, size_t Size); // void __cdecl free(void *Block); // int __fastcall main(int flags, char **cmdline, char **inst); idb // __int64 __fastcall _IAT_start__(_QWORD, _QWORD, _QWORD); weak // __int64 __lconv_init(void); weak //------------------------------------------------------------------------- // Data declarations func_ptr *p_73208 = (func_ptr *)0x403338LL; // idb UINT_PTR _security_cookie = 47936899621426uLL; // idb UINT_PTR _security_cookie_complement = 18446696136809930189uLL; // idb char aSfmsilqzdxajhn[53] = &#34;sfMSiLQzdXajhnZKrPyAoHbTDNREWtuVOcGIxkYemgBClvwFUpqJ&#34;; // weak const EXCEPTION_POINTERS GS_ExceptionPointers = { &amp;GS_ExceptionRecord, &amp;GS_ContextRecord }; // idb int *refptr__CRT_MT = &amp;CRT_MT; // weak int *refptr__MINGW_INSTALL_DEBUG_MATHERR = &amp;MINGW_INSTALL_DEBUG_MATHERR; // weak __int64 (*refptr___CTOR_LIST__)[2] = &amp;__CTOR_LIST__; // weak _UNKNOWN *refptr___RUNTIME_PSEUDO_RELOC_LIST_END__ = &amp;_RUNTIME_PSEUDO_RELOC_LIST_END___0; // weak _UNKNOWN *refptr___RUNTIME_PSEUDO_RELOC_LIST__ = &amp;_RUNTIME_PSEUDO_RELOC_LIST_END___0; // weak const PBYTE refptr___image_base__ = (const PBYTE)0x400000LL; // idb _UNKNOWN *refptr___imp__fmode = &amp;_fmode; // weak _UNKNOWN *refptr___imp__onexit = &amp;_onexit; // weak __int64 *refptr___onexitbegin = &amp;_onexitbegin; // weak __int64 *refptr___onexitend = &amp;_onexitend; // weak int *refptr__dowildcard = &amp;dowildcard; // weak int *refptr__fmode = &amp;fmode; // weak int *refptr__newmode = &amp;newmode; // weak int *refptr_mingw_app_type = &amp;mingw_app_type; // weak int *refptr_mingw_initcharmax = &amp;mingw_initcharmax; // weak int *refptr_mingw_initltsdrot_force = &amp;mingw_initltsdrot_force; // weak int *refptr_mingw_initltsdyn_force = &amp;mingw_initltsdyn_force; // weak int *refptr_mingw_initltssuo_force = &amp;mingw_initltssuo_force; // weak _startupinfo _bss_start__; // idb int managedapp; // idb int argret; // idb char **envp; // idb char **argv; // idb int argc; // idb fUserMathErr stUserMathErr; // idb int was_init_73980; // idb int maxSections; // idb sSecInfo *the_secs; // idb int was_here_73812; // idb UNWIND_INFO emu_xdata[32]; // idb RUNTIME_FUNCTION emu_pdata[32]; // idb int initialized; // idb CONTEXT GS_ContextRecord; // idb EXCEPTION_RECORD GS_ExceptionRecord; // idb volatile __mingwthr_key_t *key_dtor_list; // idb volatile int _mingwthr_cs_init; // idb CRITICAL_SECTION _mingwthr_cs; // idb void (*handler)(const wchar_t *, const wchar_t *, const wchar_t *, unsigned int, uintptr_t); // idb _PVFV *_onexitbegin; // idb _PVFV *_onexitend; // idb // extern void (__stdcall *EnterCriticalSection)(LPCRITICAL_SECTION lpCriticalSection); // extern HANDLE (__stdcall *GetCurrentProcess)(); // extern DWORD (__stdcall *GetCurrentProcessId)(); // extern DWORD (__stdcall *GetCurrentThreadId)(); // extern DWORD (__stdcall *GetLastError)(); // extern void (__stdcall *GetSystemTimeAsFileTime)(LPFILETIME lpSystemTimeAsFileTime); // extern DWORD (__stdcall *GetTickCount)(); // extern void (__stdcall *InitializeCriticalSection)(LPCRITICAL_SECTION lpCriticalSection); // extern void (__stdcall *LeaveCriticalSection)(LPCRITICAL_SECTION lpCriticalSection); // extern BOOL (__stdcall *QueryPerformanceCounter)(LARGE_INTEGER *lpPerformanceCount); // extern BOOLEAN (__cdecl *RtlAddFunctionTable)(PRUNTIME_FUNCTION FunctionTable, ULONG EntryCount, ULONG64 BaseAddress); // extern void (__stdcall *RtlCaptureContext)(PCONTEXT ContextRecord); // extern PRUNTIME_FUNCTION (__stdcall *RtlLookupFunctionEntry)(ULONG64 ControlPc, PULONG64 ImageBase, PUNWIND_HISTORY_TABLE HistoryTable); // extern PEXCEPTION_ROUTINE (__stdcall *RtlVirtualUnwind)(ULONG HandlerType, ULONG64 ImageBase, ULONG64 ControlPc, PRUNTIME_FUNCTION FunctionEntry, PCONTEXT ContextRecord, PVOID *HandlerData, PULONG64 EstablisherFrame, PKNONVOLATILE_CONTEXT_POINTERS ContextPointers); // extern LPTOP_LEVEL_EXCEPTION_FILTER (__stdcall *SetUnhandledExceptionFilter)(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter); // extern BOOL (__stdcall *TerminateProcess)(HANDLE hProcess, UINT uExitCode); // extern LPVOID (__stdcall *TlsGetValue)(DWORD dwTlsIndex); // extern LONG (__stdcall *UnhandledExceptionFilter)(struct _EXCEPTION_POINTERS *ExceptionInfo); // extern BOOL (__stdcall *VirtualProtect)(LPVOID lpAddress, SIZE_T dwSize, DWORD flNewProtect, PDWORD lpflOldProtect); // extern SIZE_T (__stdcall *VirtualQuery)(LPCVOID lpAddress, PMEMORY_BASIC_INFORMATION lpBuffer, SIZE_T dwLength); // extern HWND (__stdcall *CreateDialogParamA)(HINSTANCE hInstance, LPCSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam); // extern LRESULT (__stdcall *DispatchMessageA)(const MSG *lpMsg); // extern BOOL (__stdcall *EndDialog)(HWND hDlg, INT_PTR nResult); // extern UINT (__stdcall *GetDlgItemTextA)(HWND hDlg, int nIDDlgItem, LPSTR lpString, int cchMax); // extern BOOL (__stdcall *GetMessageA)(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax); // extern BOOL (__stdcall *IsDialogMessageA)(HWND hDlg, LPMSG lpMsg); // extern HMENU (__stdcall *LoadMenuA)(HINSTANCE hInstance, LPCSTR lpMenuName); // extern int (__stdcall *MessageBoxA)(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType); // extern BOOL (__stdcall *SetMenu)(HWND hWnd, HMENU hMenu); // extern BOOL (__stdcall *ShowWindow)(HWND hWnd, int nCmdShow); // extern BOOL (__stdcall *TranslateMessage)(const MSG *lpMsg); //----- (0000000000401010) ---------------------------------------------------- int __cdecl pre_c_init() { _BOOL8 v0; // rdx void *v1; // rax BYTE *v3; // rax __int16 v4; // cx LODWORD(v0) = 0; *refptr_mingw_initltsdrot_force = 1; *refptr_mingw_initltsdyn_force = 1; *refptr_mingw_initltssuo_force = 1; *refptr_mingw_initcharmax = 1; if ( *refptr___image_base__ == 23117 ) { v3 = &amp;refptr___image_base__[*(refptr___image_base__ &#43; 15)]; if ( *v3 == 17744 ) { v4 = *(v3 &#43; 12); if ( v4 == 267 ) { if ( *(v3 &#43; 29) &gt; 0xEu ) v0 = *(v3 &#43; 58) != 0; } else if ( v4 == 523 &amp;&amp; *(v3 &#43; 33) &gt; 0xEu ) { v0 = *(v3 &#43; 62) != 0; } } } managedapp = v0; if ( *refptr_mingw_app_type ) _set_app_type(_crt_gui_app); else _set_app_type(_crt_console_app); v1 = encode_pointer(0xFFFFFFFFFFFFFFFFLL); *refptr___onexitend = v1; *refptr___onexitbegin = v1; **refptr___imp__fmode = *refptr__fmode; setargv(); if ( *refptr__MINGW_INSTALL_DEBUG_MATHERR == 1 ) _mingw_setusermatherr(matherr); return 0; } // 405370: using guessed type int *refptr__MINGW_INSTALL_DEBUG_MATHERR; // 4053F0: using guessed type _UNKNOWN *refptr___imp__fmode; // 405470: using guessed type __int64 *refptr___onexitbegin; // 405480: using guessed type __int64 *refptr___onexitend; // 4054E0: using guessed type int *refptr__fmode; // 405520: using guessed type int *refptr_mingw_app_type; // 405530: using guessed type int *refptr_mingw_initcharmax; // 405540: using guessed type int *refptr_mingw_initltsdrot_force; // 405550: using guessed type int *refptr_mingw_initltsdyn_force; // 405560: using guessed type int *refptr_mingw_initltssuo_force; //----- (0000000000401160) ---------------------------------------------------- void __cdecl pre_cpp_init() { _bss_start__.newmode = *refptr__newmode; argret = _getmainargs(&amp;argc, &amp;argv, &amp;envp, *refptr__dowildcard, &amp;_bss_start__); } // 4030D0: using guessed type __int64 __fastcall _getmainargs(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); // 4054D0: using guessed type int *refptr__dowildcard; // 405510: using guessed type int *refptr__newmode; //----- (0000000000401500) ---------------------------------------------------- int __cdecl mainCRTStartup() { *refptr_mingw_app_type = 0; _security_init_cookie(); return _tmainCRTStartup(); } // 405520: using guessed type int *refptr_mingw_app_type; //----- (0000000000401530) ---------------------------------------------------- char *__fastcall generaLetras(int a1, char *a2) { size_t v2; // rax char *result; // rax int v4; // [rsp&#43;28h] [rbp-58h] int v5; // [rsp&#43;2Ch] [rbp-54h] int v6; // [rsp&#43;30h] [rbp-50h] int v7; // [rsp&#43;34h] [rbp-4Ch] v7 = (a1 &#43; 15) % strlen(&#34;sfMSiLQzdXajhnZKrPyAoHbTDNREWtuVOcGIxkYemgBClvwFUpqJ&#34;); v6 = (a1 &#43; 22) % strlen(&#34;sfMSiLQzdXajhnZKrPyAoHbTDNREWtuVOcGIxkYemgBClvwFUpqJ&#34;); v5 = (a1 &#43; 32) % strlen(&#34;sfMSiLQzdXajhnZKrPyAoHbTDNREWtuVOcGIxkYemgBClvwFUpqJ&#34;); v4 = (a1 &#43; 17) % strlen(&#34;sfMSiLQzdXajhnZKrPyAoHbTDNREWtuVOcGIxkYemgBClvwFUpqJ&#34;); v2 = strlen(&#34;sfMSiLQzdXajhnZKrPyAoHbTDNREWtuVOcGIxkYemgBClvwFUpqJ&#34;); *a2 = aSfmsilqzdxajhn[v7]; a2[1] = aSfmsilqzdxajhn[v6]; a2[2] = aSfmsilqzdxajhn[v5]; a2[3] = aSfmsilqzdxajhn[v4]; a2[4] = aSfmsilqzdxajhn[((a1 &#43; 4) % v2)]; result = a2 &#43; 5; a2[5] = 0; return result; } //----- (00000000004016AD) ---------------------------------------------------- __int64 __fastcall generaNumero(char *a1) { int i; // [rsp&#43;28h] [rbp-58h] int v3; // [rsp&#43;2Ch] [rbp-54h] v3 = 0; for ( i = 0; i &lt; strlen(a1); &#43;&#43;i ) v3 &#43;= a1[i]; printf(&#34;Numero: %d&#34;, v3 &#43; 6572); return (v3 &#43; 6572); } //----- (0000000000401746) ---------------------------------------------------- int __fastcall generaSerial(char *a1, char *a2) { char v3[16]; // [rsp&#43;40h] [rbp-50h] BYREF char v4[16]; // [rsp&#43;50h] [rbp-40h] BYREF char v5[16]; // [rsp&#43;60h] [rbp-30h] BYREF char v6[16]; // [rsp&#43;70h] [rbp-20h] BYREF char v7[12]; // [rsp&#43;80h] [rbp-10h] BYREF int v8; // [rsp&#43;8Ch] [rbp-4h] v8 = generaNumero(a1); generaLetras(v8, v7); v8 = generaNumero(v7); generaLetras(v8, v6); v8 = generaNumero(v6); generaLetras(v8, v5); v8 = generaNumero(v5); generaLetras(v8, v4); v8 = generaNumero(v4); generaLetras(v8, v3); return sprintf(a2, &#34;%s-%s-%s-%s-%s&#34;, v7, v6, v5, v4, v3); } //----- (000000000040182D) ---------------------------------------------------- int __fastcall checkSerial(char *a1, char *a2) { size_t v2; // rbx size_t v3; // rax int i; // [rsp&#43;28h] [rbp-58h] char v6; // [rsp&#43;2Fh] [rbp-51h] v6 = 1; v2 = strlen(a1); if ( v2 == strlen(a2) ) { for ( i = 0; ; &#43;&#43;i ) { v3 = strlen(a2); if ( i &gt;= v3 ) break; if ( a1[i] != a2[i] ) { LODWORD(v3) = MessageBoxA(0LL, &#34;Nope sigue intentando&#34;, &#34;Nop&#34;, 0x30u); v6 = 0; break; } } if ( v6 ) LODWORD(v3) = MessageBoxA(0LL, &#34;Genial lo lograste&#34;, &#34;Felicitaciones&#34;, 0); } else { MessageBoxA(0LL, &#34;Nope sigue intentando&#34;, &#34;Nop&#34;, 0x30u); LODWORD(v3) = 0; } return v3; } //----- (000000000040192F) ---------------------------------------------------- INT_PTR __fastcall DialogProc(HWND a1, int a2, unsigned __int16 a3) { char v4[32]; // [rsp&#43;20h] [rbp-60h] BYREF CHAR v5[32]; // [rsp&#43;40h] [rbp-40h] BYREF CHAR String[28]; // [rsp&#43;60h] [rbp-20h] BYREF UINT DlgItemTextA; // [rsp&#43;7Ch] [rbp-4h] DlgItemTextA = 0; switch ( a2 ) { case 272: return 1LL; case 273: if ( a3 == 40000 ) { DlgItemTextA = GetDlgItemTextA(a1, 40002, String, 20); if ( DlgItemTextA ) { DlgItemTextA = GetDlgItemTextA(a1, 40003, v5, 30); if ( DlgItemTextA ) { generaSerial(String, v4); checkSerial(v5, v4); return 1LL; } MessageBoxA(a1, &#34;Nope sigue intentando&#34;, &#34;Nop&#34;, 0x30u); } else { MessageBoxA(a1, &#34;Nope sigue intentando&#34;, &#34;Nop&#34;, 0x30u); } } else if ( a3 == 40006 ) { MessageBoxA(a1, &#34;keygeneame si puedes\n\nEl objetivo es crear el keygen sin parchear nada&#34;, &#34;About&#34;, 0x40u); return 1LL; } return 1LL; case 16: EndDialog(a1, 0LL); return 1LL; default: return 0LL; } } //----- (0000000000401AA6) ---------------------------------------------------- int __stdcall WinMain(HINSTANCE hInst, HINSTANCE hPreInst, LPSTR lpszCmdLine, int nCmdShow) { tagMSG Msg; // [rsp&#43;30h] [rbp-40h] BYREF HMENU hMenu; // [rsp&#43;60h] [rbp-10h] HWND hWnd; // [rsp&#43;68h] [rbp-8h] hWnd = CreateDialogParamA(hInst, 102, 0LL, DialogProc, 0LL); hMenu = LoadMenuA(hInst, 0x69); SetMenu(hWnd, hMenu); ShowWindow(hWnd, 10); while ( GetMessageA(&amp;Msg, 0LL, 0, 0) &gt; 0 ) { if ( !IsDialogMessageA(hWnd, &amp;Msg) ) { TranslateMessage(&amp;Msg); DispatchMessageA(&amp;Msg); } } return 0; } //----- (0000000000401BA0) ---------------------------------------------------- void *__fastcall decode_pointer(void *codedptr) { return codedptr; } //----- (0000000000401BB0) ---------------------------------------------------- void *__fastcall encode_pointer(void *ptr) { return ptr; } //----- (0000000000401BC0) ---------------------------------------------------- int __cdecl setargv() { return 0; } //----- (0000000000401BD0) ---------------------------------------------------- void __fastcall _mingw_raise_matherr(int typ, const char *name, double a3, double a1, double rslt) { _exception ex; // [rsp&#43;20h] [rbp-38h] BYREF if ( stUserMathErr ) { ex.type = typ; ex.name = name; ex.arg1 = a3; ex.arg2 = a1; ex.retval = rslt; stUserMathErr(&amp;ex); } } //----- (0000000000401C20) ---------------------------------------------------- void __fastcall _mingw_setusermatherr(int (*f)(_exception *)) { stUserMathErr = f; _setusermatherr(f); } //----- (0000000000401C30) ---------------------------------------------------- int __fastcall matherr(_exception *pexcept) { const char *v1; // rbx double retval; // xmm8_8 const char *name; // rsi double arg2; // xmm7_8 double arg1; // xmm6_8 FILE *v6; // rax switch ( pexcept-&gt;type ) { case 1: v1 = &#34;Argument domain error (DOMAIN)&#34;; break; case 2: v1 = &#34;Argument singularity (SIGN)&#34;; break; case 3: v1 = &#34;Overflow range error (OVERFLOW)&#34;; break; case 4: v1 = &#34;The result is too small to be represented (UNDERFLOW)&#34;; break; case 5: v1 = &#34;Total loss of significance (TLOSS)&#34;; break; case 6: v1 = &#34;Partial loss of significance (PLOSS)&#34;; break; default: v1 = &#34;Unknown error&#34;; break; } retval = pexcept-&gt;retval; name = pexcept-&gt;name; arg2 = pexcept-&gt;arg2; arg1 = pexcept-&gt;arg1; v6 = _iob_func(); fprintf(v6 &#43; 2, &#34;_matherr(): %s in %s(%g, %g) (retval=%g)\n&#34;, v1, name, arg1, arg2, retval); return 0; } //----- (0000000000401D30) ---------------------------------------------------- void __noreturn _report_error(const char *msg, ...) { FILE *v2; // rax FILE *v3; // rax va_list va; // [rsp&#43;58h] [rbp&#43;10h] BYREF va_start(va, msg); v2 = _iob_func(); fwrite(&#34;Mingw-w64 runtime failure:\n&#34;, 1uLL, 0x1BuLL, v2 &#43; 2); v3 = _iob_func(); vfprintf(v3 &#43; 2, msg, va); abort(); } //----- (0000000000401DA0) ---------------------------------------------------- void __fastcall _write_memory_part_0(void *addr, const void *src, size_t len) { __int64 v3; // rbp int v7; // r9d PBYTE *p_sec_start; // rax PIMAGE_SECTION_HEADER SectionForAddress; // rax PIMAGE_SECTION_HEADER v10; // r12 __int64 v11; // rbp sSecInfo *v12; // r13 DWORD LastError; // eax struct _MEMORY_BASIC_INFORMATION Buffer; // [rsp&#43;20h] [rbp-68h] BYREF v3 = maxSections; if ( maxSections &lt;= 0 ) { v3 = 0LL; LABEL_6: SectionForAddress = _mingw_GetSectionForAddress(addr); v10 = SectionForAddress; if ( !SectionForAddress ) _report_error(&#34;Address %p has no image-section&#34;, addr); v11 = v3; v12 = &amp;the_secs[v11]; v12-&gt;hash = SectionForAddress; v12-&gt;old_protect = 0; v12-&gt;sec_start = &amp;GetPEImageBase()[SectionForAddress-&gt;VirtualAddress]; if ( !VirtualQuery(the_secs[v11].sec_start, &amp;Buffer, 0x30uLL) ) _report_error( &#34; VirtualQuery failed for %d bytes at address %p&#34;, v10-&gt;Misc.PhysicalAddress, the_secs[v11].sec_start); if ( ((Buffer.Protect - 4) &amp; 0xFFFFFFFB) != 0 &amp;&amp; ((Buffer.Protect - 64) &amp; 0xFFFFFFBF) != 0 &amp;&amp; !VirtualProtect(Buffer.BaseAddress, Buffer.RegionSize, 0x40u, &amp;the_secs[v11].old_protect) ) { LastError = GetLastError(); _report_error(&#34; VirtualProtect failed with code 0x%x&#34;, LastError); } &#43;&#43;maxSections; } else { v7 = 0; p_sec_start = &amp;the_secs-&gt;sec_start; while ( addr &lt; *p_sec_start || addr &gt;= &amp;(*p_sec_start)[*(p_sec_start[1] &#43; 2)] ) { &#43;&#43;v7; p_sec_start &#43;= 3; if ( v7 == maxSections ) goto LABEL_6; } } memcpy(addr, src, len); } //----- (0000000000401F10) ---------------------------------------------------- void __cdecl pei386_runtime_relocator() { unsigned __int64 v0; // rax void *v1; // rsp _DWORD *v2; // rbx void *v3; // rsp int v4; // edx unsigned int *v5; // rbx unsigned int v6; // edx BYTE *v7; // rax BYTE *v8; // rcx __int64 v9; // r8 __int64 v10; // rbx int i; // esi __int64 v12; // rcx int v13; // eax BYTE *v14; // rcx unsigned __int64 v15; // rdx unsigned __int64 v16; // rdx unsigned __int64 v17; // rdx char v18; // [rsp&#43;20h] [rbp-40h] BYREF DWORD flOldProtect; // [rsp&#43;2Ch] [rbp-34h] BYREF struct _MEMORY_BASIC_INFORMATION src; // [rsp&#43;30h] [rbp-30h] BYREF if ( was_init_73980 ) return; was_init_73980 = 1; v0 = (24LL * _mingw_GetSectionCount() &#43; 30) &amp; 0xFFFFFFFFFFFFFFF0uLL; v1 = alloca(v0); v2 = refptr___RUNTIME_PSEUDO_RELOC_LIST__; v3 = alloca(v0); maxSections = 0; the_secs = &amp;v18; if ( refptr___RUNTIME_PSEUDO_RELOC_LIST_END__ - refptr___RUNTIME_PSEUDO_RELOC_LIST__ &lt;= 7 ) return; if ( refptr___RUNTIME_PSEUDO_RELOC_LIST_END__ - refptr___RUNTIME_PSEUDO_RELOC_LIST__ &gt; 11 ) { if ( *refptr___RUNTIME_PSEUDO_RELOC_LIST__ || *(refptr___RUNTIME_PSEUDO_RELOC_LIST__ &#43; 1) ) goto LABEL_25; if ( *(refptr___RUNTIME_PSEUDO_RELOC_LIST__ &#43; 2) ) goto LABEL_11; v2 = (refptr___RUNTIME_PSEUDO_RELOC_LIST__ &#43; 12); } if ( *v2 || v2[1] ) { LABEL_25: if ( v2 &gt;= refptr___RUNTIME_PSEUDO_RELOC_LIST_END__ ) return; do { v12 = v2[1]; v13 = *v2; v2 &#43;= 2; v14 = &amp;refptr___image_base__[v12]; LODWORD(src.BaseAddress) = *v14 &#43; v13; _write_memory_part_0(v14, &amp;src, 4uLL); } while ( v2 &lt; refptr___RUNTIME_PSEUDO_RELOC_LIST_END__ ); goto LABEL_19; } LABEL_11: v4 = v2[2]; if ( v4 != 1 ) _report_error(&#34; Unknown pseudo relocation protocol version %d.\n&#34;, v4); v5 = v2 &#43; 3; if ( v5 &lt; refptr___RUNTIME_PSEUDO_RELOC_LIST_END__ ) { do { v6 = *(v5 &#43; 8); v7 = &amp;refptr___image_base__[*v5]; v8 = &amp;refptr___image_base__[v5[1]]; v9 = *v7; if ( v6 == 16 ) { v16 = *v8; if ( (v16 &amp; 0x8000u) != 0LL ) v16 = *v8 | 0xFFFFFFFFFFFF0000uLL; src.BaseAddress = (v9 &#43; v16 - v7); _write_memory_part_0(v8, &amp;src, 2uLL); } else if ( v6 &lt;= 0x10 ) { if ( v6 != 8 ) { LABEL_35: src.BaseAddress = 0LL; _report_error(&#34; Unknown pseudo relocation bit size %d.\n&#34;, v6); } v15 = *v8; if ( (v15 &amp; 0x80u) != 0LL ) v15 = *v8 | 0xFFFFFFFFFFFFFF00uLL; src.BaseAddress = (v9 &#43; v15 - v7); _write_memory_part_0(v8, &amp;src, 1uLL); } else if ( v6 == 32 ) { v17 = *v8; if ( (v17 &amp; 0x80000000) != 0LL ) v17 = *v8 | 0xFFFFFFFF00000000uLL; src.BaseAddress = (v9 &#43; v17 - v7); _write_memory_part_0(v8, &amp;src, 4uLL); } else { if ( v6 != 64 ) goto LABEL_35; src.BaseAddress = (*v8 &#43; v9 - v7); _write_memory_part_0(v8, &amp;src, 8uLL); } v5 &#43;= 3; } while ( v5 &lt; refptr___RUNTIME_PSEUDO_RELOC_LIST_END__ ); LABEL_19: v10 = 0LL; for ( i = 0; i &lt; maxSections; &#43;&#43;v10 ) { if ( the_secs[v10].old_protect ) { if ( !VirtualQuery(the_secs[v10].sec_start, &amp;src, 0x30uLL) ) _report_error( &#34; VirtualQuery failed for %d bytes at address %p&#34;, the_secs[v10].hash-&gt;Misc.PhysicalAddress, the_secs[v10].sec_start); VirtualProtect(src.BaseAddress, src.RegionSize, the_secs[v10].old_protect, &amp;flOldProtect); } &#43;&#43;i; } } } // 405390: using guessed type _UNKNOWN *refptr___RUNTIME_PSEUDO_RELOC_LIST_END__; // 4053A0: using guessed type _UNKNOWN *refptr___RUNTIME_PSEUDO_RELOC_LIST__; //----- (0000000000402210) ---------------------------------------------------- int __fastcall _mingw_SEH_error_handler( _EXCEPTION_RECORD *ExceptionRecord, void *EstablisherFrame, _CONTEXT *ContextRecord, void *DispatcherContext) { DWORD ExceptionCode; // eax _crt_signal_t v5; // rax int result; // eax _crt_signal_t v7; // rdx _crt_signal_t v8; // rax ExceptionCode = ExceptionRecord-&gt;ExceptionCode; if ( ExceptionRecord-&gt;ExceptionCode &gt; 0xC0000091 ) { if ( ExceptionCode == -1073741676 ) { v7 = signal(8, 0LL); if ( v7 == 1 ) { signal(8, 1); return 0; } goto LABEL_16; } if ( ExceptionCode &gt; 0xC0000094 ) { if ( ExceptionCode == -1073741675 ) return 0; if ( ExceptionCode != -1073741674 ) return 1; goto LABEL_20; } if ( ExceptionCode == -1073741678 ) return 0; if ( ExceptionCode != -1073741677 ) return 1; } else if ( ExceptionCode &lt; 0xC000008D ) { if ( ExceptionCode == -1073741816 ) return 0; if ( ExceptionCode &lt;= 0xC0000008 ) { if ( ExceptionCode != -2147483646 ) { if ( ExceptionCode == -1073741819 ) { v5 = signal(11, 0LL); if ( v5 == 1 ) { signal(11, 1); return 0; } if ( v5 ) { (v5)(11LL); return 0; } return 4; } return 1; } return 0; } if ( ExceptionCode != -1073741795 ) return ExceptionCode != -1073741684; LABEL_20: v8 = signal(4, 0LL); if ( v8 == 1 ) { signal(4, 1); return 0; } if ( v8 ) { (v8)(4LL); return 0; } return 4; } v7 = signal(8, 0LL); if ( v7 == 1 ) { signal(8, 1); fpreset(); return 0; } LABEL_16: result = 1; if ( v7 ) { (v7)(8LL); return 0; } return result; } //----- (00000000004023C0) ---------------------------------------------------- int __cdecl _mingw_init_ehandler() { PBYTE PEImageBase; // rbp int result; // eax RUNTIME_FUNCTION *v2; // rbx size_t v3; // rsi UNWIND_INFO *v4; // rdi DWORD VirtualAddress; // edx DWORD v6; // edx DWORD v7; // eax PIMAGE_SECTION_HEADER PESectionExec; // rax ULONG v9; // edx PEImageBase = GetPEImageBase(); result = was_here_73812; if ( !was_here_73812 &amp;&amp; PEImageBase ) { was_here_73812 = 1; if ( !FindPESectionByName(&#34;.pdata&#34;) ) { v2 = emu_pdata; v3 = 0LL; memset(emu_pdata, 0, sizeof(emu_pdata)); memset(emu_xdata, 0, sizeof(emu_xdata)); v4 = emu_xdata; while ( 1 ) { PESectionExec = FindPESectionExec(v3); if ( !PESectionExec ) break; v4-&gt;VersionAndFlags = 9; v4-&gt;AddressOfExceptionHandler = _mingw_SEH_error_handler - PEImageBase; &#43;&#43;v3; VirtualAddress = PESectionExec-&gt;VirtualAddress; &#43;&#43;v2; v2[-1].BeginAddress = VirtualAddress; v6 = PESectionExec-&gt;Misc.PhysicalAddress &#43; VirtualAddress; v7 = v4&#43;&#43; - PEImageBase; v2[-1].UnwindData = v7; v2[-1].EndAddress = v6; if ( v3 == 32 ) { v9 = 32; goto LABEL_11; } } if ( !v3 ) return 1; v9 = v3; LABEL_11: RtlAddFunctionTable(emu_pdata, v9, PEImageBase); } return 1; } return result; } //----- (0000000000402670) ---------------------------------------------------- void __cdecl fpreset() { __asm { fninit } } //----- (0000000000402680) ---------------------------------------------------- void __cdecl _do_global_dtors() { void (*i)(void); // rax for ( i = *p_73208; i; &#43;&#43;p_73208 ) { i(); i = p_73208[1]; } } //----- (00000000004026C0) ---------------------------------------------------- void __cdecl _do_global_ctors() { int i; // ebx i = (*refptr___CTOR_LIST__)[0]; if ( i == -1 ) { for ( i = 0; (*refptr___CTOR_LIST__)[i &#43; 1]; &#43;&#43;i ) ; } for ( ; i; --i ) ((*refptr___CTOR_LIST__)[i])(); atexit(_do_global_dtors); } // 405380: using guessed type __int64 (*refptr___CTOR_LIST__)[2]; //----- (0000000000402720) ---------------------------------------------------- void __cdecl _main() { if ( !initialized ) { initialized = 1; _do_global_ctors(); } } //----- (0000000000402740) ---------------------------------------------------- void __cdecl _security_init_cookie() { FT v0; // r12 __int64 CurrentProcessId; // rbp DWORD CurrentThreadId; // edi DWORD TickCount; // esi LONGLONG v4; // rsi UINT_PTR v5; // rax FT systime; // [rsp&#43;20h] [rbp-48h] BYREF LARGE_INTEGER perfctr; // [rsp&#43;30h] [rbp-38h] BYREF systime.ft_scalar = 0LL; if ( _security_cookie == 0x2B992DDFA232LL ) { GetSystemTimeAsFileTime(&amp;systime); v0.ft_scalar = systime.ft_scalar; CurrentProcessId = GetCurrentProcessId(); CurrentThreadId = GetCurrentThreadId(); TickCount = GetTickCount(); QueryPerformanceCounter(&amp;perfctr); v4 = (TickCount ^ CurrentThreadId ^ perfctr.QuadPart ^ v0.ft_scalar ^ CurrentProcessId) &amp; 0xFFFFFFFFFFFFLL; if ( v4 == 0x2B992DDFA232LL ) { v5 = 0xFFFFD466D2205DCCuLL; v4 = 0x2B992DDFA233LL; } else { v5 = ~v4; } _security_cookie = v4; _security_cookie_complement = v5; } else { _security_cookie_complement = ~_security_cookie; } } //----- (0000000000402820) ---------------------------------------------------- void __fastcall __noreturn _report_gsfailure(ULONG_PTR StackCookie) { ULONG64 Rip; // rbx _RUNTIME_FUNCTION *v3; // r9 HANDLE CurrentProcess; // rax ULONG64 imgBase; // [rsp&#43;48h] [rbp-28h] BYREF ULONG64 establisherFrame; // [rsp&#43;50h] [rbp-20h] BYREF PVOID hndData; // [rsp&#43;58h] [rbp-18h] BYREF UINT_PTR cookie[2]; // [rsp&#43;60h] [rbp-10h] char vars8; // [rsp&#43;78h] [rbp&#43;8h] BYREF DWORD64 retaddr; // [rsp&#43;88h] [rbp&#43;18h] RtlCaptureContext(&amp;GS_ContextRecord); Rip = GS_ContextRecord.Rip; v3 = RtlLookupFunctionEntry(GS_ContextRecord.Rip, &amp;imgBase, 0LL); if ( v3 ) { RtlVirtualUnwind(0, imgBase, Rip, v3, &amp;GS_ContextRecord, &amp;hndData, &amp;establisherFrame, 0LL); } else { GS_ContextRecord.Rip = retaddr; GS_ContextRecord.Rsp = &amp;vars8; } GS_ContextRecord.Rcx = StackCookie; GS_ExceptionRecord.ExceptionCode = -1073740791; GS_ExceptionRecord.ExceptionFlags = 1; GS_ExceptionRecord.ExceptionAddress = GS_ContextRecord.Rip; cookie[1] = _security_cookie_complement; SetUnhandledExceptionFilter(0LL); UnhandledExceptionFilter(&amp;GS_ExceptionPointers); CurrentProcess = GetCurrentProcess(); TerminateProcess(CurrentProcess, 0xC0000409); abort(); } //----- (0000000000402920) ---------------------------------------------------- BOOL __fastcall _dyn_tls_dtor(HANDLE hDllHandle, DWORD dwReason, LPVOID lpreserved) { if ( dwReason &amp;&amp; dwReason != 3 ) return 1; _mingw_TLScallback(hDllHandle, dwReason, lpreserved); return 1; } //----- (0000000000402950) ---------------------------------------------------- BOOL __fastcall _dyn_tls_init(HANDLE hDllHandle, DWORD dwReason, LPVOID lpreserved) { if ( *refptr__CRT_MT != 2 ) *refptr__CRT_MT = 2; if ( dwReason == 1 ) _mingw_TLScallback(hDllHandle, 1u, lpreserved); return 1; } // 405360: using guessed type int *refptr__CRT_MT; //----- (00000000004029C0) ---------------------------------------------------- int __fastcall _tlregdtor(_PVFV func) { return 0; } //----- (00000000004029D0) ---------------------------------------------------- _onexit_t __fastcall mingw_onexit(_onexit_t func) { int (*v2)(void); // rbx _PVFV *onexitbegin; // [rsp&#43;20h] [rbp-18h] BYREF _PVFV *onexitend; // [rsp&#43;28h] [rbp-10h] BYREF onexitbegin = decode_pointer(_onexitbegin); if ( onexitbegin == -1LL ) return (*refptr___imp__onexit)(func); lock(8LL); onexitbegin = decode_pointer(_onexitbegin); onexitend = decode_pointer(_onexitend); v2 = _dllonexit(func, &amp;onexitbegin, &amp;onexitend); _onexitbegin = encode_pointer(onexitbegin); _onexitend = encode_pointer(onexitend); unlock(8LL); return v2; } // 403180: using guessed type __int64 __fastcall lock(_QWORD); // 403188: using guessed type __int64 __fastcall _dllonexit(_QWORD, _QWORD, _QWORD); // 403190: using guessed type __int64 __fastcall unlock(_QWORD); // 405400: using guessed type _UNKNOWN *refptr___imp__onexit; //----- (0000000000402A80) ---------------------------------------------------- int __fastcall atexit(_PVFV func) { return -(mingw_onexit(func) == 0LL); } //----- (0000000000402AA0) ---------------------------------------------------- int __cdecl my_lconv_init() { return __lconv_init(); } // 409350: using guessed type __int64 __lconv_init(void); //----- (0000000000402AB0) ---------------------------------------------------- WINBOOL __fastcall ValidateImageBase_part_0(PBYTE pImageBase) { BYTE *v1; // rcx WINBOOL result; // eax v1 = &amp;pImageBase[*(pImageBase &#43; 15)]; result = 0; if ( *v1 == 17744 ) return *(v1 &#43; 12) == 523; return result; } //----- (0000000000402AD0) ---------------------------------------------------- WINBOOL __fastcall ValidateImageBase(PBYTE pImageBase) { if ( *pImageBase == 23117 ) return ValidateImageBase_part_0(pImageBase); else return 0; } //----- (0000000000402AF0) ---------------------------------------------------- PIMAGE_SECTION_HEADER __fastcall FindPESection(PBYTE pImageBase, DWORD_PTR rva) { BYTE *v2; // rcx PIMAGE_SECTION_HEADER result; // rax int v4; // ecx _IMAGE_SECTION_HEADER *v5; // r9 v2 = &amp;pImageBase[*(pImageBase &#43; 15)]; result = &amp;v2[*(v2 &#43; 10) &#43; 24]; v4 = *(v2 &#43; 3); if ( !v4 ) return 0LL; v5 = &amp;result[(v4 - 1) &#43; 1]; while ( result-&gt;VirtualAddress &gt; rva || rva &gt;= result-&gt;Misc.PhysicalAddress &#43; result-&gt;VirtualAddress ) { if ( &#43;&#43;result == v5 ) return 0LL; } return result; } //----- (0000000000402B40) ---------------------------------------------------- PIMAGE_SECTION_HEADER __fastcall FindPESectionByName(const char *pName) { BYTE *v3; // rdx _IMAGE_SECTION_HEADER *v4; // rbx int v5; // edx __int64 v6; // rdi if ( strlen(pName) &gt; 8 ) return 0LL; if ( *refptr___image_base__ != 23117 ) return 0LL; if ( !ValidateImageBase_part_0(refptr___image_base__) ) return 0LL; v3 = &amp;refptr___image_base__[*(refptr___image_base__ &#43; 15)]; v4 = &amp;v3[*(v3 &#43; 10) &#43; 24]; v5 = *(v3 &#43; 3); if ( !v5 ) return 0LL; v6 = &amp;v4[(v5 - 1) &#43; 1]; while ( strncmp(v4, pName, 8uLL) ) { if ( &#43;&#43;v4 == v6 ) return 0LL; } return v4; } //----- (0000000000402BE0) ---------------------------------------------------- PIMAGE_SECTION_HEADER __fastcall _mingw_GetSectionForAddress(LPVOID p) { if ( *refptr___image_base__ == 23117 &amp;&amp; ValidateImageBase_part_0(refptr___image_base__) ) return FindPESection(refptr___image_base__, p - refptr___image_base__); else return 0LL; } //----- (0000000000402C30) ---------------------------------------------------- int __cdecl _mingw_GetSectionCount() { int result; // eax result = 0; if ( *refptr___image_base__ == 23117 ) { result = ValidateImageBase_part_0(refptr___image_base__); if ( result ) return *&amp;refptr___image_base__[*(refptr___image_base__ &#43; 15) &#43; 6]; } return result; } //----- (0000000000402C70) ---------------------------------------------------- PIMAGE_SECTION_HEADER __fastcall FindPESectionExec(size_t eNo) { BYTE *v3; // rsi __int64 v4; // rdx __int64 v5; // rax if ( *refptr___image_base__ != 23117 ) return 0LL; if ( !ValidateImageBase_part_0(refptr___image_base__) ) return 0LL; v3 = &amp;refptr___image_base__[*(refptr___image_base__ &#43; 15)]; v4 = &amp;v3[*(v3 &#43; 10) &#43; 24]; if ( !*(v3 &#43; 3) ) return 0LL; v5 = v4 &#43; 40LL * (*(v3 &#43; 3) - 1) &#43; 40; while ( (*(v4 &#43; 39) &amp; 0x20) == 0 ) { LABEL_9: v4 &#43;= 40LL; if ( v4 == v5 ) return 0LL; } if ( eNo ) { --eNo; goto LABEL_9; } return v4; } //----- (0000000000402D00) ---------------------------------------------------- PBYTE __cdecl GetPEImageBase() { BYTE *v0; // rbx v0 = 0LL; if ( *refptr___image_base__ != 23117 ) return 0LL; if ( ValidateImageBase_part_0(refptr___image_base__) ) return refptr___image_base__; return v0; } //----- (0000000000402D40) ---------------------------------------------------- WINBOOL __fastcall IsNonwritableInCurrentImage(PBYTE pTarget) { WINBOOL result; // eax PIMAGE_SECTION_HEADER PESection; // rax result = 0; if ( *refptr___image_base__ == 23117 ) { result = ValidateImageBase_part_0(refptr___image_base__); if ( result ) { PESection = FindPESection(refptr___image_base__, pTarget - refptr___image_base__); return PESection &amp;&amp; (PESection-&gt;Characteristics &amp; 0x80000000) == 0; } } return result; } //----- (0000000000402DA0) ---------------------------------------------------- const char *__fastcall _mingw_enum_import_library_names(int i) { unsigned int v3; // edx __int64 v4; // rbx BYTE *v5; // rdx if ( *refptr___image_base__ != 23117 ) return 0LL; if ( !ValidateImageBase_part_0(refptr___image_base__) ) return 0LL; v3 = *&amp;refptr___image_base__[*(refptr___image_base__ &#43; 15) &#43; 144]; if ( !v3 ) return 0LL; v4 = v3; if ( !FindPESection(refptr___image_base__, v3) ) return 0LL; v5 = &amp;refptr___image_base__[v4]; if ( !&amp;refptr___image_base__[v4] ) return 0LL; while ( *(v5 &#43; 1) || *(v5 &#43; 3) ) { if ( i &lt;= 0 ) return &amp;refptr___image_base__[*(v5 &#43; 3)]; --i; v5 &#43;= 20; } return 0LL; } //----- (0000000000402E50) ---------------------------------------------------- void __cdecl _mingwthr_run_key_dtors_part_0() { volatile __mingwthr_key_t *i; // rbx LPVOID Value; // rsi EnterCriticalSection(&amp;_mingwthr_cs); for ( i = key_dtor_list; i; i = i-&gt;next ) { Value = TlsGetValue(i-&gt;key); if ( !GetLastError() &amp;&amp; Value ) i-&gt;dtor(Value); } LeaveCriticalSection(&amp;_mingwthr_cs); } //----- (0000000000402EC0) ---------------------------------------------------- int __fastcall __w64_mingwthr_add_key_dtor(DWORD key, void (*dtor)(void *)) { int result; // eax volatile __mingwthr_key_t *v5; // rax volatile __mingwthr_key_t *v6; // rbx volatile __mingwthr_key_t *v7; // rax result = _mingwthr_cs_init; if ( _mingwthr_cs_init ) { v5 = calloc(1uLL, 0x18uLL); v6 = v5; if ( v5 ) { v5-&gt;key = key; v5-&gt;dtor = dtor; EnterCriticalSection(&amp;_mingwthr_cs); v7 = key_dtor_list; key_dtor_list = v6; v6-&gt;next = v7; LeaveCriticalSection(&amp;_mingwthr_cs); return 0; } else { return -1; } } return result; } //----- (0000000000402F40) ---------------------------------------------------- int __fastcall __w64_mingwthr_remove_key_dtor(DWORD key) { volatile __mingwthr_key_t *v3; // rdx volatile __mingwthr_key_t *next; // rax volatile __mingwthr_key_t *v5; // rcx if ( !_mingwthr_cs_init ) return 0; EnterCriticalSection(&amp;_mingwthr_cs); v3 = key_dtor_list; if ( key_dtor_list ) { if ( key_dtor_list-&gt;key == key ) { v5 = key_dtor_list; key_dtor_list = key_dtor_list-&gt;next; LABEL_12: free(v5); LeaveCriticalSection(&amp;_mingwthr_cs); return 0; } while ( 1 ) { next = v3-&gt;next; if ( !next ) break; if ( next-&gt;key == key ) { v5 = v3-&gt;next; v3-&gt;next = next-&gt;next; goto LABEL_12; } v3 = v3-&gt;next; } } LeaveCriticalSection(&amp;_mingwthr_cs); return 0; } //----- (0000000000402FE0) ---------------------------------------------------- // local variable allocation has failed, the output may be wrong! WINBOOL __fastcall _mingw_TLScallback(HANDLE hDllHandle, DWORD reason, LPVOID reserved) { WINBOOL result; // eax if ( reason == 1 ) { if ( !_mingwthr_cs_init ) InitializeCriticalSection(&amp;_mingwthr_cs); result = 1; _mingwthr_cs_init = 1; } else { if ( reason ) { if ( reason == 3 ) { if ( _mingwthr_cs_init ) _mingwthr_run_key_dtors_part_0(); } } else { if ( _mingwthr_cs_init ) _mingwthr_run_key_dtors_part_0(); if ( _mingwthr_cs_init == 1 ) { _mingwthr_cs_init = 0; _IAT_start__(&amp;_mingwthr_cs, *&amp;reason, reserved); } } return 1; } return result; } // 402FE0: variables would overlap: edx.4 and rdx.8 // 409268: using guessed type __int64 __fastcall _IAT_start__(_QWORD, _QWORD, _QWORD); //----- (00000000004030E0) ---------------------------------------------------- void (*__cdecl get_invalid_parameter_handler())(const wchar_t *, const wchar_t *, const wchar_t *, unsigned int, uintptr_t) { return handler; } //----- (00000000004030F0) ---------------------------------------------------- void (*__fastcall set_invalid_parameter_handler( void (*new_handler)(const wchar_t *, const wchar_t *, const wchar_t *, unsigned int, uintptr_t)))(const wchar_t *, const wchar_t *, const wchar_t *, unsigned int, uintptr_t) { return _InterlockedExchange64(&amp;handler, new_handler); } // nfuncs=114 queued=48 decompiled=48 lumina nreq=0 worse=0 better=0 // ALL OK, 48 function(s) have been successfully decompiled Exploit:">
  <meta property="og:locale" content="es_es">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-09-09T06:41:05-03:00">
    <meta property="article:modified_time" content="2024-09-09T06:41:05-03:00">
    <meta property="article:tag" content="Reversing">
    <meta property="article:tag" content="Ida">

  
  <meta itemprop="name" content="Keygen si puedes">
  <meta itemprop="description" content="El keygen se encuentra en: https://drive.google.com/file/d/1QRIk3zBGGXH54nSZorX3jnuNmURCHw6K/view?pli=1
El c贸digo que me gener贸 el ida es:
#include &lt;windows.h&gt; #include &lt;defs.h&gt; #include &lt;stdarg.h&gt; //------------------------------------------------------------------------- // Function declarations void __fastcall _mingw_invalidParameterHandler(const wchar_t *expression, const wchar_t *function, const wchar_t *file, unsigned int line, uintptr_t pReserved); int __cdecl pre_c_init(); void __cdecl pre_cpp_init(); // int __cdecl _tmainCRTStartup(); // int __cdecl WinMainCRTStartup(); int __cdecl mainCRTStartup(); char *__fastcall generaLetras(int a1, char *a2); __int64 __fastcall generaNumero(char *a1); // idb int __fastcall generaSerial(char *a1, char *a2); int __fastcall checkSerial(char *a1, char *a2); INT_PTR __fastcall DialogProc(HWND a1, int a2, unsigned __int16 a3); int __stdcall WinMain(HINSTANCE hInst, HINSTANCE hPreInst, LPSTR lpszCmdLine, int nCmdShow); void *__fastcall decode_pointer(void *codedptr); void *__fastcall encode_pointer(void *ptr); int __cdecl setargv(); void __fastcall _mingw_raise_matherr(int typ, const char *name, double a3, double a1, double rslt); void __fastcall _mingw_setusermatherr(int (*f)(_exception *)); int __fastcall matherr(_exception *pexcept); void _report_error(const char *msg, ...); void __fastcall _write_memory_part_0(void *addr, const void *src, size_t len); void __cdecl pei386_runtime_relocator(); int __fastcall _mingw_SEH_error_handler(_EXCEPTION_RECORD *ExceptionRecord, void *EstablisherFrame, _CONTEXT *ContextRecord, void *DispatcherContext); int __cdecl _mingw_init_ehandler(); int __fastcall gnu_exception_handler(EXCEPTION_POINTERS *exception_data); void __cdecl fpreset(); void __cdecl _do_global_dtors(); void __cdecl _do_global_ctors(); void __cdecl _main(); void __cdecl _security_init_cookie(); void __fastcall _report_gsfailure(ULONG_PTR StackCookie); BOOL __fastcall _dyn_tls_dtor(HANDLE hDllHandle, DWORD dwReason, LPVOID lpreserved); BOOL __fastcall _dyn_tls_init(HANDLE hDllHandle, DWORD dwReason, LPVOID lpreserved); int __fastcall _tlregdtor(_PVFV func); _onexit_t __fastcall mingw_onexit(_onexit_t func); int __fastcall atexit(_PVFV func); int __cdecl my_lconv_init(); WINBOOL __fastcall ValidateImageBase_part_0(PBYTE pImageBase); WINBOOL __fastcall ValidateImageBase(PBYTE pImageBase); PIMAGE_SECTION_HEADER __fastcall FindPESection(PBYTE pImageBase, DWORD_PTR rva); PIMAGE_SECTION_HEADER __fastcall FindPESectionByName(const char *pName); PIMAGE_SECTION_HEADER __fastcall _mingw_GetSectionForAddress(LPVOID p); int __cdecl _mingw_GetSectionCount(); PIMAGE_SECTION_HEADER __fastcall FindPESectionExec(size_t eNo); PBYTE __cdecl GetPEImageBase(); WINBOOL __fastcall IsNonwritableInCurrentImage(PBYTE pTarget); const char *__fastcall _mingw_enum_import_library_names(int i); void __cdecl _mingwthr_run_key_dtors_part_0(); int __fastcall __w64_mingwthr_add_key_dtor(DWORD key, void (*dtor)(void *)); int __fastcall __w64_mingwthr_remove_key_dtor(DWORD key); WINBOOL __fastcall _mingw_TLScallback(HANDLE hDllHandle, DWORD reason, LPVOID reserved); // void __cdecl _set_app_type(_crt_app_type Type); // __int64 __fastcall _getmainargs(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak void (*__cdecl get_invalid_parameter_handler())(const wchar_t *, const wchar_t *, const wchar_t *, unsigned int, uintptr_t); void (*__fastcall set_invalid_parameter_handler(void (*new_handler)(const wchar_t *, const wchar_t *, const wchar_t *, unsigned int, uintptr_t)))(const wchar_t *, const wchar_t *, const wchar_t *, unsigned int, uintptr_t); // void *__cdecl malloc(size_t Size); // size_t __cdecl strlen(const char *Str); // void *__cdecl memcpy(void *, const void *Src, size_t Size); // void __cdecl cexit(); // __int64 __fastcall amsg_exit(_QWORD); weak // void __cdecl initterm(_PVFV *First, _PVFV *Last); // void __cdecl __noreturn exit(int Code); // int printf(const char *const Format, ...); // int sprintf(char *const Buffer, const char *const Format, ...); // void __cdecl _setusermatherr(_UserMathErrorFunctionPointer UserMathErrorFunction); // FILE *__cdecl _iob_func(); // int fprintf(FILE *const Stream, const char *const Format, ...); // size_t __cdecl fwrite(const void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream); // int __cdecl vfprintf(FILE *const Stream, const char *const Format, va_list ArgList); // void __cdecl __noreturn abort(); // _crt_signal_t __cdecl signal(int Signal, _crt_signal_t Function); // __int64 __fastcall lock(_QWORD); weak // __int64 __fastcall _dllonexit(_QWORD, _QWORD, _QWORD); weak // __int64 __fastcall unlock(_QWORD); weak // int __cdecl strncmp(const char *Str1, const char *Str2, size_t MaxCount); // void *__cdecl calloc(size_t Count, size_t Size); // void __cdecl free(void *Block); // int __fastcall main(int flags, char **cmdline, char **inst); idb // __int64 __fastcall _IAT_start__(_QWORD, _QWORD, _QWORD); weak // __int64 __lconv_init(void); weak //------------------------------------------------------------------------- // Data declarations func_ptr *p_73208 = (func_ptr *)0x403338LL; // idb UINT_PTR _security_cookie = 47936899621426uLL; // idb UINT_PTR _security_cookie_complement = 18446696136809930189uLL; // idb char aSfmsilqzdxajhn[53] = &#34;sfMSiLQzdXajhnZKrPyAoHbTDNREWtuVOcGIxkYemgBClvwFUpqJ&#34;; // weak const EXCEPTION_POINTERS GS_ExceptionPointers = { &amp;GS_ExceptionRecord, &amp;GS_ContextRecord }; // idb int *refptr__CRT_MT = &amp;CRT_MT; // weak int *refptr__MINGW_INSTALL_DEBUG_MATHERR = &amp;MINGW_INSTALL_DEBUG_MATHERR; // weak __int64 (*refptr___CTOR_LIST__)[2] = &amp;__CTOR_LIST__; // weak _UNKNOWN *refptr___RUNTIME_PSEUDO_RELOC_LIST_END__ = &amp;_RUNTIME_PSEUDO_RELOC_LIST_END___0; // weak _UNKNOWN *refptr___RUNTIME_PSEUDO_RELOC_LIST__ = &amp;_RUNTIME_PSEUDO_RELOC_LIST_END___0; // weak const PBYTE refptr___image_base__ = (const PBYTE)0x400000LL; // idb _UNKNOWN *refptr___imp__fmode = &amp;_fmode; // weak _UNKNOWN *refptr___imp__onexit = &amp;_onexit; // weak __int64 *refptr___onexitbegin = &amp;_onexitbegin; // weak __int64 *refptr___onexitend = &amp;_onexitend; // weak int *refptr__dowildcard = &amp;dowildcard; // weak int *refptr__fmode = &amp;fmode; // weak int *refptr__newmode = &amp;newmode; // weak int *refptr_mingw_app_type = &amp;mingw_app_type; // weak int *refptr_mingw_initcharmax = &amp;mingw_initcharmax; // weak int *refptr_mingw_initltsdrot_force = &amp;mingw_initltsdrot_force; // weak int *refptr_mingw_initltsdyn_force = &amp;mingw_initltsdyn_force; // weak int *refptr_mingw_initltssuo_force = &amp;mingw_initltssuo_force; // weak _startupinfo _bss_start__; // idb int managedapp; // idb int argret; // idb char **envp; // idb char **argv; // idb int argc; // idb fUserMathErr stUserMathErr; // idb int was_init_73980; // idb int maxSections; // idb sSecInfo *the_secs; // idb int was_here_73812; // idb UNWIND_INFO emu_xdata[32]; // idb RUNTIME_FUNCTION emu_pdata[32]; // idb int initialized; // idb CONTEXT GS_ContextRecord; // idb EXCEPTION_RECORD GS_ExceptionRecord; // idb volatile __mingwthr_key_t *key_dtor_list; // idb volatile int _mingwthr_cs_init; // idb CRITICAL_SECTION _mingwthr_cs; // idb void (*handler)(const wchar_t *, const wchar_t *, const wchar_t *, unsigned int, uintptr_t); // idb _PVFV *_onexitbegin; // idb _PVFV *_onexitend; // idb // extern void (__stdcall *EnterCriticalSection)(LPCRITICAL_SECTION lpCriticalSection); // extern HANDLE (__stdcall *GetCurrentProcess)(); // extern DWORD (__stdcall *GetCurrentProcessId)(); // extern DWORD (__stdcall *GetCurrentThreadId)(); // extern DWORD (__stdcall *GetLastError)(); // extern void (__stdcall *GetSystemTimeAsFileTime)(LPFILETIME lpSystemTimeAsFileTime); // extern DWORD (__stdcall *GetTickCount)(); // extern void (__stdcall *InitializeCriticalSection)(LPCRITICAL_SECTION lpCriticalSection); // extern void (__stdcall *LeaveCriticalSection)(LPCRITICAL_SECTION lpCriticalSection); // extern BOOL (__stdcall *QueryPerformanceCounter)(LARGE_INTEGER *lpPerformanceCount); // extern BOOLEAN (__cdecl *RtlAddFunctionTable)(PRUNTIME_FUNCTION FunctionTable, ULONG EntryCount, ULONG64 BaseAddress); // extern void (__stdcall *RtlCaptureContext)(PCONTEXT ContextRecord); // extern PRUNTIME_FUNCTION (__stdcall *RtlLookupFunctionEntry)(ULONG64 ControlPc, PULONG64 ImageBase, PUNWIND_HISTORY_TABLE HistoryTable); // extern PEXCEPTION_ROUTINE (__stdcall *RtlVirtualUnwind)(ULONG HandlerType, ULONG64 ImageBase, ULONG64 ControlPc, PRUNTIME_FUNCTION FunctionEntry, PCONTEXT ContextRecord, PVOID *HandlerData, PULONG64 EstablisherFrame, PKNONVOLATILE_CONTEXT_POINTERS ContextPointers); // extern LPTOP_LEVEL_EXCEPTION_FILTER (__stdcall *SetUnhandledExceptionFilter)(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter); // extern BOOL (__stdcall *TerminateProcess)(HANDLE hProcess, UINT uExitCode); // extern LPVOID (__stdcall *TlsGetValue)(DWORD dwTlsIndex); // extern LONG (__stdcall *UnhandledExceptionFilter)(struct _EXCEPTION_POINTERS *ExceptionInfo); // extern BOOL (__stdcall *VirtualProtect)(LPVOID lpAddress, SIZE_T dwSize, DWORD flNewProtect, PDWORD lpflOldProtect); // extern SIZE_T (__stdcall *VirtualQuery)(LPCVOID lpAddress, PMEMORY_BASIC_INFORMATION lpBuffer, SIZE_T dwLength); // extern HWND (__stdcall *CreateDialogParamA)(HINSTANCE hInstance, LPCSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam); // extern LRESULT (__stdcall *DispatchMessageA)(const MSG *lpMsg); // extern BOOL (__stdcall *EndDialog)(HWND hDlg, INT_PTR nResult); // extern UINT (__stdcall *GetDlgItemTextA)(HWND hDlg, int nIDDlgItem, LPSTR lpString, int cchMax); // extern BOOL (__stdcall *GetMessageA)(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax); // extern BOOL (__stdcall *IsDialogMessageA)(HWND hDlg, LPMSG lpMsg); // extern HMENU (__stdcall *LoadMenuA)(HINSTANCE hInstance, LPCSTR lpMenuName); // extern int (__stdcall *MessageBoxA)(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType); // extern BOOL (__stdcall *SetMenu)(HWND hWnd, HMENU hMenu); // extern BOOL (__stdcall *ShowWindow)(HWND hWnd, int nCmdShow); // extern BOOL (__stdcall *TranslateMessage)(const MSG *lpMsg); //----- (0000000000401010) ---------------------------------------------------- int __cdecl pre_c_init() { _BOOL8 v0; // rdx void *v1; // rax BYTE *v3; // rax __int16 v4; // cx LODWORD(v0) = 0; *refptr_mingw_initltsdrot_force = 1; *refptr_mingw_initltsdyn_force = 1; *refptr_mingw_initltssuo_force = 1; *refptr_mingw_initcharmax = 1; if ( *refptr___image_base__ == 23117 ) { v3 = &amp;refptr___image_base__[*(refptr___image_base__ &#43; 15)]; if ( *v3 == 17744 ) { v4 = *(v3 &#43; 12); if ( v4 == 267 ) { if ( *(v3 &#43; 29) &gt; 0xEu ) v0 = *(v3 &#43; 58) != 0; } else if ( v4 == 523 &amp;&amp; *(v3 &#43; 33) &gt; 0xEu ) { v0 = *(v3 &#43; 62) != 0; } } } managedapp = v0; if ( *refptr_mingw_app_type ) _set_app_type(_crt_gui_app); else _set_app_type(_crt_console_app); v1 = encode_pointer(0xFFFFFFFFFFFFFFFFLL); *refptr___onexitend = v1; *refptr___onexitbegin = v1; **refptr___imp__fmode = *refptr__fmode; setargv(); if ( *refptr__MINGW_INSTALL_DEBUG_MATHERR == 1 ) _mingw_setusermatherr(matherr); return 0; } // 405370: using guessed type int *refptr__MINGW_INSTALL_DEBUG_MATHERR; // 4053F0: using guessed type _UNKNOWN *refptr___imp__fmode; // 405470: using guessed type __int64 *refptr___onexitbegin; // 405480: using guessed type __int64 *refptr___onexitend; // 4054E0: using guessed type int *refptr__fmode; // 405520: using guessed type int *refptr_mingw_app_type; // 405530: using guessed type int *refptr_mingw_initcharmax; // 405540: using guessed type int *refptr_mingw_initltsdrot_force; // 405550: using guessed type int *refptr_mingw_initltsdyn_force; // 405560: using guessed type int *refptr_mingw_initltssuo_force; //----- (0000000000401160) ---------------------------------------------------- void __cdecl pre_cpp_init() { _bss_start__.newmode = *refptr__newmode; argret = _getmainargs(&amp;argc, &amp;argv, &amp;envp, *refptr__dowildcard, &amp;_bss_start__); } // 4030D0: using guessed type __int64 __fastcall _getmainargs(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); // 4054D0: using guessed type int *refptr__dowildcard; // 405510: using guessed type int *refptr__newmode; //----- (0000000000401500) ---------------------------------------------------- int __cdecl mainCRTStartup() { *refptr_mingw_app_type = 0; _security_init_cookie(); return _tmainCRTStartup(); } // 405520: using guessed type int *refptr_mingw_app_type; //----- (0000000000401530) ---------------------------------------------------- char *__fastcall generaLetras(int a1, char *a2) { size_t v2; // rax char *result; // rax int v4; // [rsp&#43;28h] [rbp-58h] int v5; // [rsp&#43;2Ch] [rbp-54h] int v6; // [rsp&#43;30h] [rbp-50h] int v7; // [rsp&#43;34h] [rbp-4Ch] v7 = (a1 &#43; 15) % strlen(&#34;sfMSiLQzdXajhnZKrPyAoHbTDNREWtuVOcGIxkYemgBClvwFUpqJ&#34;); v6 = (a1 &#43; 22) % strlen(&#34;sfMSiLQzdXajhnZKrPyAoHbTDNREWtuVOcGIxkYemgBClvwFUpqJ&#34;); v5 = (a1 &#43; 32) % strlen(&#34;sfMSiLQzdXajhnZKrPyAoHbTDNREWtuVOcGIxkYemgBClvwFUpqJ&#34;); v4 = (a1 &#43; 17) % strlen(&#34;sfMSiLQzdXajhnZKrPyAoHbTDNREWtuVOcGIxkYemgBClvwFUpqJ&#34;); v2 = strlen(&#34;sfMSiLQzdXajhnZKrPyAoHbTDNREWtuVOcGIxkYemgBClvwFUpqJ&#34;); *a2 = aSfmsilqzdxajhn[v7]; a2[1] = aSfmsilqzdxajhn[v6]; a2[2] = aSfmsilqzdxajhn[v5]; a2[3] = aSfmsilqzdxajhn[v4]; a2[4] = aSfmsilqzdxajhn[((a1 &#43; 4) % v2)]; result = a2 &#43; 5; a2[5] = 0; return result; } //----- (00000000004016AD) ---------------------------------------------------- __int64 __fastcall generaNumero(char *a1) { int i; // [rsp&#43;28h] [rbp-58h] int v3; // [rsp&#43;2Ch] [rbp-54h] v3 = 0; for ( i = 0; i &lt; strlen(a1); &#43;&#43;i ) v3 &#43;= a1[i]; printf(&#34;Numero: %d&#34;, v3 &#43; 6572); return (v3 &#43; 6572); } //----- (0000000000401746) ---------------------------------------------------- int __fastcall generaSerial(char *a1, char *a2) { char v3[16]; // [rsp&#43;40h] [rbp-50h] BYREF char v4[16]; // [rsp&#43;50h] [rbp-40h] BYREF char v5[16]; // [rsp&#43;60h] [rbp-30h] BYREF char v6[16]; // [rsp&#43;70h] [rbp-20h] BYREF char v7[12]; // [rsp&#43;80h] [rbp-10h] BYREF int v8; // [rsp&#43;8Ch] [rbp-4h] v8 = generaNumero(a1); generaLetras(v8, v7); v8 = generaNumero(v7); generaLetras(v8, v6); v8 = generaNumero(v6); generaLetras(v8, v5); v8 = generaNumero(v5); generaLetras(v8, v4); v8 = generaNumero(v4); generaLetras(v8, v3); return sprintf(a2, &#34;%s-%s-%s-%s-%s&#34;, v7, v6, v5, v4, v3); } //----- (000000000040182D) ---------------------------------------------------- int __fastcall checkSerial(char *a1, char *a2) { size_t v2; // rbx size_t v3; // rax int i; // [rsp&#43;28h] [rbp-58h] char v6; // [rsp&#43;2Fh] [rbp-51h] v6 = 1; v2 = strlen(a1); if ( v2 == strlen(a2) ) { for ( i = 0; ; &#43;&#43;i ) { v3 = strlen(a2); if ( i &gt;= v3 ) break; if ( a1[i] != a2[i] ) { LODWORD(v3) = MessageBoxA(0LL, &#34;Nope sigue intentando&#34;, &#34;Nop&#34;, 0x30u); v6 = 0; break; } } if ( v6 ) LODWORD(v3) = MessageBoxA(0LL, &#34;Genial lo lograste&#34;, &#34;Felicitaciones&#34;, 0); } else { MessageBoxA(0LL, &#34;Nope sigue intentando&#34;, &#34;Nop&#34;, 0x30u); LODWORD(v3) = 0; } return v3; } //----- (000000000040192F) ---------------------------------------------------- INT_PTR __fastcall DialogProc(HWND a1, int a2, unsigned __int16 a3) { char v4[32]; // [rsp&#43;20h] [rbp-60h] BYREF CHAR v5[32]; // [rsp&#43;40h] [rbp-40h] BYREF CHAR String[28]; // [rsp&#43;60h] [rbp-20h] BYREF UINT DlgItemTextA; // [rsp&#43;7Ch] [rbp-4h] DlgItemTextA = 0; switch ( a2 ) { case 272: return 1LL; case 273: if ( a3 == 40000 ) { DlgItemTextA = GetDlgItemTextA(a1, 40002, String, 20); if ( DlgItemTextA ) { DlgItemTextA = GetDlgItemTextA(a1, 40003, v5, 30); if ( DlgItemTextA ) { generaSerial(String, v4); checkSerial(v5, v4); return 1LL; } MessageBoxA(a1, &#34;Nope sigue intentando&#34;, &#34;Nop&#34;, 0x30u); } else { MessageBoxA(a1, &#34;Nope sigue intentando&#34;, &#34;Nop&#34;, 0x30u); } } else if ( a3 == 40006 ) { MessageBoxA(a1, &#34;keygeneame si puedes\n\nEl objetivo es crear el keygen sin parchear nada&#34;, &#34;About&#34;, 0x40u); return 1LL; } return 1LL; case 16: EndDialog(a1, 0LL); return 1LL; default: return 0LL; } } //----- (0000000000401AA6) ---------------------------------------------------- int __stdcall WinMain(HINSTANCE hInst, HINSTANCE hPreInst, LPSTR lpszCmdLine, int nCmdShow) { tagMSG Msg; // [rsp&#43;30h] [rbp-40h] BYREF HMENU hMenu; // [rsp&#43;60h] [rbp-10h] HWND hWnd; // [rsp&#43;68h] [rbp-8h] hWnd = CreateDialogParamA(hInst, 102, 0LL, DialogProc, 0LL); hMenu = LoadMenuA(hInst, 0x69); SetMenu(hWnd, hMenu); ShowWindow(hWnd, 10); while ( GetMessageA(&amp;Msg, 0LL, 0, 0) &gt; 0 ) { if ( !IsDialogMessageA(hWnd, &amp;Msg) ) { TranslateMessage(&amp;Msg); DispatchMessageA(&amp;Msg); } } return 0; } //----- (0000000000401BA0) ---------------------------------------------------- void *__fastcall decode_pointer(void *codedptr) { return codedptr; } //----- (0000000000401BB0) ---------------------------------------------------- void *__fastcall encode_pointer(void *ptr) { return ptr; } //----- (0000000000401BC0) ---------------------------------------------------- int __cdecl setargv() { return 0; } //----- (0000000000401BD0) ---------------------------------------------------- void __fastcall _mingw_raise_matherr(int typ, const char *name, double a3, double a1, double rslt) { _exception ex; // [rsp&#43;20h] [rbp-38h] BYREF if ( stUserMathErr ) { ex.type = typ; ex.name = name; ex.arg1 = a3; ex.arg2 = a1; ex.retval = rslt; stUserMathErr(&amp;ex); } } //----- (0000000000401C20) ---------------------------------------------------- void __fastcall _mingw_setusermatherr(int (*f)(_exception *)) { stUserMathErr = f; _setusermatherr(f); } //----- (0000000000401C30) ---------------------------------------------------- int __fastcall matherr(_exception *pexcept) { const char *v1; // rbx double retval; // xmm8_8 const char *name; // rsi double arg2; // xmm7_8 double arg1; // xmm6_8 FILE *v6; // rax switch ( pexcept-&gt;type ) { case 1: v1 = &#34;Argument domain error (DOMAIN)&#34;; break; case 2: v1 = &#34;Argument singularity (SIGN)&#34;; break; case 3: v1 = &#34;Overflow range error (OVERFLOW)&#34;; break; case 4: v1 = &#34;The result is too small to be represented (UNDERFLOW)&#34;; break; case 5: v1 = &#34;Total loss of significance (TLOSS)&#34;; break; case 6: v1 = &#34;Partial loss of significance (PLOSS)&#34;; break; default: v1 = &#34;Unknown error&#34;; break; } retval = pexcept-&gt;retval; name = pexcept-&gt;name; arg2 = pexcept-&gt;arg2; arg1 = pexcept-&gt;arg1; v6 = _iob_func(); fprintf(v6 &#43; 2, &#34;_matherr(): %s in %s(%g, %g) (retval=%g)\n&#34;, v1, name, arg1, arg2, retval); return 0; } //----- (0000000000401D30) ---------------------------------------------------- void __noreturn _report_error(const char *msg, ...) { FILE *v2; // rax FILE *v3; // rax va_list va; // [rsp&#43;58h] [rbp&#43;10h] BYREF va_start(va, msg); v2 = _iob_func(); fwrite(&#34;Mingw-w64 runtime failure:\n&#34;, 1uLL, 0x1BuLL, v2 &#43; 2); v3 = _iob_func(); vfprintf(v3 &#43; 2, msg, va); abort(); } //----- (0000000000401DA0) ---------------------------------------------------- void __fastcall _write_memory_part_0(void *addr, const void *src, size_t len) { __int64 v3; // rbp int v7; // r9d PBYTE *p_sec_start; // rax PIMAGE_SECTION_HEADER SectionForAddress; // rax PIMAGE_SECTION_HEADER v10; // r12 __int64 v11; // rbp sSecInfo *v12; // r13 DWORD LastError; // eax struct _MEMORY_BASIC_INFORMATION Buffer; // [rsp&#43;20h] [rbp-68h] BYREF v3 = maxSections; if ( maxSections &lt;= 0 ) { v3 = 0LL; LABEL_6: SectionForAddress = _mingw_GetSectionForAddress(addr); v10 = SectionForAddress; if ( !SectionForAddress ) _report_error(&#34;Address %p has no image-section&#34;, addr); v11 = v3; v12 = &amp;the_secs[v11]; v12-&gt;hash = SectionForAddress; v12-&gt;old_protect = 0; v12-&gt;sec_start = &amp;GetPEImageBase()[SectionForAddress-&gt;VirtualAddress]; if ( !VirtualQuery(the_secs[v11].sec_start, &amp;Buffer, 0x30uLL) ) _report_error( &#34; VirtualQuery failed for %d bytes at address %p&#34;, v10-&gt;Misc.PhysicalAddress, the_secs[v11].sec_start); if ( ((Buffer.Protect - 4) &amp; 0xFFFFFFFB) != 0 &amp;&amp; ((Buffer.Protect - 64) &amp; 0xFFFFFFBF) != 0 &amp;&amp; !VirtualProtect(Buffer.BaseAddress, Buffer.RegionSize, 0x40u, &amp;the_secs[v11].old_protect) ) { LastError = GetLastError(); _report_error(&#34; VirtualProtect failed with code 0x%x&#34;, LastError); } &#43;&#43;maxSections; } else { v7 = 0; p_sec_start = &amp;the_secs-&gt;sec_start; while ( addr &lt; *p_sec_start || addr &gt;= &amp;(*p_sec_start)[*(p_sec_start[1] &#43; 2)] ) { &#43;&#43;v7; p_sec_start &#43;= 3; if ( v7 == maxSections ) goto LABEL_6; } } memcpy(addr, src, len); } //----- (0000000000401F10) ---------------------------------------------------- void __cdecl pei386_runtime_relocator() { unsigned __int64 v0; // rax void *v1; // rsp _DWORD *v2; // rbx void *v3; // rsp int v4; // edx unsigned int *v5; // rbx unsigned int v6; // edx BYTE *v7; // rax BYTE *v8; // rcx __int64 v9; // r8 __int64 v10; // rbx int i; // esi __int64 v12; // rcx int v13; // eax BYTE *v14; // rcx unsigned __int64 v15; // rdx unsigned __int64 v16; // rdx unsigned __int64 v17; // rdx char v18; // [rsp&#43;20h] [rbp-40h] BYREF DWORD flOldProtect; // [rsp&#43;2Ch] [rbp-34h] BYREF struct _MEMORY_BASIC_INFORMATION src; // [rsp&#43;30h] [rbp-30h] BYREF if ( was_init_73980 ) return; was_init_73980 = 1; v0 = (24LL * _mingw_GetSectionCount() &#43; 30) &amp; 0xFFFFFFFFFFFFFFF0uLL; v1 = alloca(v0); v2 = refptr___RUNTIME_PSEUDO_RELOC_LIST__; v3 = alloca(v0); maxSections = 0; the_secs = &amp;v18; if ( refptr___RUNTIME_PSEUDO_RELOC_LIST_END__ - refptr___RUNTIME_PSEUDO_RELOC_LIST__ &lt;= 7 ) return; if ( refptr___RUNTIME_PSEUDO_RELOC_LIST_END__ - refptr___RUNTIME_PSEUDO_RELOC_LIST__ &gt; 11 ) { if ( *refptr___RUNTIME_PSEUDO_RELOC_LIST__ || *(refptr___RUNTIME_PSEUDO_RELOC_LIST__ &#43; 1) ) goto LABEL_25; if ( *(refptr___RUNTIME_PSEUDO_RELOC_LIST__ &#43; 2) ) goto LABEL_11; v2 = (refptr___RUNTIME_PSEUDO_RELOC_LIST__ &#43; 12); } if ( *v2 || v2[1] ) { LABEL_25: if ( v2 &gt;= refptr___RUNTIME_PSEUDO_RELOC_LIST_END__ ) return; do { v12 = v2[1]; v13 = *v2; v2 &#43;= 2; v14 = &amp;refptr___image_base__[v12]; LODWORD(src.BaseAddress) = *v14 &#43; v13; _write_memory_part_0(v14, &amp;src, 4uLL); } while ( v2 &lt; refptr___RUNTIME_PSEUDO_RELOC_LIST_END__ ); goto LABEL_19; } LABEL_11: v4 = v2[2]; if ( v4 != 1 ) _report_error(&#34; Unknown pseudo relocation protocol version %d.\n&#34;, v4); v5 = v2 &#43; 3; if ( v5 &lt; refptr___RUNTIME_PSEUDO_RELOC_LIST_END__ ) { do { v6 = *(v5 &#43; 8); v7 = &amp;refptr___image_base__[*v5]; v8 = &amp;refptr___image_base__[v5[1]]; v9 = *v7; if ( v6 == 16 ) { v16 = *v8; if ( (v16 &amp; 0x8000u) != 0LL ) v16 = *v8 | 0xFFFFFFFFFFFF0000uLL; src.BaseAddress = (v9 &#43; v16 - v7); _write_memory_part_0(v8, &amp;src, 2uLL); } else if ( v6 &lt;= 0x10 ) { if ( v6 != 8 ) { LABEL_35: src.BaseAddress = 0LL; _report_error(&#34; Unknown pseudo relocation bit size %d.\n&#34;, v6); } v15 = *v8; if ( (v15 &amp; 0x80u) != 0LL ) v15 = *v8 | 0xFFFFFFFFFFFFFF00uLL; src.BaseAddress = (v9 &#43; v15 - v7); _write_memory_part_0(v8, &amp;src, 1uLL); } else if ( v6 == 32 ) { v17 = *v8; if ( (v17 &amp; 0x80000000) != 0LL ) v17 = *v8 | 0xFFFFFFFF00000000uLL; src.BaseAddress = (v9 &#43; v17 - v7); _write_memory_part_0(v8, &amp;src, 4uLL); } else { if ( v6 != 64 ) goto LABEL_35; src.BaseAddress = (*v8 &#43; v9 - v7); _write_memory_part_0(v8, &amp;src, 8uLL); } v5 &#43;= 3; } while ( v5 &lt; refptr___RUNTIME_PSEUDO_RELOC_LIST_END__ ); LABEL_19: v10 = 0LL; for ( i = 0; i &lt; maxSections; &#43;&#43;v10 ) { if ( the_secs[v10].old_protect ) { if ( !VirtualQuery(the_secs[v10].sec_start, &amp;src, 0x30uLL) ) _report_error( &#34; VirtualQuery failed for %d bytes at address %p&#34;, the_secs[v10].hash-&gt;Misc.PhysicalAddress, the_secs[v10].sec_start); VirtualProtect(src.BaseAddress, src.RegionSize, the_secs[v10].old_protect, &amp;flOldProtect); } &#43;&#43;i; } } } // 405390: using guessed type _UNKNOWN *refptr___RUNTIME_PSEUDO_RELOC_LIST_END__; // 4053A0: using guessed type _UNKNOWN *refptr___RUNTIME_PSEUDO_RELOC_LIST__; //----- (0000000000402210) ---------------------------------------------------- int __fastcall _mingw_SEH_error_handler( _EXCEPTION_RECORD *ExceptionRecord, void *EstablisherFrame, _CONTEXT *ContextRecord, void *DispatcherContext) { DWORD ExceptionCode; // eax _crt_signal_t v5; // rax int result; // eax _crt_signal_t v7; // rdx _crt_signal_t v8; // rax ExceptionCode = ExceptionRecord-&gt;ExceptionCode; if ( ExceptionRecord-&gt;ExceptionCode &gt; 0xC0000091 ) { if ( ExceptionCode == -1073741676 ) { v7 = signal(8, 0LL); if ( v7 == 1 ) { signal(8, 1); return 0; } goto LABEL_16; } if ( ExceptionCode &gt; 0xC0000094 ) { if ( ExceptionCode == -1073741675 ) return 0; if ( ExceptionCode != -1073741674 ) return 1; goto LABEL_20; } if ( ExceptionCode == -1073741678 ) return 0; if ( ExceptionCode != -1073741677 ) return 1; } else if ( ExceptionCode &lt; 0xC000008D ) { if ( ExceptionCode == -1073741816 ) return 0; if ( ExceptionCode &lt;= 0xC0000008 ) { if ( ExceptionCode != -2147483646 ) { if ( ExceptionCode == -1073741819 ) { v5 = signal(11, 0LL); if ( v5 == 1 ) { signal(11, 1); return 0; } if ( v5 ) { (v5)(11LL); return 0; } return 4; } return 1; } return 0; } if ( ExceptionCode != -1073741795 ) return ExceptionCode != -1073741684; LABEL_20: v8 = signal(4, 0LL); if ( v8 == 1 ) { signal(4, 1); return 0; } if ( v8 ) { (v8)(4LL); return 0; } return 4; } v7 = signal(8, 0LL); if ( v7 == 1 ) { signal(8, 1); fpreset(); return 0; } LABEL_16: result = 1; if ( v7 ) { (v7)(8LL); return 0; } return result; } //----- (00000000004023C0) ---------------------------------------------------- int __cdecl _mingw_init_ehandler() { PBYTE PEImageBase; // rbp int result; // eax RUNTIME_FUNCTION *v2; // rbx size_t v3; // rsi UNWIND_INFO *v4; // rdi DWORD VirtualAddress; // edx DWORD v6; // edx DWORD v7; // eax PIMAGE_SECTION_HEADER PESectionExec; // rax ULONG v9; // edx PEImageBase = GetPEImageBase(); result = was_here_73812; if ( !was_here_73812 &amp;&amp; PEImageBase ) { was_here_73812 = 1; if ( !FindPESectionByName(&#34;.pdata&#34;) ) { v2 = emu_pdata; v3 = 0LL; memset(emu_pdata, 0, sizeof(emu_pdata)); memset(emu_xdata, 0, sizeof(emu_xdata)); v4 = emu_xdata; while ( 1 ) { PESectionExec = FindPESectionExec(v3); if ( !PESectionExec ) break; v4-&gt;VersionAndFlags = 9; v4-&gt;AddressOfExceptionHandler = _mingw_SEH_error_handler - PEImageBase; &#43;&#43;v3; VirtualAddress = PESectionExec-&gt;VirtualAddress; &#43;&#43;v2; v2[-1].BeginAddress = VirtualAddress; v6 = PESectionExec-&gt;Misc.PhysicalAddress &#43; VirtualAddress; v7 = v4&#43;&#43; - PEImageBase; v2[-1].UnwindData = v7; v2[-1].EndAddress = v6; if ( v3 == 32 ) { v9 = 32; goto LABEL_11; } } if ( !v3 ) return 1; v9 = v3; LABEL_11: RtlAddFunctionTable(emu_pdata, v9, PEImageBase); } return 1; } return result; } //----- (0000000000402670) ---------------------------------------------------- void __cdecl fpreset() { __asm { fninit } } //----- (0000000000402680) ---------------------------------------------------- void __cdecl _do_global_dtors() { void (*i)(void); // rax for ( i = *p_73208; i; &#43;&#43;p_73208 ) { i(); i = p_73208[1]; } } //----- (00000000004026C0) ---------------------------------------------------- void __cdecl _do_global_ctors() { int i; // ebx i = (*refptr___CTOR_LIST__)[0]; if ( i == -1 ) { for ( i = 0; (*refptr___CTOR_LIST__)[i &#43; 1]; &#43;&#43;i ) ; } for ( ; i; --i ) ((*refptr___CTOR_LIST__)[i])(); atexit(_do_global_dtors); } // 405380: using guessed type __int64 (*refptr___CTOR_LIST__)[2]; //----- (0000000000402720) ---------------------------------------------------- void __cdecl _main() { if ( !initialized ) { initialized = 1; _do_global_ctors(); } } //----- (0000000000402740) ---------------------------------------------------- void __cdecl _security_init_cookie() { FT v0; // r12 __int64 CurrentProcessId; // rbp DWORD CurrentThreadId; // edi DWORD TickCount; // esi LONGLONG v4; // rsi UINT_PTR v5; // rax FT systime; // [rsp&#43;20h] [rbp-48h] BYREF LARGE_INTEGER perfctr; // [rsp&#43;30h] [rbp-38h] BYREF systime.ft_scalar = 0LL; if ( _security_cookie == 0x2B992DDFA232LL ) { GetSystemTimeAsFileTime(&amp;systime); v0.ft_scalar = systime.ft_scalar; CurrentProcessId = GetCurrentProcessId(); CurrentThreadId = GetCurrentThreadId(); TickCount = GetTickCount(); QueryPerformanceCounter(&amp;perfctr); v4 = (TickCount ^ CurrentThreadId ^ perfctr.QuadPart ^ v0.ft_scalar ^ CurrentProcessId) &amp; 0xFFFFFFFFFFFFLL; if ( v4 == 0x2B992DDFA232LL ) { v5 = 0xFFFFD466D2205DCCuLL; v4 = 0x2B992DDFA233LL; } else { v5 = ~v4; } _security_cookie = v4; _security_cookie_complement = v5; } else { _security_cookie_complement = ~_security_cookie; } } //----- (0000000000402820) ---------------------------------------------------- void __fastcall __noreturn _report_gsfailure(ULONG_PTR StackCookie) { ULONG64 Rip; // rbx _RUNTIME_FUNCTION *v3; // r9 HANDLE CurrentProcess; // rax ULONG64 imgBase; // [rsp&#43;48h] [rbp-28h] BYREF ULONG64 establisherFrame; // [rsp&#43;50h] [rbp-20h] BYREF PVOID hndData; // [rsp&#43;58h] [rbp-18h] BYREF UINT_PTR cookie[2]; // [rsp&#43;60h] [rbp-10h] char vars8; // [rsp&#43;78h] [rbp&#43;8h] BYREF DWORD64 retaddr; // [rsp&#43;88h] [rbp&#43;18h] RtlCaptureContext(&amp;GS_ContextRecord); Rip = GS_ContextRecord.Rip; v3 = RtlLookupFunctionEntry(GS_ContextRecord.Rip, &amp;imgBase, 0LL); if ( v3 ) { RtlVirtualUnwind(0, imgBase, Rip, v3, &amp;GS_ContextRecord, &amp;hndData, &amp;establisherFrame, 0LL); } else { GS_ContextRecord.Rip = retaddr; GS_ContextRecord.Rsp = &amp;vars8; } GS_ContextRecord.Rcx = StackCookie; GS_ExceptionRecord.ExceptionCode = -1073740791; GS_ExceptionRecord.ExceptionFlags = 1; GS_ExceptionRecord.ExceptionAddress = GS_ContextRecord.Rip; cookie[1] = _security_cookie_complement; SetUnhandledExceptionFilter(0LL); UnhandledExceptionFilter(&amp;GS_ExceptionPointers); CurrentProcess = GetCurrentProcess(); TerminateProcess(CurrentProcess, 0xC0000409); abort(); } //----- (0000000000402920) ---------------------------------------------------- BOOL __fastcall _dyn_tls_dtor(HANDLE hDllHandle, DWORD dwReason, LPVOID lpreserved) { if ( dwReason &amp;&amp; dwReason != 3 ) return 1; _mingw_TLScallback(hDllHandle, dwReason, lpreserved); return 1; } //----- (0000000000402950) ---------------------------------------------------- BOOL __fastcall _dyn_tls_init(HANDLE hDllHandle, DWORD dwReason, LPVOID lpreserved) { if ( *refptr__CRT_MT != 2 ) *refptr__CRT_MT = 2; if ( dwReason == 1 ) _mingw_TLScallback(hDllHandle, 1u, lpreserved); return 1; } // 405360: using guessed type int *refptr__CRT_MT; //----- (00000000004029C0) ---------------------------------------------------- int __fastcall _tlregdtor(_PVFV func) { return 0; } //----- (00000000004029D0) ---------------------------------------------------- _onexit_t __fastcall mingw_onexit(_onexit_t func) { int (*v2)(void); // rbx _PVFV *onexitbegin; // [rsp&#43;20h] [rbp-18h] BYREF _PVFV *onexitend; // [rsp&#43;28h] [rbp-10h] BYREF onexitbegin = decode_pointer(_onexitbegin); if ( onexitbegin == -1LL ) return (*refptr___imp__onexit)(func); lock(8LL); onexitbegin = decode_pointer(_onexitbegin); onexitend = decode_pointer(_onexitend); v2 = _dllonexit(func, &amp;onexitbegin, &amp;onexitend); _onexitbegin = encode_pointer(onexitbegin); _onexitend = encode_pointer(onexitend); unlock(8LL); return v2; } // 403180: using guessed type __int64 __fastcall lock(_QWORD); // 403188: using guessed type __int64 __fastcall _dllonexit(_QWORD, _QWORD, _QWORD); // 403190: using guessed type __int64 __fastcall unlock(_QWORD); // 405400: using guessed type _UNKNOWN *refptr___imp__onexit; //----- (0000000000402A80) ---------------------------------------------------- int __fastcall atexit(_PVFV func) { return -(mingw_onexit(func) == 0LL); } //----- (0000000000402AA0) ---------------------------------------------------- int __cdecl my_lconv_init() { return __lconv_init(); } // 409350: using guessed type __int64 __lconv_init(void); //----- (0000000000402AB0) ---------------------------------------------------- WINBOOL __fastcall ValidateImageBase_part_0(PBYTE pImageBase) { BYTE *v1; // rcx WINBOOL result; // eax v1 = &amp;pImageBase[*(pImageBase &#43; 15)]; result = 0; if ( *v1 == 17744 ) return *(v1 &#43; 12) == 523; return result; } //----- (0000000000402AD0) ---------------------------------------------------- WINBOOL __fastcall ValidateImageBase(PBYTE pImageBase) { if ( *pImageBase == 23117 ) return ValidateImageBase_part_0(pImageBase); else return 0; } //----- (0000000000402AF0) ---------------------------------------------------- PIMAGE_SECTION_HEADER __fastcall FindPESection(PBYTE pImageBase, DWORD_PTR rva) { BYTE *v2; // rcx PIMAGE_SECTION_HEADER result; // rax int v4; // ecx _IMAGE_SECTION_HEADER *v5; // r9 v2 = &amp;pImageBase[*(pImageBase &#43; 15)]; result = &amp;v2[*(v2 &#43; 10) &#43; 24]; v4 = *(v2 &#43; 3); if ( !v4 ) return 0LL; v5 = &amp;result[(v4 - 1) &#43; 1]; while ( result-&gt;VirtualAddress &gt; rva || rva &gt;= result-&gt;Misc.PhysicalAddress &#43; result-&gt;VirtualAddress ) { if ( &#43;&#43;result == v5 ) return 0LL; } return result; } //----- (0000000000402B40) ---------------------------------------------------- PIMAGE_SECTION_HEADER __fastcall FindPESectionByName(const char *pName) { BYTE *v3; // rdx _IMAGE_SECTION_HEADER *v4; // rbx int v5; // edx __int64 v6; // rdi if ( strlen(pName) &gt; 8 ) return 0LL; if ( *refptr___image_base__ != 23117 ) return 0LL; if ( !ValidateImageBase_part_0(refptr___image_base__) ) return 0LL; v3 = &amp;refptr___image_base__[*(refptr___image_base__ &#43; 15)]; v4 = &amp;v3[*(v3 &#43; 10) &#43; 24]; v5 = *(v3 &#43; 3); if ( !v5 ) return 0LL; v6 = &amp;v4[(v5 - 1) &#43; 1]; while ( strncmp(v4, pName, 8uLL) ) { if ( &#43;&#43;v4 == v6 ) return 0LL; } return v4; } //----- (0000000000402BE0) ---------------------------------------------------- PIMAGE_SECTION_HEADER __fastcall _mingw_GetSectionForAddress(LPVOID p) { if ( *refptr___image_base__ == 23117 &amp;&amp; ValidateImageBase_part_0(refptr___image_base__) ) return FindPESection(refptr___image_base__, p - refptr___image_base__); else return 0LL; } //----- (0000000000402C30) ---------------------------------------------------- int __cdecl _mingw_GetSectionCount() { int result; // eax result = 0; if ( *refptr___image_base__ == 23117 ) { result = ValidateImageBase_part_0(refptr___image_base__); if ( result ) return *&amp;refptr___image_base__[*(refptr___image_base__ &#43; 15) &#43; 6]; } return result; } //----- (0000000000402C70) ---------------------------------------------------- PIMAGE_SECTION_HEADER __fastcall FindPESectionExec(size_t eNo) { BYTE *v3; // rsi __int64 v4; // rdx __int64 v5; // rax if ( *refptr___image_base__ != 23117 ) return 0LL; if ( !ValidateImageBase_part_0(refptr___image_base__) ) return 0LL; v3 = &amp;refptr___image_base__[*(refptr___image_base__ &#43; 15)]; v4 = &amp;v3[*(v3 &#43; 10) &#43; 24]; if ( !*(v3 &#43; 3) ) return 0LL; v5 = v4 &#43; 40LL * (*(v3 &#43; 3) - 1) &#43; 40; while ( (*(v4 &#43; 39) &amp; 0x20) == 0 ) { LABEL_9: v4 &#43;= 40LL; if ( v4 == v5 ) return 0LL; } if ( eNo ) { --eNo; goto LABEL_9; } return v4; } //----- (0000000000402D00) ---------------------------------------------------- PBYTE __cdecl GetPEImageBase() { BYTE *v0; // rbx v0 = 0LL; if ( *refptr___image_base__ != 23117 ) return 0LL; if ( ValidateImageBase_part_0(refptr___image_base__) ) return refptr___image_base__; return v0; } //----- (0000000000402D40) ---------------------------------------------------- WINBOOL __fastcall IsNonwritableInCurrentImage(PBYTE pTarget) { WINBOOL result; // eax PIMAGE_SECTION_HEADER PESection; // rax result = 0; if ( *refptr___image_base__ == 23117 ) { result = ValidateImageBase_part_0(refptr___image_base__); if ( result ) { PESection = FindPESection(refptr___image_base__, pTarget - refptr___image_base__); return PESection &amp;&amp; (PESection-&gt;Characteristics &amp; 0x80000000) == 0; } } return result; } //----- (0000000000402DA0) ---------------------------------------------------- const char *__fastcall _mingw_enum_import_library_names(int i) { unsigned int v3; // edx __int64 v4; // rbx BYTE *v5; // rdx if ( *refptr___image_base__ != 23117 ) return 0LL; if ( !ValidateImageBase_part_0(refptr___image_base__) ) return 0LL; v3 = *&amp;refptr___image_base__[*(refptr___image_base__ &#43; 15) &#43; 144]; if ( !v3 ) return 0LL; v4 = v3; if ( !FindPESection(refptr___image_base__, v3) ) return 0LL; v5 = &amp;refptr___image_base__[v4]; if ( !&amp;refptr___image_base__[v4] ) return 0LL; while ( *(v5 &#43; 1) || *(v5 &#43; 3) ) { if ( i &lt;= 0 ) return &amp;refptr___image_base__[*(v5 &#43; 3)]; --i; v5 &#43;= 20; } return 0LL; } //----- (0000000000402E50) ---------------------------------------------------- void __cdecl _mingwthr_run_key_dtors_part_0() { volatile __mingwthr_key_t *i; // rbx LPVOID Value; // rsi EnterCriticalSection(&amp;_mingwthr_cs); for ( i = key_dtor_list; i; i = i-&gt;next ) { Value = TlsGetValue(i-&gt;key); if ( !GetLastError() &amp;&amp; Value ) i-&gt;dtor(Value); } LeaveCriticalSection(&amp;_mingwthr_cs); } //----- (0000000000402EC0) ---------------------------------------------------- int __fastcall __w64_mingwthr_add_key_dtor(DWORD key, void (*dtor)(void *)) { int result; // eax volatile __mingwthr_key_t *v5; // rax volatile __mingwthr_key_t *v6; // rbx volatile __mingwthr_key_t *v7; // rax result = _mingwthr_cs_init; if ( _mingwthr_cs_init ) { v5 = calloc(1uLL, 0x18uLL); v6 = v5; if ( v5 ) { v5-&gt;key = key; v5-&gt;dtor = dtor; EnterCriticalSection(&amp;_mingwthr_cs); v7 = key_dtor_list; key_dtor_list = v6; v6-&gt;next = v7; LeaveCriticalSection(&amp;_mingwthr_cs); return 0; } else { return -1; } } return result; } //----- (0000000000402F40) ---------------------------------------------------- int __fastcall __w64_mingwthr_remove_key_dtor(DWORD key) { volatile __mingwthr_key_t *v3; // rdx volatile __mingwthr_key_t *next; // rax volatile __mingwthr_key_t *v5; // rcx if ( !_mingwthr_cs_init ) return 0; EnterCriticalSection(&amp;_mingwthr_cs); v3 = key_dtor_list; if ( key_dtor_list ) { if ( key_dtor_list-&gt;key == key ) { v5 = key_dtor_list; key_dtor_list = key_dtor_list-&gt;next; LABEL_12: free(v5); LeaveCriticalSection(&amp;_mingwthr_cs); return 0; } while ( 1 ) { next = v3-&gt;next; if ( !next ) break; if ( next-&gt;key == key ) { v5 = v3-&gt;next; v3-&gt;next = next-&gt;next; goto LABEL_12; } v3 = v3-&gt;next; } } LeaveCriticalSection(&amp;_mingwthr_cs); return 0; } //----- (0000000000402FE0) ---------------------------------------------------- // local variable allocation has failed, the output may be wrong! WINBOOL __fastcall _mingw_TLScallback(HANDLE hDllHandle, DWORD reason, LPVOID reserved) { WINBOOL result; // eax if ( reason == 1 ) { if ( !_mingwthr_cs_init ) InitializeCriticalSection(&amp;_mingwthr_cs); result = 1; _mingwthr_cs_init = 1; } else { if ( reason ) { if ( reason == 3 ) { if ( _mingwthr_cs_init ) _mingwthr_run_key_dtors_part_0(); } } else { if ( _mingwthr_cs_init ) _mingwthr_run_key_dtors_part_0(); if ( _mingwthr_cs_init == 1 ) { _mingwthr_cs_init = 0; _IAT_start__(&amp;_mingwthr_cs, *&amp;reason, reserved); } } return 1; } return result; } // 402FE0: variables would overlap: edx.4 and rdx.8 // 409268: using guessed type __int64 __fastcall _IAT_start__(_QWORD, _QWORD, _QWORD); //----- (00000000004030E0) ---------------------------------------------------- void (*__cdecl get_invalid_parameter_handler())(const wchar_t *, const wchar_t *, const wchar_t *, unsigned int, uintptr_t) { return handler; } //----- (00000000004030F0) ---------------------------------------------------- void (*__fastcall set_invalid_parameter_handler( void (*new_handler)(const wchar_t *, const wchar_t *, const wchar_t *, unsigned int, uintptr_t)))(const wchar_t *, const wchar_t *, const wchar_t *, unsigned int, uintptr_t) { return _InterlockedExchange64(&amp;handler, new_handler); } // nfuncs=114 queued=48 decompiled=48 lumina nreq=0 worse=0 better=0 // ALL OK, 48 function(s) have been successfully decompiled Exploit:">
  <meta itemprop="datePublished" content="2024-09-09T06:41:05-03:00">
  <meta itemprop="dateModified" content="2024-09-09T06:41:05-03:00">
  <meta itemprop="wordCount" content="4963">
  <meta itemprop="keywords" content="Reversing,Ida">
  
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Keygen si puedes">
  <meta name="twitter:description" content="El keygen se encuentra en: https://drive.google.com/file/d/1QRIk3zBGGXH54nSZorX3jnuNmURCHw6K/view?pli=1
El c贸digo que me gener贸 el ida es:
#include &lt;windows.h&gt; #include &lt;defs.h&gt; #include &lt;stdarg.h&gt; //------------------------------------------------------------------------- // Function declarations void __fastcall _mingw_invalidParameterHandler(const wchar_t *expression, const wchar_t *function, const wchar_t *file, unsigned int line, uintptr_t pReserved); int __cdecl pre_c_init(); void __cdecl pre_cpp_init(); // int __cdecl _tmainCRTStartup(); // int __cdecl WinMainCRTStartup(); int __cdecl mainCRTStartup(); char *__fastcall generaLetras(int a1, char *a2); __int64 __fastcall generaNumero(char *a1); // idb int __fastcall generaSerial(char *a1, char *a2); int __fastcall checkSerial(char *a1, char *a2); INT_PTR __fastcall DialogProc(HWND a1, int a2, unsigned __int16 a3); int __stdcall WinMain(HINSTANCE hInst, HINSTANCE hPreInst, LPSTR lpszCmdLine, int nCmdShow); void *__fastcall decode_pointer(void *codedptr); void *__fastcall encode_pointer(void *ptr); int __cdecl setargv(); void __fastcall _mingw_raise_matherr(int typ, const char *name, double a3, double a1, double rslt); void __fastcall _mingw_setusermatherr(int (*f)(_exception *)); int __fastcall matherr(_exception *pexcept); void _report_error(const char *msg, ...); void __fastcall _write_memory_part_0(void *addr, const void *src, size_t len); void __cdecl pei386_runtime_relocator(); int __fastcall _mingw_SEH_error_handler(_EXCEPTION_RECORD *ExceptionRecord, void *EstablisherFrame, _CONTEXT *ContextRecord, void *DispatcherContext); int __cdecl _mingw_init_ehandler(); int __fastcall gnu_exception_handler(EXCEPTION_POINTERS *exception_data); void __cdecl fpreset(); void __cdecl _do_global_dtors(); void __cdecl _do_global_ctors(); void __cdecl _main(); void __cdecl _security_init_cookie(); void __fastcall _report_gsfailure(ULONG_PTR StackCookie); BOOL __fastcall _dyn_tls_dtor(HANDLE hDllHandle, DWORD dwReason, LPVOID lpreserved); BOOL __fastcall _dyn_tls_init(HANDLE hDllHandle, DWORD dwReason, LPVOID lpreserved); int __fastcall _tlregdtor(_PVFV func); _onexit_t __fastcall mingw_onexit(_onexit_t func); int __fastcall atexit(_PVFV func); int __cdecl my_lconv_init(); WINBOOL __fastcall ValidateImageBase_part_0(PBYTE pImageBase); WINBOOL __fastcall ValidateImageBase(PBYTE pImageBase); PIMAGE_SECTION_HEADER __fastcall FindPESection(PBYTE pImageBase, DWORD_PTR rva); PIMAGE_SECTION_HEADER __fastcall FindPESectionByName(const char *pName); PIMAGE_SECTION_HEADER __fastcall _mingw_GetSectionForAddress(LPVOID p); int __cdecl _mingw_GetSectionCount(); PIMAGE_SECTION_HEADER __fastcall FindPESectionExec(size_t eNo); PBYTE __cdecl GetPEImageBase(); WINBOOL __fastcall IsNonwritableInCurrentImage(PBYTE pTarget); const char *__fastcall _mingw_enum_import_library_names(int i); void __cdecl _mingwthr_run_key_dtors_part_0(); int __fastcall __w64_mingwthr_add_key_dtor(DWORD key, void (*dtor)(void *)); int __fastcall __w64_mingwthr_remove_key_dtor(DWORD key); WINBOOL __fastcall _mingw_TLScallback(HANDLE hDllHandle, DWORD reason, LPVOID reserved); // void __cdecl _set_app_type(_crt_app_type Type); // __int64 __fastcall _getmainargs(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak void (*__cdecl get_invalid_parameter_handler())(const wchar_t *, const wchar_t *, const wchar_t *, unsigned int, uintptr_t); void (*__fastcall set_invalid_parameter_handler(void (*new_handler)(const wchar_t *, const wchar_t *, const wchar_t *, unsigned int, uintptr_t)))(const wchar_t *, const wchar_t *, const wchar_t *, unsigned int, uintptr_t); // void *__cdecl malloc(size_t Size); // size_t __cdecl strlen(const char *Str); // void *__cdecl memcpy(void *, const void *Src, size_t Size); // void __cdecl cexit(); // __int64 __fastcall amsg_exit(_QWORD); weak // void __cdecl initterm(_PVFV *First, _PVFV *Last); // void __cdecl __noreturn exit(int Code); // int printf(const char *const Format, ...); // int sprintf(char *const Buffer, const char *const Format, ...); // void __cdecl _setusermatherr(_UserMathErrorFunctionPointer UserMathErrorFunction); // FILE *__cdecl _iob_func(); // int fprintf(FILE *const Stream, const char *const Format, ...); // size_t __cdecl fwrite(const void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream); // int __cdecl vfprintf(FILE *const Stream, const char *const Format, va_list ArgList); // void __cdecl __noreturn abort(); // _crt_signal_t __cdecl signal(int Signal, _crt_signal_t Function); // __int64 __fastcall lock(_QWORD); weak // __int64 __fastcall _dllonexit(_QWORD, _QWORD, _QWORD); weak // __int64 __fastcall unlock(_QWORD); weak // int __cdecl strncmp(const char *Str1, const char *Str2, size_t MaxCount); // void *__cdecl calloc(size_t Count, size_t Size); // void __cdecl free(void *Block); // int __fastcall main(int flags, char **cmdline, char **inst); idb // __int64 __fastcall _IAT_start__(_QWORD, _QWORD, _QWORD); weak // __int64 __lconv_init(void); weak //------------------------------------------------------------------------- // Data declarations func_ptr *p_73208 = (func_ptr *)0x403338LL; // idb UINT_PTR _security_cookie = 47936899621426uLL; // idb UINT_PTR _security_cookie_complement = 18446696136809930189uLL; // idb char aSfmsilqzdxajhn[53] = &#34;sfMSiLQzdXajhnZKrPyAoHbTDNREWtuVOcGIxkYemgBClvwFUpqJ&#34;; // weak const EXCEPTION_POINTERS GS_ExceptionPointers = { &amp;GS_ExceptionRecord, &amp;GS_ContextRecord }; // idb int *refptr__CRT_MT = &amp;CRT_MT; // weak int *refptr__MINGW_INSTALL_DEBUG_MATHERR = &amp;MINGW_INSTALL_DEBUG_MATHERR; // weak __int64 (*refptr___CTOR_LIST__)[2] = &amp;__CTOR_LIST__; // weak _UNKNOWN *refptr___RUNTIME_PSEUDO_RELOC_LIST_END__ = &amp;_RUNTIME_PSEUDO_RELOC_LIST_END___0; // weak _UNKNOWN *refptr___RUNTIME_PSEUDO_RELOC_LIST__ = &amp;_RUNTIME_PSEUDO_RELOC_LIST_END___0; // weak const PBYTE refptr___image_base__ = (const PBYTE)0x400000LL; // idb _UNKNOWN *refptr___imp__fmode = &amp;_fmode; // weak _UNKNOWN *refptr___imp__onexit = &amp;_onexit; // weak __int64 *refptr___onexitbegin = &amp;_onexitbegin; // weak __int64 *refptr___onexitend = &amp;_onexitend; // weak int *refptr__dowildcard = &amp;dowildcard; // weak int *refptr__fmode = &amp;fmode; // weak int *refptr__newmode = &amp;newmode; // weak int *refptr_mingw_app_type = &amp;mingw_app_type; // weak int *refptr_mingw_initcharmax = &amp;mingw_initcharmax; // weak int *refptr_mingw_initltsdrot_force = &amp;mingw_initltsdrot_force; // weak int *refptr_mingw_initltsdyn_force = &amp;mingw_initltsdyn_force; // weak int *refptr_mingw_initltssuo_force = &amp;mingw_initltssuo_force; // weak _startupinfo _bss_start__; // idb int managedapp; // idb int argret; // idb char **envp; // idb char **argv; // idb int argc; // idb fUserMathErr stUserMathErr; // idb int was_init_73980; // idb int maxSections; // idb sSecInfo *the_secs; // idb int was_here_73812; // idb UNWIND_INFO emu_xdata[32]; // idb RUNTIME_FUNCTION emu_pdata[32]; // idb int initialized; // idb CONTEXT GS_ContextRecord; // idb EXCEPTION_RECORD GS_ExceptionRecord; // idb volatile __mingwthr_key_t *key_dtor_list; // idb volatile int _mingwthr_cs_init; // idb CRITICAL_SECTION _mingwthr_cs; // idb void (*handler)(const wchar_t *, const wchar_t *, const wchar_t *, unsigned int, uintptr_t); // idb _PVFV *_onexitbegin; // idb _PVFV *_onexitend; // idb // extern void (__stdcall *EnterCriticalSection)(LPCRITICAL_SECTION lpCriticalSection); // extern HANDLE (__stdcall *GetCurrentProcess)(); // extern DWORD (__stdcall *GetCurrentProcessId)(); // extern DWORD (__stdcall *GetCurrentThreadId)(); // extern DWORD (__stdcall *GetLastError)(); // extern void (__stdcall *GetSystemTimeAsFileTime)(LPFILETIME lpSystemTimeAsFileTime); // extern DWORD (__stdcall *GetTickCount)(); // extern void (__stdcall *InitializeCriticalSection)(LPCRITICAL_SECTION lpCriticalSection); // extern void (__stdcall *LeaveCriticalSection)(LPCRITICAL_SECTION lpCriticalSection); // extern BOOL (__stdcall *QueryPerformanceCounter)(LARGE_INTEGER *lpPerformanceCount); // extern BOOLEAN (__cdecl *RtlAddFunctionTable)(PRUNTIME_FUNCTION FunctionTable, ULONG EntryCount, ULONG64 BaseAddress); // extern void (__stdcall *RtlCaptureContext)(PCONTEXT ContextRecord); // extern PRUNTIME_FUNCTION (__stdcall *RtlLookupFunctionEntry)(ULONG64 ControlPc, PULONG64 ImageBase, PUNWIND_HISTORY_TABLE HistoryTable); // extern PEXCEPTION_ROUTINE (__stdcall *RtlVirtualUnwind)(ULONG HandlerType, ULONG64 ImageBase, ULONG64 ControlPc, PRUNTIME_FUNCTION FunctionEntry, PCONTEXT ContextRecord, PVOID *HandlerData, PULONG64 EstablisherFrame, PKNONVOLATILE_CONTEXT_POINTERS ContextPointers); // extern LPTOP_LEVEL_EXCEPTION_FILTER (__stdcall *SetUnhandledExceptionFilter)(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter); // extern BOOL (__stdcall *TerminateProcess)(HANDLE hProcess, UINT uExitCode); // extern LPVOID (__stdcall *TlsGetValue)(DWORD dwTlsIndex); // extern LONG (__stdcall *UnhandledExceptionFilter)(struct _EXCEPTION_POINTERS *ExceptionInfo); // extern BOOL (__stdcall *VirtualProtect)(LPVOID lpAddress, SIZE_T dwSize, DWORD flNewProtect, PDWORD lpflOldProtect); // extern SIZE_T (__stdcall *VirtualQuery)(LPCVOID lpAddress, PMEMORY_BASIC_INFORMATION lpBuffer, SIZE_T dwLength); // extern HWND (__stdcall *CreateDialogParamA)(HINSTANCE hInstance, LPCSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam); // extern LRESULT (__stdcall *DispatchMessageA)(const MSG *lpMsg); // extern BOOL (__stdcall *EndDialog)(HWND hDlg, INT_PTR nResult); // extern UINT (__stdcall *GetDlgItemTextA)(HWND hDlg, int nIDDlgItem, LPSTR lpString, int cchMax); // extern BOOL (__stdcall *GetMessageA)(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax); // extern BOOL (__stdcall *IsDialogMessageA)(HWND hDlg, LPMSG lpMsg); // extern HMENU (__stdcall *LoadMenuA)(HINSTANCE hInstance, LPCSTR lpMenuName); // extern int (__stdcall *MessageBoxA)(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType); // extern BOOL (__stdcall *SetMenu)(HWND hWnd, HMENU hMenu); // extern BOOL (__stdcall *ShowWindow)(HWND hWnd, int nCmdShow); // extern BOOL (__stdcall *TranslateMessage)(const MSG *lpMsg); //----- (0000000000401010) ---------------------------------------------------- int __cdecl pre_c_init() { _BOOL8 v0; // rdx void *v1; // rax BYTE *v3; // rax __int16 v4; // cx LODWORD(v0) = 0; *refptr_mingw_initltsdrot_force = 1; *refptr_mingw_initltsdyn_force = 1; *refptr_mingw_initltssuo_force = 1; *refptr_mingw_initcharmax = 1; if ( *refptr___image_base__ == 23117 ) { v3 = &amp;refptr___image_base__[*(refptr___image_base__ &#43; 15)]; if ( *v3 == 17744 ) { v4 = *(v3 &#43; 12); if ( v4 == 267 ) { if ( *(v3 &#43; 29) &gt; 0xEu ) v0 = *(v3 &#43; 58) != 0; } else if ( v4 == 523 &amp;&amp; *(v3 &#43; 33) &gt; 0xEu ) { v0 = *(v3 &#43; 62) != 0; } } } managedapp = v0; if ( *refptr_mingw_app_type ) _set_app_type(_crt_gui_app); else _set_app_type(_crt_console_app); v1 = encode_pointer(0xFFFFFFFFFFFFFFFFLL); *refptr___onexitend = v1; *refptr___onexitbegin = v1; **refptr___imp__fmode = *refptr__fmode; setargv(); if ( *refptr__MINGW_INSTALL_DEBUG_MATHERR == 1 ) _mingw_setusermatherr(matherr); return 0; } // 405370: using guessed type int *refptr__MINGW_INSTALL_DEBUG_MATHERR; // 4053F0: using guessed type _UNKNOWN *refptr___imp__fmode; // 405470: using guessed type __int64 *refptr___onexitbegin; // 405480: using guessed type __int64 *refptr___onexitend; // 4054E0: using guessed type int *refptr__fmode; // 405520: using guessed type int *refptr_mingw_app_type; // 405530: using guessed type int *refptr_mingw_initcharmax; // 405540: using guessed type int *refptr_mingw_initltsdrot_force; // 405550: using guessed type int *refptr_mingw_initltsdyn_force; // 405560: using guessed type int *refptr_mingw_initltssuo_force; //----- (0000000000401160) ---------------------------------------------------- void __cdecl pre_cpp_init() { _bss_start__.newmode = *refptr__newmode; argret = _getmainargs(&amp;argc, &amp;argv, &amp;envp, *refptr__dowildcard, &amp;_bss_start__); } // 4030D0: using guessed type __int64 __fastcall _getmainargs(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); // 4054D0: using guessed type int *refptr__dowildcard; // 405510: using guessed type int *refptr__newmode; //----- (0000000000401500) ---------------------------------------------------- int __cdecl mainCRTStartup() { *refptr_mingw_app_type = 0; _security_init_cookie(); return _tmainCRTStartup(); } // 405520: using guessed type int *refptr_mingw_app_type; //----- (0000000000401530) ---------------------------------------------------- char *__fastcall generaLetras(int a1, char *a2) { size_t v2; // rax char *result; // rax int v4; // [rsp&#43;28h] [rbp-58h] int v5; // [rsp&#43;2Ch] [rbp-54h] int v6; // [rsp&#43;30h] [rbp-50h] int v7; // [rsp&#43;34h] [rbp-4Ch] v7 = (a1 &#43; 15) % strlen(&#34;sfMSiLQzdXajhnZKrPyAoHbTDNREWtuVOcGIxkYemgBClvwFUpqJ&#34;); v6 = (a1 &#43; 22) % strlen(&#34;sfMSiLQzdXajhnZKrPyAoHbTDNREWtuVOcGIxkYemgBClvwFUpqJ&#34;); v5 = (a1 &#43; 32) % strlen(&#34;sfMSiLQzdXajhnZKrPyAoHbTDNREWtuVOcGIxkYemgBClvwFUpqJ&#34;); v4 = (a1 &#43; 17) % strlen(&#34;sfMSiLQzdXajhnZKrPyAoHbTDNREWtuVOcGIxkYemgBClvwFUpqJ&#34;); v2 = strlen(&#34;sfMSiLQzdXajhnZKrPyAoHbTDNREWtuVOcGIxkYemgBClvwFUpqJ&#34;); *a2 = aSfmsilqzdxajhn[v7]; a2[1] = aSfmsilqzdxajhn[v6]; a2[2] = aSfmsilqzdxajhn[v5]; a2[3] = aSfmsilqzdxajhn[v4]; a2[4] = aSfmsilqzdxajhn[((a1 &#43; 4) % v2)]; result = a2 &#43; 5; a2[5] = 0; return result; } //----- (00000000004016AD) ---------------------------------------------------- __int64 __fastcall generaNumero(char *a1) { int i; // [rsp&#43;28h] [rbp-58h] int v3; // [rsp&#43;2Ch] [rbp-54h] v3 = 0; for ( i = 0; i &lt; strlen(a1); &#43;&#43;i ) v3 &#43;= a1[i]; printf(&#34;Numero: %d&#34;, v3 &#43; 6572); return (v3 &#43; 6572); } //----- (0000000000401746) ---------------------------------------------------- int __fastcall generaSerial(char *a1, char *a2) { char v3[16]; // [rsp&#43;40h] [rbp-50h] BYREF char v4[16]; // [rsp&#43;50h] [rbp-40h] BYREF char v5[16]; // [rsp&#43;60h] [rbp-30h] BYREF char v6[16]; // [rsp&#43;70h] [rbp-20h] BYREF char v7[12]; // [rsp&#43;80h] [rbp-10h] BYREF int v8; // [rsp&#43;8Ch] [rbp-4h] v8 = generaNumero(a1); generaLetras(v8, v7); v8 = generaNumero(v7); generaLetras(v8, v6); v8 = generaNumero(v6); generaLetras(v8, v5); v8 = generaNumero(v5); generaLetras(v8, v4); v8 = generaNumero(v4); generaLetras(v8, v3); return sprintf(a2, &#34;%s-%s-%s-%s-%s&#34;, v7, v6, v5, v4, v3); } //----- (000000000040182D) ---------------------------------------------------- int __fastcall checkSerial(char *a1, char *a2) { size_t v2; // rbx size_t v3; // rax int i; // [rsp&#43;28h] [rbp-58h] char v6; // [rsp&#43;2Fh] [rbp-51h] v6 = 1; v2 = strlen(a1); if ( v2 == strlen(a2) ) { for ( i = 0; ; &#43;&#43;i ) { v3 = strlen(a2); if ( i &gt;= v3 ) break; if ( a1[i] != a2[i] ) { LODWORD(v3) = MessageBoxA(0LL, &#34;Nope sigue intentando&#34;, &#34;Nop&#34;, 0x30u); v6 = 0; break; } } if ( v6 ) LODWORD(v3) = MessageBoxA(0LL, &#34;Genial lo lograste&#34;, &#34;Felicitaciones&#34;, 0); } else { MessageBoxA(0LL, &#34;Nope sigue intentando&#34;, &#34;Nop&#34;, 0x30u); LODWORD(v3) = 0; } return v3; } //----- (000000000040192F) ---------------------------------------------------- INT_PTR __fastcall DialogProc(HWND a1, int a2, unsigned __int16 a3) { char v4[32]; // [rsp&#43;20h] [rbp-60h] BYREF CHAR v5[32]; // [rsp&#43;40h] [rbp-40h] BYREF CHAR String[28]; // [rsp&#43;60h] [rbp-20h] BYREF UINT DlgItemTextA; // [rsp&#43;7Ch] [rbp-4h] DlgItemTextA = 0; switch ( a2 ) { case 272: return 1LL; case 273: if ( a3 == 40000 ) { DlgItemTextA = GetDlgItemTextA(a1, 40002, String, 20); if ( DlgItemTextA ) { DlgItemTextA = GetDlgItemTextA(a1, 40003, v5, 30); if ( DlgItemTextA ) { generaSerial(String, v4); checkSerial(v5, v4); return 1LL; } MessageBoxA(a1, &#34;Nope sigue intentando&#34;, &#34;Nop&#34;, 0x30u); } else { MessageBoxA(a1, &#34;Nope sigue intentando&#34;, &#34;Nop&#34;, 0x30u); } } else if ( a3 == 40006 ) { MessageBoxA(a1, &#34;keygeneame si puedes\n\nEl objetivo es crear el keygen sin parchear nada&#34;, &#34;About&#34;, 0x40u); return 1LL; } return 1LL; case 16: EndDialog(a1, 0LL); return 1LL; default: return 0LL; } } //----- (0000000000401AA6) ---------------------------------------------------- int __stdcall WinMain(HINSTANCE hInst, HINSTANCE hPreInst, LPSTR lpszCmdLine, int nCmdShow) { tagMSG Msg; // [rsp&#43;30h] [rbp-40h] BYREF HMENU hMenu; // [rsp&#43;60h] [rbp-10h] HWND hWnd; // [rsp&#43;68h] [rbp-8h] hWnd = CreateDialogParamA(hInst, 102, 0LL, DialogProc, 0LL); hMenu = LoadMenuA(hInst, 0x69); SetMenu(hWnd, hMenu); ShowWindow(hWnd, 10); while ( GetMessageA(&amp;Msg, 0LL, 0, 0) &gt; 0 ) { if ( !IsDialogMessageA(hWnd, &amp;Msg) ) { TranslateMessage(&amp;Msg); DispatchMessageA(&amp;Msg); } } return 0; } //----- (0000000000401BA0) ---------------------------------------------------- void *__fastcall decode_pointer(void *codedptr) { return codedptr; } //----- (0000000000401BB0) ---------------------------------------------------- void *__fastcall encode_pointer(void *ptr) { return ptr; } //----- (0000000000401BC0) ---------------------------------------------------- int __cdecl setargv() { return 0; } //----- (0000000000401BD0) ---------------------------------------------------- void __fastcall _mingw_raise_matherr(int typ, const char *name, double a3, double a1, double rslt) { _exception ex; // [rsp&#43;20h] [rbp-38h] BYREF if ( stUserMathErr ) { ex.type = typ; ex.name = name; ex.arg1 = a3; ex.arg2 = a1; ex.retval = rslt; stUserMathErr(&amp;ex); } } //----- (0000000000401C20) ---------------------------------------------------- void __fastcall _mingw_setusermatherr(int (*f)(_exception *)) { stUserMathErr = f; _setusermatherr(f); } //----- (0000000000401C30) ---------------------------------------------------- int __fastcall matherr(_exception *pexcept) { const char *v1; // rbx double retval; // xmm8_8 const char *name; // rsi double arg2; // xmm7_8 double arg1; // xmm6_8 FILE *v6; // rax switch ( pexcept-&gt;type ) { case 1: v1 = &#34;Argument domain error (DOMAIN)&#34;; break; case 2: v1 = &#34;Argument singularity (SIGN)&#34;; break; case 3: v1 = &#34;Overflow range error (OVERFLOW)&#34;; break; case 4: v1 = &#34;The result is too small to be represented (UNDERFLOW)&#34;; break; case 5: v1 = &#34;Total loss of significance (TLOSS)&#34;; break; case 6: v1 = &#34;Partial loss of significance (PLOSS)&#34;; break; default: v1 = &#34;Unknown error&#34;; break; } retval = pexcept-&gt;retval; name = pexcept-&gt;name; arg2 = pexcept-&gt;arg2; arg1 = pexcept-&gt;arg1; v6 = _iob_func(); fprintf(v6 &#43; 2, &#34;_matherr(): %s in %s(%g, %g) (retval=%g)\n&#34;, v1, name, arg1, arg2, retval); return 0; } //----- (0000000000401D30) ---------------------------------------------------- void __noreturn _report_error(const char *msg, ...) { FILE *v2; // rax FILE *v3; // rax va_list va; // [rsp&#43;58h] [rbp&#43;10h] BYREF va_start(va, msg); v2 = _iob_func(); fwrite(&#34;Mingw-w64 runtime failure:\n&#34;, 1uLL, 0x1BuLL, v2 &#43; 2); v3 = _iob_func(); vfprintf(v3 &#43; 2, msg, va); abort(); } //----- (0000000000401DA0) ---------------------------------------------------- void __fastcall _write_memory_part_0(void *addr, const void *src, size_t len) { __int64 v3; // rbp int v7; // r9d PBYTE *p_sec_start; // rax PIMAGE_SECTION_HEADER SectionForAddress; // rax PIMAGE_SECTION_HEADER v10; // r12 __int64 v11; // rbp sSecInfo *v12; // r13 DWORD LastError; // eax struct _MEMORY_BASIC_INFORMATION Buffer; // [rsp&#43;20h] [rbp-68h] BYREF v3 = maxSections; if ( maxSections &lt;= 0 ) { v3 = 0LL; LABEL_6: SectionForAddress = _mingw_GetSectionForAddress(addr); v10 = SectionForAddress; if ( !SectionForAddress ) _report_error(&#34;Address %p has no image-section&#34;, addr); v11 = v3; v12 = &amp;the_secs[v11]; v12-&gt;hash = SectionForAddress; v12-&gt;old_protect = 0; v12-&gt;sec_start = &amp;GetPEImageBase()[SectionForAddress-&gt;VirtualAddress]; if ( !VirtualQuery(the_secs[v11].sec_start, &amp;Buffer, 0x30uLL) ) _report_error( &#34; VirtualQuery failed for %d bytes at address %p&#34;, v10-&gt;Misc.PhysicalAddress, the_secs[v11].sec_start); if ( ((Buffer.Protect - 4) &amp; 0xFFFFFFFB) != 0 &amp;&amp; ((Buffer.Protect - 64) &amp; 0xFFFFFFBF) != 0 &amp;&amp; !VirtualProtect(Buffer.BaseAddress, Buffer.RegionSize, 0x40u, &amp;the_secs[v11].old_protect) ) { LastError = GetLastError(); _report_error(&#34; VirtualProtect failed with code 0x%x&#34;, LastError); } &#43;&#43;maxSections; } else { v7 = 0; p_sec_start = &amp;the_secs-&gt;sec_start; while ( addr &lt; *p_sec_start || addr &gt;= &amp;(*p_sec_start)[*(p_sec_start[1] &#43; 2)] ) { &#43;&#43;v7; p_sec_start &#43;= 3; if ( v7 == maxSections ) goto LABEL_6; } } memcpy(addr, src, len); } //----- (0000000000401F10) ---------------------------------------------------- void __cdecl pei386_runtime_relocator() { unsigned __int64 v0; // rax void *v1; // rsp _DWORD *v2; // rbx void *v3; // rsp int v4; // edx unsigned int *v5; // rbx unsigned int v6; // edx BYTE *v7; // rax BYTE *v8; // rcx __int64 v9; // r8 __int64 v10; // rbx int i; // esi __int64 v12; // rcx int v13; // eax BYTE *v14; // rcx unsigned __int64 v15; // rdx unsigned __int64 v16; // rdx unsigned __int64 v17; // rdx char v18; // [rsp&#43;20h] [rbp-40h] BYREF DWORD flOldProtect; // [rsp&#43;2Ch] [rbp-34h] BYREF struct _MEMORY_BASIC_INFORMATION src; // [rsp&#43;30h] [rbp-30h] BYREF if ( was_init_73980 ) return; was_init_73980 = 1; v0 = (24LL * _mingw_GetSectionCount() &#43; 30) &amp; 0xFFFFFFFFFFFFFFF0uLL; v1 = alloca(v0); v2 = refptr___RUNTIME_PSEUDO_RELOC_LIST__; v3 = alloca(v0); maxSections = 0; the_secs = &amp;v18; if ( refptr___RUNTIME_PSEUDO_RELOC_LIST_END__ - refptr___RUNTIME_PSEUDO_RELOC_LIST__ &lt;= 7 ) return; if ( refptr___RUNTIME_PSEUDO_RELOC_LIST_END__ - refptr___RUNTIME_PSEUDO_RELOC_LIST__ &gt; 11 ) { if ( *refptr___RUNTIME_PSEUDO_RELOC_LIST__ || *(refptr___RUNTIME_PSEUDO_RELOC_LIST__ &#43; 1) ) goto LABEL_25; if ( *(refptr___RUNTIME_PSEUDO_RELOC_LIST__ &#43; 2) ) goto LABEL_11; v2 = (refptr___RUNTIME_PSEUDO_RELOC_LIST__ &#43; 12); } if ( *v2 || v2[1] ) { LABEL_25: if ( v2 &gt;= refptr___RUNTIME_PSEUDO_RELOC_LIST_END__ ) return; do { v12 = v2[1]; v13 = *v2; v2 &#43;= 2; v14 = &amp;refptr___image_base__[v12]; LODWORD(src.BaseAddress) = *v14 &#43; v13; _write_memory_part_0(v14, &amp;src, 4uLL); } while ( v2 &lt; refptr___RUNTIME_PSEUDO_RELOC_LIST_END__ ); goto LABEL_19; } LABEL_11: v4 = v2[2]; if ( v4 != 1 ) _report_error(&#34; Unknown pseudo relocation protocol version %d.\n&#34;, v4); v5 = v2 &#43; 3; if ( v5 &lt; refptr___RUNTIME_PSEUDO_RELOC_LIST_END__ ) { do { v6 = *(v5 &#43; 8); v7 = &amp;refptr___image_base__[*v5]; v8 = &amp;refptr___image_base__[v5[1]]; v9 = *v7; if ( v6 == 16 ) { v16 = *v8; if ( (v16 &amp; 0x8000u) != 0LL ) v16 = *v8 | 0xFFFFFFFFFFFF0000uLL; src.BaseAddress = (v9 &#43; v16 - v7); _write_memory_part_0(v8, &amp;src, 2uLL); } else if ( v6 &lt;= 0x10 ) { if ( v6 != 8 ) { LABEL_35: src.BaseAddress = 0LL; _report_error(&#34; Unknown pseudo relocation bit size %d.\n&#34;, v6); } v15 = *v8; if ( (v15 &amp; 0x80u) != 0LL ) v15 = *v8 | 0xFFFFFFFFFFFFFF00uLL; src.BaseAddress = (v9 &#43; v15 - v7); _write_memory_part_0(v8, &amp;src, 1uLL); } else if ( v6 == 32 ) { v17 = *v8; if ( (v17 &amp; 0x80000000) != 0LL ) v17 = *v8 | 0xFFFFFFFF00000000uLL; src.BaseAddress = (v9 &#43; v17 - v7); _write_memory_part_0(v8, &amp;src, 4uLL); } else { if ( v6 != 64 ) goto LABEL_35; src.BaseAddress = (*v8 &#43; v9 - v7); _write_memory_part_0(v8, &amp;src, 8uLL); } v5 &#43;= 3; } while ( v5 &lt; refptr___RUNTIME_PSEUDO_RELOC_LIST_END__ ); LABEL_19: v10 = 0LL; for ( i = 0; i &lt; maxSections; &#43;&#43;v10 ) { if ( the_secs[v10].old_protect ) { if ( !VirtualQuery(the_secs[v10].sec_start, &amp;src, 0x30uLL) ) _report_error( &#34; VirtualQuery failed for %d bytes at address %p&#34;, the_secs[v10].hash-&gt;Misc.PhysicalAddress, the_secs[v10].sec_start); VirtualProtect(src.BaseAddress, src.RegionSize, the_secs[v10].old_protect, &amp;flOldProtect); } &#43;&#43;i; } } } // 405390: using guessed type _UNKNOWN *refptr___RUNTIME_PSEUDO_RELOC_LIST_END__; // 4053A0: using guessed type _UNKNOWN *refptr___RUNTIME_PSEUDO_RELOC_LIST__; //----- (0000000000402210) ---------------------------------------------------- int __fastcall _mingw_SEH_error_handler( _EXCEPTION_RECORD *ExceptionRecord, void *EstablisherFrame, _CONTEXT *ContextRecord, void *DispatcherContext) { DWORD ExceptionCode; // eax _crt_signal_t v5; // rax int result; // eax _crt_signal_t v7; // rdx _crt_signal_t v8; // rax ExceptionCode = ExceptionRecord-&gt;ExceptionCode; if ( ExceptionRecord-&gt;ExceptionCode &gt; 0xC0000091 ) { if ( ExceptionCode == -1073741676 ) { v7 = signal(8, 0LL); if ( v7 == 1 ) { signal(8, 1); return 0; } goto LABEL_16; } if ( ExceptionCode &gt; 0xC0000094 ) { if ( ExceptionCode == -1073741675 ) return 0; if ( ExceptionCode != -1073741674 ) return 1; goto LABEL_20; } if ( ExceptionCode == -1073741678 ) return 0; if ( ExceptionCode != -1073741677 ) return 1; } else if ( ExceptionCode &lt; 0xC000008D ) { if ( ExceptionCode == -1073741816 ) return 0; if ( ExceptionCode &lt;= 0xC0000008 ) { if ( ExceptionCode != -2147483646 ) { if ( ExceptionCode == -1073741819 ) { v5 = signal(11, 0LL); if ( v5 == 1 ) { signal(11, 1); return 0; } if ( v5 ) { (v5)(11LL); return 0; } return 4; } return 1; } return 0; } if ( ExceptionCode != -1073741795 ) return ExceptionCode != -1073741684; LABEL_20: v8 = signal(4, 0LL); if ( v8 == 1 ) { signal(4, 1); return 0; } if ( v8 ) { (v8)(4LL); return 0; } return 4; } v7 = signal(8, 0LL); if ( v7 == 1 ) { signal(8, 1); fpreset(); return 0; } LABEL_16: result = 1; if ( v7 ) { (v7)(8LL); return 0; } return result; } //----- (00000000004023C0) ---------------------------------------------------- int __cdecl _mingw_init_ehandler() { PBYTE PEImageBase; // rbp int result; // eax RUNTIME_FUNCTION *v2; // rbx size_t v3; // rsi UNWIND_INFO *v4; // rdi DWORD VirtualAddress; // edx DWORD v6; // edx DWORD v7; // eax PIMAGE_SECTION_HEADER PESectionExec; // rax ULONG v9; // edx PEImageBase = GetPEImageBase(); result = was_here_73812; if ( !was_here_73812 &amp;&amp; PEImageBase ) { was_here_73812 = 1; if ( !FindPESectionByName(&#34;.pdata&#34;) ) { v2 = emu_pdata; v3 = 0LL; memset(emu_pdata, 0, sizeof(emu_pdata)); memset(emu_xdata, 0, sizeof(emu_xdata)); v4 = emu_xdata; while ( 1 ) { PESectionExec = FindPESectionExec(v3); if ( !PESectionExec ) break; v4-&gt;VersionAndFlags = 9; v4-&gt;AddressOfExceptionHandler = _mingw_SEH_error_handler - PEImageBase; &#43;&#43;v3; VirtualAddress = PESectionExec-&gt;VirtualAddress; &#43;&#43;v2; v2[-1].BeginAddress = VirtualAddress; v6 = PESectionExec-&gt;Misc.PhysicalAddress &#43; VirtualAddress; v7 = v4&#43;&#43; - PEImageBase; v2[-1].UnwindData = v7; v2[-1].EndAddress = v6; if ( v3 == 32 ) { v9 = 32; goto LABEL_11; } } if ( !v3 ) return 1; v9 = v3; LABEL_11: RtlAddFunctionTable(emu_pdata, v9, PEImageBase); } return 1; } return result; } //----- (0000000000402670) ---------------------------------------------------- void __cdecl fpreset() { __asm { fninit } } //----- (0000000000402680) ---------------------------------------------------- void __cdecl _do_global_dtors() { void (*i)(void); // rax for ( i = *p_73208; i; &#43;&#43;p_73208 ) { i(); i = p_73208[1]; } } //----- (00000000004026C0) ---------------------------------------------------- void __cdecl _do_global_ctors() { int i; // ebx i = (*refptr___CTOR_LIST__)[0]; if ( i == -1 ) { for ( i = 0; (*refptr___CTOR_LIST__)[i &#43; 1]; &#43;&#43;i ) ; } for ( ; i; --i ) ((*refptr___CTOR_LIST__)[i])(); atexit(_do_global_dtors); } // 405380: using guessed type __int64 (*refptr___CTOR_LIST__)[2]; //----- (0000000000402720) ---------------------------------------------------- void __cdecl _main() { if ( !initialized ) { initialized = 1; _do_global_ctors(); } } //----- (0000000000402740) ---------------------------------------------------- void __cdecl _security_init_cookie() { FT v0; // r12 __int64 CurrentProcessId; // rbp DWORD CurrentThreadId; // edi DWORD TickCount; // esi LONGLONG v4; // rsi UINT_PTR v5; // rax FT systime; // [rsp&#43;20h] [rbp-48h] BYREF LARGE_INTEGER perfctr; // [rsp&#43;30h] [rbp-38h] BYREF systime.ft_scalar = 0LL; if ( _security_cookie == 0x2B992DDFA232LL ) { GetSystemTimeAsFileTime(&amp;systime); v0.ft_scalar = systime.ft_scalar; CurrentProcessId = GetCurrentProcessId(); CurrentThreadId = GetCurrentThreadId(); TickCount = GetTickCount(); QueryPerformanceCounter(&amp;perfctr); v4 = (TickCount ^ CurrentThreadId ^ perfctr.QuadPart ^ v0.ft_scalar ^ CurrentProcessId) &amp; 0xFFFFFFFFFFFFLL; if ( v4 == 0x2B992DDFA232LL ) { v5 = 0xFFFFD466D2205DCCuLL; v4 = 0x2B992DDFA233LL; } else { v5 = ~v4; } _security_cookie = v4; _security_cookie_complement = v5; } else { _security_cookie_complement = ~_security_cookie; } } //----- (0000000000402820) ---------------------------------------------------- void __fastcall __noreturn _report_gsfailure(ULONG_PTR StackCookie) { ULONG64 Rip; // rbx _RUNTIME_FUNCTION *v3; // r9 HANDLE CurrentProcess; // rax ULONG64 imgBase; // [rsp&#43;48h] [rbp-28h] BYREF ULONG64 establisherFrame; // [rsp&#43;50h] [rbp-20h] BYREF PVOID hndData; // [rsp&#43;58h] [rbp-18h] BYREF UINT_PTR cookie[2]; // [rsp&#43;60h] [rbp-10h] char vars8; // [rsp&#43;78h] [rbp&#43;8h] BYREF DWORD64 retaddr; // [rsp&#43;88h] [rbp&#43;18h] RtlCaptureContext(&amp;GS_ContextRecord); Rip = GS_ContextRecord.Rip; v3 = RtlLookupFunctionEntry(GS_ContextRecord.Rip, &amp;imgBase, 0LL); if ( v3 ) { RtlVirtualUnwind(0, imgBase, Rip, v3, &amp;GS_ContextRecord, &amp;hndData, &amp;establisherFrame, 0LL); } else { GS_ContextRecord.Rip = retaddr; GS_ContextRecord.Rsp = &amp;vars8; } GS_ContextRecord.Rcx = StackCookie; GS_ExceptionRecord.ExceptionCode = -1073740791; GS_ExceptionRecord.ExceptionFlags = 1; GS_ExceptionRecord.ExceptionAddress = GS_ContextRecord.Rip; cookie[1] = _security_cookie_complement; SetUnhandledExceptionFilter(0LL); UnhandledExceptionFilter(&amp;GS_ExceptionPointers); CurrentProcess = GetCurrentProcess(); TerminateProcess(CurrentProcess, 0xC0000409); abort(); } //----- (0000000000402920) ---------------------------------------------------- BOOL __fastcall _dyn_tls_dtor(HANDLE hDllHandle, DWORD dwReason, LPVOID lpreserved) { if ( dwReason &amp;&amp; dwReason != 3 ) return 1; _mingw_TLScallback(hDllHandle, dwReason, lpreserved); return 1; } //----- (0000000000402950) ---------------------------------------------------- BOOL __fastcall _dyn_tls_init(HANDLE hDllHandle, DWORD dwReason, LPVOID lpreserved) { if ( *refptr__CRT_MT != 2 ) *refptr__CRT_MT = 2; if ( dwReason == 1 ) _mingw_TLScallback(hDllHandle, 1u, lpreserved); return 1; } // 405360: using guessed type int *refptr__CRT_MT; //----- (00000000004029C0) ---------------------------------------------------- int __fastcall _tlregdtor(_PVFV func) { return 0; } //----- (00000000004029D0) ---------------------------------------------------- _onexit_t __fastcall mingw_onexit(_onexit_t func) { int (*v2)(void); // rbx _PVFV *onexitbegin; // [rsp&#43;20h] [rbp-18h] BYREF _PVFV *onexitend; // [rsp&#43;28h] [rbp-10h] BYREF onexitbegin = decode_pointer(_onexitbegin); if ( onexitbegin == -1LL ) return (*refptr___imp__onexit)(func); lock(8LL); onexitbegin = decode_pointer(_onexitbegin); onexitend = decode_pointer(_onexitend); v2 = _dllonexit(func, &amp;onexitbegin, &amp;onexitend); _onexitbegin = encode_pointer(onexitbegin); _onexitend = encode_pointer(onexitend); unlock(8LL); return v2; } // 403180: using guessed type __int64 __fastcall lock(_QWORD); // 403188: using guessed type __int64 __fastcall _dllonexit(_QWORD, _QWORD, _QWORD); // 403190: using guessed type __int64 __fastcall unlock(_QWORD); // 405400: using guessed type _UNKNOWN *refptr___imp__onexit; //----- (0000000000402A80) ---------------------------------------------------- int __fastcall atexit(_PVFV func) { return -(mingw_onexit(func) == 0LL); } //----- (0000000000402AA0) ---------------------------------------------------- int __cdecl my_lconv_init() { return __lconv_init(); } // 409350: using guessed type __int64 __lconv_init(void); //----- (0000000000402AB0) ---------------------------------------------------- WINBOOL __fastcall ValidateImageBase_part_0(PBYTE pImageBase) { BYTE *v1; // rcx WINBOOL result; // eax v1 = &amp;pImageBase[*(pImageBase &#43; 15)]; result = 0; if ( *v1 == 17744 ) return *(v1 &#43; 12) == 523; return result; } //----- (0000000000402AD0) ---------------------------------------------------- WINBOOL __fastcall ValidateImageBase(PBYTE pImageBase) { if ( *pImageBase == 23117 ) return ValidateImageBase_part_0(pImageBase); else return 0; } //----- (0000000000402AF0) ---------------------------------------------------- PIMAGE_SECTION_HEADER __fastcall FindPESection(PBYTE pImageBase, DWORD_PTR rva) { BYTE *v2; // rcx PIMAGE_SECTION_HEADER result; // rax int v4; // ecx _IMAGE_SECTION_HEADER *v5; // r9 v2 = &amp;pImageBase[*(pImageBase &#43; 15)]; result = &amp;v2[*(v2 &#43; 10) &#43; 24]; v4 = *(v2 &#43; 3); if ( !v4 ) return 0LL; v5 = &amp;result[(v4 - 1) &#43; 1]; while ( result-&gt;VirtualAddress &gt; rva || rva &gt;= result-&gt;Misc.PhysicalAddress &#43; result-&gt;VirtualAddress ) { if ( &#43;&#43;result == v5 ) return 0LL; } return result; } //----- (0000000000402B40) ---------------------------------------------------- PIMAGE_SECTION_HEADER __fastcall FindPESectionByName(const char *pName) { BYTE *v3; // rdx _IMAGE_SECTION_HEADER *v4; // rbx int v5; // edx __int64 v6; // rdi if ( strlen(pName) &gt; 8 ) return 0LL; if ( *refptr___image_base__ != 23117 ) return 0LL; if ( !ValidateImageBase_part_0(refptr___image_base__) ) return 0LL; v3 = &amp;refptr___image_base__[*(refptr___image_base__ &#43; 15)]; v4 = &amp;v3[*(v3 &#43; 10) &#43; 24]; v5 = *(v3 &#43; 3); if ( !v5 ) return 0LL; v6 = &amp;v4[(v5 - 1) &#43; 1]; while ( strncmp(v4, pName, 8uLL) ) { if ( &#43;&#43;v4 == v6 ) return 0LL; } return v4; } //----- (0000000000402BE0) ---------------------------------------------------- PIMAGE_SECTION_HEADER __fastcall _mingw_GetSectionForAddress(LPVOID p) { if ( *refptr___image_base__ == 23117 &amp;&amp; ValidateImageBase_part_0(refptr___image_base__) ) return FindPESection(refptr___image_base__, p - refptr___image_base__); else return 0LL; } //----- (0000000000402C30) ---------------------------------------------------- int __cdecl _mingw_GetSectionCount() { int result; // eax result = 0; if ( *refptr___image_base__ == 23117 ) { result = ValidateImageBase_part_0(refptr___image_base__); if ( result ) return *&amp;refptr___image_base__[*(refptr___image_base__ &#43; 15) &#43; 6]; } return result; } //----- (0000000000402C70) ---------------------------------------------------- PIMAGE_SECTION_HEADER __fastcall FindPESectionExec(size_t eNo) { BYTE *v3; // rsi __int64 v4; // rdx __int64 v5; // rax if ( *refptr___image_base__ != 23117 ) return 0LL; if ( !ValidateImageBase_part_0(refptr___image_base__) ) return 0LL; v3 = &amp;refptr___image_base__[*(refptr___image_base__ &#43; 15)]; v4 = &amp;v3[*(v3 &#43; 10) &#43; 24]; if ( !*(v3 &#43; 3) ) return 0LL; v5 = v4 &#43; 40LL * (*(v3 &#43; 3) - 1) &#43; 40; while ( (*(v4 &#43; 39) &amp; 0x20) == 0 ) { LABEL_9: v4 &#43;= 40LL; if ( v4 == v5 ) return 0LL; } if ( eNo ) { --eNo; goto LABEL_9; } return v4; } //----- (0000000000402D00) ---------------------------------------------------- PBYTE __cdecl GetPEImageBase() { BYTE *v0; // rbx v0 = 0LL; if ( *refptr___image_base__ != 23117 ) return 0LL; if ( ValidateImageBase_part_0(refptr___image_base__) ) return refptr___image_base__; return v0; } //----- (0000000000402D40) ---------------------------------------------------- WINBOOL __fastcall IsNonwritableInCurrentImage(PBYTE pTarget) { WINBOOL result; // eax PIMAGE_SECTION_HEADER PESection; // rax result = 0; if ( *refptr___image_base__ == 23117 ) { result = ValidateImageBase_part_0(refptr___image_base__); if ( result ) { PESection = FindPESection(refptr___image_base__, pTarget - refptr___image_base__); return PESection &amp;&amp; (PESection-&gt;Characteristics &amp; 0x80000000) == 0; } } return result; } //----- (0000000000402DA0) ---------------------------------------------------- const char *__fastcall _mingw_enum_import_library_names(int i) { unsigned int v3; // edx __int64 v4; // rbx BYTE *v5; // rdx if ( *refptr___image_base__ != 23117 ) return 0LL; if ( !ValidateImageBase_part_0(refptr___image_base__) ) return 0LL; v3 = *&amp;refptr___image_base__[*(refptr___image_base__ &#43; 15) &#43; 144]; if ( !v3 ) return 0LL; v4 = v3; if ( !FindPESection(refptr___image_base__, v3) ) return 0LL; v5 = &amp;refptr___image_base__[v4]; if ( !&amp;refptr___image_base__[v4] ) return 0LL; while ( *(v5 &#43; 1) || *(v5 &#43; 3) ) { if ( i &lt;= 0 ) return &amp;refptr___image_base__[*(v5 &#43; 3)]; --i; v5 &#43;= 20; } return 0LL; } //----- (0000000000402E50) ---------------------------------------------------- void __cdecl _mingwthr_run_key_dtors_part_0() { volatile __mingwthr_key_t *i; // rbx LPVOID Value; // rsi EnterCriticalSection(&amp;_mingwthr_cs); for ( i = key_dtor_list; i; i = i-&gt;next ) { Value = TlsGetValue(i-&gt;key); if ( !GetLastError() &amp;&amp; Value ) i-&gt;dtor(Value); } LeaveCriticalSection(&amp;_mingwthr_cs); } //----- (0000000000402EC0) ---------------------------------------------------- int __fastcall __w64_mingwthr_add_key_dtor(DWORD key, void (*dtor)(void *)) { int result; // eax volatile __mingwthr_key_t *v5; // rax volatile __mingwthr_key_t *v6; // rbx volatile __mingwthr_key_t *v7; // rax result = _mingwthr_cs_init; if ( _mingwthr_cs_init ) { v5 = calloc(1uLL, 0x18uLL); v6 = v5; if ( v5 ) { v5-&gt;key = key; v5-&gt;dtor = dtor; EnterCriticalSection(&amp;_mingwthr_cs); v7 = key_dtor_list; key_dtor_list = v6; v6-&gt;next = v7; LeaveCriticalSection(&amp;_mingwthr_cs); return 0; } else { return -1; } } return result; } //----- (0000000000402F40) ---------------------------------------------------- int __fastcall __w64_mingwthr_remove_key_dtor(DWORD key) { volatile __mingwthr_key_t *v3; // rdx volatile __mingwthr_key_t *next; // rax volatile __mingwthr_key_t *v5; // rcx if ( !_mingwthr_cs_init ) return 0; EnterCriticalSection(&amp;_mingwthr_cs); v3 = key_dtor_list; if ( key_dtor_list ) { if ( key_dtor_list-&gt;key == key ) { v5 = key_dtor_list; key_dtor_list = key_dtor_list-&gt;next; LABEL_12: free(v5); LeaveCriticalSection(&amp;_mingwthr_cs); return 0; } while ( 1 ) { next = v3-&gt;next; if ( !next ) break; if ( next-&gt;key == key ) { v5 = v3-&gt;next; v3-&gt;next = next-&gt;next; goto LABEL_12; } v3 = v3-&gt;next; } } LeaveCriticalSection(&amp;_mingwthr_cs); return 0; } //----- (0000000000402FE0) ---------------------------------------------------- // local variable allocation has failed, the output may be wrong! WINBOOL __fastcall _mingw_TLScallback(HANDLE hDllHandle, DWORD reason, LPVOID reserved) { WINBOOL result; // eax if ( reason == 1 ) { if ( !_mingwthr_cs_init ) InitializeCriticalSection(&amp;_mingwthr_cs); result = 1; _mingwthr_cs_init = 1; } else { if ( reason ) { if ( reason == 3 ) { if ( _mingwthr_cs_init ) _mingwthr_run_key_dtors_part_0(); } } else { if ( _mingwthr_cs_init ) _mingwthr_run_key_dtors_part_0(); if ( _mingwthr_cs_init == 1 ) { _mingwthr_cs_init = 0; _IAT_start__(&amp;_mingwthr_cs, *&amp;reason, reserved); } } return 1; } return result; } // 402FE0: variables would overlap: edx.4 and rdx.8 // 409268: using guessed type __int64 __fastcall _IAT_start__(_QWORD, _QWORD, _QWORD); //----- (00000000004030E0) ---------------------------------------------------- void (*__cdecl get_invalid_parameter_handler())(const wchar_t *, const wchar_t *, const wchar_t *, unsigned int, uintptr_t) { return handler; } //----- (00000000004030F0) ---------------------------------------------------- void (*__fastcall set_invalid_parameter_handler( void (*new_handler)(const wchar_t *, const wchar_t *, const wchar_t *, unsigned int, uintptr_t)))(const wchar_t *, const wchar_t *, const wchar_t *, unsigned int, uintptr_t) { return _InterlockedExchange64(&amp;handler, new_handler); } // nfuncs=114 queued=48 decompiled=48 lumina nreq=0 worse=0 better=0 // ALL OK, 48 function(s) have been successfully decompiled Exploit:">

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>
    
    Keygen si puedes
    
  </title>
  <link rel="stylesheet" href='https://imlauera.github.io/css/site.min.css'>
  <link rel="canonical" href="https://imlauera.github.io/post/keygen/">
  <link rel="alternate" type="application/rss&#43;xml" href="https://imlauera.github.io/index.xml" title="Imlauer">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="referrer" content="no-referrer">
  <meta name="author" content="Imlauer.">
  <meta name="description" content="El keygen se encuentra en: https://drive.google.com/file/d/1QRIk3zBGGXH54nSZorX3jnuNmURCHw6K/view?pli=1
El c贸digo que me gener贸 el ida es:

#include &lt;windows.h&gt;
#include &lt;defs.h&gt;

#include &lt;stdarg.h&gt;


//-------------------------------------------------------------------------
// Function declarations

void __fastcall _mingw_invalidParameterHandler(const wchar_t *expression, const wchar_t *function, const wchar_t *file, unsigned int line, uintptr_t pReserved);
int __cdecl pre_c_init();
void __cdecl pre_cpp_init();
// int __cdecl _tmainCRTStartup();
// int __cdecl WinMainCRTStartup();
int __cdecl mainCRTStartup();
char *__fastcall generaLetras(int a1, char *a2);
__int64 __fastcall generaNumero(char *a1); // idb
int __fastcall generaSerial(char *a1, char *a2);
int __fastcall checkSerial(char *a1, char *a2);
INT_PTR __fastcall DialogProc(HWND a1, int a2, unsigned __int16 a3);
int __stdcall WinMain(HINSTANCE hInst, HINSTANCE hPreInst, LPSTR lpszCmdLine, int nCmdShow);
void *__fastcall decode_pointer(void *codedptr);
void *__fastcall encode_pointer(void *ptr);
int __cdecl setargv();
void __fastcall _mingw_raise_matherr(int typ, const char *name, double a3, double a1, double rslt);
void __fastcall _mingw_setusermatherr(int (*f)(_exception *));
int __fastcall matherr(_exception *pexcept);
void _report_error(const char *msg, ...);
void __fastcall _write_memory_part_0(void *addr, const void *src, size_t len);
void __cdecl pei386_runtime_relocator();
int __fastcall _mingw_SEH_error_handler(_EXCEPTION_RECORD *ExceptionRecord, void *EstablisherFrame, _CONTEXT *ContextRecord, void *DispatcherContext);
int __cdecl _mingw_init_ehandler();
int __fastcall gnu_exception_handler(EXCEPTION_POINTERS *exception_data);
void __cdecl fpreset();
void __cdecl _do_global_dtors();
void __cdecl _do_global_ctors();
void __cdecl _main();
void __cdecl _security_init_cookie();
void __fastcall _report_gsfailure(ULONG_PTR StackCookie);
BOOL __fastcall _dyn_tls_dtor(HANDLE hDllHandle, DWORD dwReason, LPVOID lpreserved);
BOOL __fastcall _dyn_tls_init(HANDLE hDllHandle, DWORD dwReason, LPVOID lpreserved);
int __fastcall _tlregdtor(_PVFV func);
_onexit_t __fastcall mingw_onexit(_onexit_t func);
int __fastcall atexit(_PVFV func);
int __cdecl my_lconv_init();
WINBOOL __fastcall ValidateImageBase_part_0(PBYTE pImageBase);
WINBOOL __fastcall ValidateImageBase(PBYTE pImageBase);
PIMAGE_SECTION_HEADER __fastcall FindPESection(PBYTE pImageBase, DWORD_PTR rva);
PIMAGE_SECTION_HEADER __fastcall FindPESectionByName(const char *pName);
PIMAGE_SECTION_HEADER __fastcall _mingw_GetSectionForAddress(LPVOID p);
int __cdecl _mingw_GetSectionCount();
PIMAGE_SECTION_HEADER __fastcall FindPESectionExec(size_t eNo);
PBYTE __cdecl GetPEImageBase();
WINBOOL __fastcall IsNonwritableInCurrentImage(PBYTE pTarget);
const char *__fastcall _mingw_enum_import_library_names(int i);
void __cdecl _mingwthr_run_key_dtors_part_0();
int __fastcall __w64_mingwthr_add_key_dtor(DWORD key, void (*dtor)(void *));
int __fastcall __w64_mingwthr_remove_key_dtor(DWORD key);
WINBOOL __fastcall _mingw_TLScallback(HANDLE hDllHandle, DWORD reason, LPVOID reserved);
// void __cdecl _set_app_type(_crt_app_type Type);
// __int64 __fastcall _getmainargs(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
void (*__cdecl get_invalid_parameter_handler())(const wchar_t *, const wchar_t *, const wchar_t *, unsigned int, uintptr_t);
void (*__fastcall set_invalid_parameter_handler(void (*new_handler)(const wchar_t *, const wchar_t *, const wchar_t *, unsigned int, uintptr_t)))(const wchar_t *, const wchar_t *, const wchar_t *, unsigned int, uintptr_t);
// void *__cdecl malloc(size_t Size);
// size_t __cdecl strlen(const char *Str);
// void *__cdecl memcpy(void *, const void *Src, size_t Size);
// void __cdecl cexit();
// __int64 __fastcall amsg_exit(_QWORD); weak
// void __cdecl initterm(_PVFV *First, _PVFV *Last);
// void __cdecl __noreturn exit(int Code);
// int printf(const char *const Format, ...);
// int sprintf(char *const Buffer, const char *const Format, ...);
// void __cdecl _setusermatherr(_UserMathErrorFunctionPointer UserMathErrorFunction);
// FILE *__cdecl _iob_func();
// int fprintf(FILE *const Stream, const char *const Format, ...);
// size_t __cdecl fwrite(const void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream);
// int __cdecl vfprintf(FILE *const Stream, const char *const Format, va_list ArgList);
// void __cdecl __noreturn abort();
// _crt_signal_t __cdecl signal(int Signal, _crt_signal_t Function);
// __int64 __fastcall lock(_QWORD); weak
// __int64 __fastcall _dllonexit(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall unlock(_QWORD); weak
// int __cdecl strncmp(const char *Str1, const char *Str2, size_t MaxCount);
// void *__cdecl calloc(size_t Count, size_t Size);
// void __cdecl free(void *Block);
// int __fastcall main(int flags, char **cmdline, char **inst); idb
// __int64 __fastcall _IAT_start__(_QWORD, _QWORD, _QWORD); weak
// __int64 __lconv_init(void); weak

//-------------------------------------------------------------------------
// Data declarations

func_ptr *p_73208 = (func_ptr *)0x403338LL; // idb
UINT_PTR _security_cookie = 47936899621426uLL; // idb
UINT_PTR _security_cookie_complement = 18446696136809930189uLL; // idb
char aSfmsilqzdxajhn[53] = &#34;sfMSiLQzdXajhnZKrPyAoHbTDNREWtuVOcGIxkYemgBClvwFUpqJ&#34;; // weak
const EXCEPTION_POINTERS GS_ExceptionPointers = { &amp;GS_ExceptionRecord, &amp;GS_ContextRecord }; // idb
int *refptr__CRT_MT = &amp;CRT_MT; // weak
int *refptr__MINGW_INSTALL_DEBUG_MATHERR = &amp;MINGW_INSTALL_DEBUG_MATHERR; // weak
__int64 (*refptr___CTOR_LIST__)[2] = &amp;__CTOR_LIST__; // weak
_UNKNOWN *refptr___RUNTIME_PSEUDO_RELOC_LIST_END__ = &amp;_RUNTIME_PSEUDO_RELOC_LIST_END___0; // weak
_UNKNOWN *refptr___RUNTIME_PSEUDO_RELOC_LIST__ = &amp;_RUNTIME_PSEUDO_RELOC_LIST_END___0; // weak
const PBYTE refptr___image_base__ = (const PBYTE)0x400000LL; // idb
_UNKNOWN *refptr___imp__fmode = &amp;_fmode; // weak
_UNKNOWN *refptr___imp__onexit = &amp;_onexit; // weak
__int64 *refptr___onexitbegin = &amp;_onexitbegin; // weak
__int64 *refptr___onexitend = &amp;_onexitend; // weak
int *refptr__dowildcard = &amp;dowildcard; // weak
int *refptr__fmode = &amp;fmode; // weak
int *refptr__newmode = &amp;newmode; // weak
int *refptr_mingw_app_type = &amp;mingw_app_type; // weak
int *refptr_mingw_initcharmax = &amp;mingw_initcharmax; // weak
int *refptr_mingw_initltsdrot_force = &amp;mingw_initltsdrot_force; // weak
int *refptr_mingw_initltsdyn_force = &amp;mingw_initltsdyn_force; // weak
int *refptr_mingw_initltssuo_force = &amp;mingw_initltssuo_force; // weak
_startupinfo _bss_start__; // idb
int managedapp; // idb
int argret; // idb
char **envp; // idb
char **argv; // idb
int argc; // idb
fUserMathErr stUserMathErr; // idb
int was_init_73980; // idb
int maxSections; // idb
sSecInfo *the_secs; // idb
int was_here_73812; // idb
UNWIND_INFO emu_xdata[32]; // idb
RUNTIME_FUNCTION emu_pdata[32]; // idb
int initialized; // idb
CONTEXT GS_ContextRecord; // idb
EXCEPTION_RECORD GS_ExceptionRecord; // idb
volatile __mingwthr_key_t *key_dtor_list; // idb
volatile int _mingwthr_cs_init; // idb
CRITICAL_SECTION _mingwthr_cs; // idb
void (*handler)(const wchar_t *, const wchar_t *, const wchar_t *, unsigned int, uintptr_t); // idb
_PVFV *_onexitbegin; // idb
_PVFV *_onexitend; // idb
// extern void (__stdcall *EnterCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern HANDLE (__stdcall *GetCurrentProcess)();
// extern DWORD (__stdcall *GetCurrentProcessId)();
// extern DWORD (__stdcall *GetCurrentThreadId)();
// extern DWORD (__stdcall *GetLastError)();
// extern void (__stdcall *GetSystemTimeAsFileTime)(LPFILETIME lpSystemTimeAsFileTime);
// extern DWORD (__stdcall *GetTickCount)();
// extern void (__stdcall *InitializeCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern void (__stdcall *LeaveCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern BOOL (__stdcall *QueryPerformanceCounter)(LARGE_INTEGER *lpPerformanceCount);
// extern BOOLEAN (__cdecl *RtlAddFunctionTable)(PRUNTIME_FUNCTION FunctionTable, ULONG EntryCount, ULONG64 BaseAddress);
// extern void (__stdcall *RtlCaptureContext)(PCONTEXT ContextRecord);
// extern PRUNTIME_FUNCTION (__stdcall *RtlLookupFunctionEntry)(ULONG64 ControlPc, PULONG64 ImageBase, PUNWIND_HISTORY_TABLE HistoryTable);
// extern PEXCEPTION_ROUTINE (__stdcall *RtlVirtualUnwind)(ULONG HandlerType, ULONG64 ImageBase, ULONG64 ControlPc, PRUNTIME_FUNCTION FunctionEntry, PCONTEXT ContextRecord, PVOID *HandlerData, PULONG64 EstablisherFrame, PKNONVOLATILE_CONTEXT_POINTERS ContextPointers);
// extern LPTOP_LEVEL_EXCEPTION_FILTER (__stdcall *SetUnhandledExceptionFilter)(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter);
// extern BOOL (__stdcall *TerminateProcess)(HANDLE hProcess, UINT uExitCode);
// extern LPVOID (__stdcall *TlsGetValue)(DWORD dwTlsIndex);
// extern LONG (__stdcall *UnhandledExceptionFilter)(struct _EXCEPTION_POINTERS *ExceptionInfo);
// extern BOOL (__stdcall *VirtualProtect)(LPVOID lpAddress, SIZE_T dwSize, DWORD flNewProtect, PDWORD lpflOldProtect);
// extern SIZE_T (__stdcall *VirtualQuery)(LPCVOID lpAddress, PMEMORY_BASIC_INFORMATION lpBuffer, SIZE_T dwLength);
// extern HWND (__stdcall *CreateDialogParamA)(HINSTANCE hInstance, LPCSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam);
// extern LRESULT (__stdcall *DispatchMessageA)(const MSG *lpMsg);
// extern BOOL (__stdcall *EndDialog)(HWND hDlg, INT_PTR nResult);
// extern UINT (__stdcall *GetDlgItemTextA)(HWND hDlg, int nIDDlgItem, LPSTR lpString, int cchMax);
// extern BOOL (__stdcall *GetMessageA)(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax);
// extern BOOL (__stdcall *IsDialogMessageA)(HWND hDlg, LPMSG lpMsg);
// extern HMENU (__stdcall *LoadMenuA)(HINSTANCE hInstance, LPCSTR lpMenuName);
// extern int (__stdcall *MessageBoxA)(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType);
// extern BOOL (__stdcall *SetMenu)(HWND hWnd, HMENU hMenu);
// extern BOOL (__stdcall *ShowWindow)(HWND hWnd, int nCmdShow);
// extern BOOL (__stdcall *TranslateMessage)(const MSG *lpMsg);


//----- (0000000000401010) ----------------------------------------------------
int __cdecl pre_c_init()
{
  _BOOL8 v0; // rdx
  void *v1; // rax
  BYTE *v3; // rax
  __int16 v4; // cx

  LODWORD(v0) = 0;
  *refptr_mingw_initltsdrot_force = 1;
  *refptr_mingw_initltsdyn_force = 1;
  *refptr_mingw_initltssuo_force = 1;
  *refptr_mingw_initcharmax = 1;
  if ( *refptr___image_base__ == 23117 )
  {
    v3 = &amp;refptr___image_base__[*(refptr___image_base__ &#43; 15)];
    if ( *v3 == 17744 )
    {
      v4 = *(v3 &#43; 12);
      if ( v4 == 267 )
      {
        if ( *(v3 &#43; 29) &gt; 0xEu )
          v0 = *(v3 &#43; 58) != 0;
      }
      else if ( v4 == 523 &amp;&amp; *(v3 &#43; 33) &gt; 0xEu )
      {
        v0 = *(v3 &#43; 62) != 0;
      }
    }
  }
  managedapp = v0;
  if ( *refptr_mingw_app_type )
    _set_app_type(_crt_gui_app);
  else
    _set_app_type(_crt_console_app);
  v1 = encode_pointer(0xFFFFFFFFFFFFFFFFLL);
  *refptr___onexitend = v1;
  *refptr___onexitbegin = v1;
  **refptr___imp__fmode = *refptr__fmode;
  setargv();
  if ( *refptr__MINGW_INSTALL_DEBUG_MATHERR == 1 )
    _mingw_setusermatherr(matherr);
  return 0;
}
// 405370: using guessed type int *refptr__MINGW_INSTALL_DEBUG_MATHERR;
// 4053F0: using guessed type _UNKNOWN *refptr___imp__fmode;
// 405470: using guessed type __int64 *refptr___onexitbegin;
// 405480: using guessed type __int64 *refptr___onexitend;
// 4054E0: using guessed type int *refptr__fmode;
// 405520: using guessed type int *refptr_mingw_app_type;
// 405530: using guessed type int *refptr_mingw_initcharmax;
// 405540: using guessed type int *refptr_mingw_initltsdrot_force;
// 405550: using guessed type int *refptr_mingw_initltsdyn_force;
// 405560: using guessed type int *refptr_mingw_initltssuo_force;

//----- (0000000000401160) ----------------------------------------------------
void __cdecl pre_cpp_init()
{
  _bss_start__.newmode = *refptr__newmode;
  argret = _getmainargs(&amp;argc, &amp;argv, &amp;envp, *refptr__dowildcard, &amp;_bss_start__);
}
// 4030D0: using guessed type __int64 __fastcall _getmainargs(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 4054D0: using guessed type int *refptr__dowildcard;
// 405510: using guessed type int *refptr__newmode;

//----- (0000000000401500) ----------------------------------------------------
int __cdecl mainCRTStartup()
{
  *refptr_mingw_app_type = 0;
  _security_init_cookie();
  return _tmainCRTStartup();
}
// 405520: using guessed type int *refptr_mingw_app_type;

//----- (0000000000401530) ----------------------------------------------------
char *__fastcall generaLetras(int a1, char *a2)
{
  size_t v2; // rax
  char *result; // rax
  int v4; // [rsp&#43;28h] [rbp-58h]
  int v5; // [rsp&#43;2Ch] [rbp-54h]
  int v6; // [rsp&#43;30h] [rbp-50h]
  int v7; // [rsp&#43;34h] [rbp-4Ch]

  v7 = (a1 &#43; 15) % strlen(&#34;sfMSiLQzdXajhnZKrPyAoHbTDNREWtuVOcGIxkYemgBClvwFUpqJ&#34;);
  v6 = (a1 &#43; 22) % strlen(&#34;sfMSiLQzdXajhnZKrPyAoHbTDNREWtuVOcGIxkYemgBClvwFUpqJ&#34;);
  v5 = (a1 &#43; 32) % strlen(&#34;sfMSiLQzdXajhnZKrPyAoHbTDNREWtuVOcGIxkYemgBClvwFUpqJ&#34;);
  v4 = (a1 &#43; 17) % strlen(&#34;sfMSiLQzdXajhnZKrPyAoHbTDNREWtuVOcGIxkYemgBClvwFUpqJ&#34;);
  v2 = strlen(&#34;sfMSiLQzdXajhnZKrPyAoHbTDNREWtuVOcGIxkYemgBClvwFUpqJ&#34;);
  *a2 = aSfmsilqzdxajhn[v7];
  a2[1] = aSfmsilqzdxajhn[v6];
  a2[2] = aSfmsilqzdxajhn[v5];
  a2[3] = aSfmsilqzdxajhn[v4];
  a2[4] = aSfmsilqzdxajhn[((a1 &#43; 4) % v2)];
  result = a2 &#43; 5;
  a2[5] = 0;
  return result;
}

//----- (00000000004016AD) ----------------------------------------------------
__int64 __fastcall generaNumero(char *a1)
{
  int i; // [rsp&#43;28h] [rbp-58h]
  int v3; // [rsp&#43;2Ch] [rbp-54h]

  v3 = 0;
  for ( i = 0; i &lt; strlen(a1); &#43;&#43;i )
    v3 &#43;= a1[i];
  printf(&#34;Numero: %d&#34;, v3 &#43; 6572);
  return (v3 &#43; 6572);
}

//----- (0000000000401746) ----------------------------------------------------
int __fastcall generaSerial(char *a1, char *a2)
{
  char v3[16]; // [rsp&#43;40h] [rbp-50h] BYREF
  char v4[16]; // [rsp&#43;50h] [rbp-40h] BYREF
  char v5[16]; // [rsp&#43;60h] [rbp-30h] BYREF
  char v6[16]; // [rsp&#43;70h] [rbp-20h] BYREF
  char v7[12]; // [rsp&#43;80h] [rbp-10h] BYREF
  int v8; // [rsp&#43;8Ch] [rbp-4h]

  v8 = generaNumero(a1);
  generaLetras(v8, v7);
  v8 = generaNumero(v7);
  generaLetras(v8, v6);
  v8 = generaNumero(v6);
  generaLetras(v8, v5);
  v8 = generaNumero(v5);
  generaLetras(v8, v4);
  v8 = generaNumero(v4);
  generaLetras(v8, v3);
  return sprintf(a2, &#34;%s-%s-%s-%s-%s&#34;, v7, v6, v5, v4, v3);
}

//----- (000000000040182D) ----------------------------------------------------
int __fastcall checkSerial(char *a1, char *a2)
{
  size_t v2; // rbx
  size_t v3; // rax
  int i; // [rsp&#43;28h] [rbp-58h]
  char v6; // [rsp&#43;2Fh] [rbp-51h]

  v6 = 1;
  v2 = strlen(a1);
  if ( v2 == strlen(a2) )
  {
    for ( i = 0; ; &#43;&#43;i )
    {
      v3 = strlen(a2);
      if ( i &gt;= v3 )
        break;
      if ( a1[i] != a2[i] )
      {
        LODWORD(v3) = MessageBoxA(0LL, &#34;Nope sigue intentando&#34;, &#34;Nop&#34;, 0x30u);
        v6 = 0;
        break;
      }
    }
    if ( v6 )
      LODWORD(v3) = MessageBoxA(0LL, &#34;Genial lo lograste&#34;, &#34;Felicitaciones&#34;, 0);
  }
  else
  {
    MessageBoxA(0LL, &#34;Nope sigue intentando&#34;, &#34;Nop&#34;, 0x30u);
    LODWORD(v3) = 0;
  }
  return v3;
}

//----- (000000000040192F) ----------------------------------------------------
INT_PTR __fastcall DialogProc(HWND a1, int a2, unsigned __int16 a3)
{
  char v4[32]; // [rsp&#43;20h] [rbp-60h] BYREF
  CHAR v5[32]; // [rsp&#43;40h] [rbp-40h] BYREF
  CHAR String[28]; // [rsp&#43;60h] [rbp-20h] BYREF
  UINT DlgItemTextA; // [rsp&#43;7Ch] [rbp-4h]

  DlgItemTextA = 0;
  switch ( a2 )
  {
    case 272:
      return 1LL;
    case 273:
      if ( a3 == 40000 )
      {
        DlgItemTextA = GetDlgItemTextA(a1, 40002, String, 20);
        if ( DlgItemTextA )
        {
          DlgItemTextA = GetDlgItemTextA(a1, 40003, v5, 30);
          if ( DlgItemTextA )
          {
            generaSerial(String, v4);
            checkSerial(v5, v4);
            return 1LL;
          }
          MessageBoxA(a1, &#34;Nope sigue intentando&#34;, &#34;Nop&#34;, 0x30u);
        }
        else
        {
          MessageBoxA(a1, &#34;Nope sigue intentando&#34;, &#34;Nop&#34;, 0x30u);
        }
      }
      else if ( a3 == 40006 )
      {
        MessageBoxA(a1, &#34;keygeneame si puedes\n\nEl objetivo es crear el keygen sin parchear nada&#34;, &#34;About&#34;, 0x40u);
        return 1LL;
      }
      return 1LL;
    case 16:
      EndDialog(a1, 0LL);
      return 1LL;
    default:
      return 0LL;
  }
}

//----- (0000000000401AA6) ----------------------------------------------------
int __stdcall WinMain(HINSTANCE hInst, HINSTANCE hPreInst, LPSTR lpszCmdLine, int nCmdShow)
{
  tagMSG Msg; // [rsp&#43;30h] [rbp-40h] BYREF
  HMENU hMenu; // [rsp&#43;60h] [rbp-10h]
  HWND hWnd; // [rsp&#43;68h] [rbp-8h]

  hWnd = CreateDialogParamA(hInst, 102, 0LL, DialogProc, 0LL);
  hMenu = LoadMenuA(hInst, 0x69);
  SetMenu(hWnd, hMenu);
  ShowWindow(hWnd, 10);
  while ( GetMessageA(&amp;Msg, 0LL, 0, 0) &gt; 0 )
  {
    if ( !IsDialogMessageA(hWnd, &amp;Msg) )
    {
      TranslateMessage(&amp;Msg);
      DispatchMessageA(&amp;Msg);
    }
  }
  return 0;
}

//----- (0000000000401BA0) ----------------------------------------------------
void *__fastcall decode_pointer(void *codedptr)
{
  return codedptr;
}

//----- (0000000000401BB0) ----------------------------------------------------
void *__fastcall encode_pointer(void *ptr)
{
  return ptr;
}

//----- (0000000000401BC0) ----------------------------------------------------
int __cdecl setargv()
{
  return 0;
}

//----- (0000000000401BD0) ----------------------------------------------------
void __fastcall _mingw_raise_matherr(int typ, const char *name, double a3, double a1, double rslt)
{
  _exception ex; // [rsp&#43;20h] [rbp-38h] BYREF

  if ( stUserMathErr )
  {
    ex.type = typ;
    ex.name = name;
    ex.arg1 = a3;
    ex.arg2 = a1;
    ex.retval = rslt;
    stUserMathErr(&amp;ex);
  }
}

//----- (0000000000401C20) ----------------------------------------------------
void __fastcall _mingw_setusermatherr(int (*f)(_exception *))
{
  stUserMathErr = f;
  _setusermatherr(f);
}

//----- (0000000000401C30) ----------------------------------------------------
int __fastcall matherr(_exception *pexcept)
{
  const char *v1; // rbx
  double retval; // xmm8_8
  const char *name; // rsi
  double arg2; // xmm7_8
  double arg1; // xmm6_8
  FILE *v6; // rax

  switch ( pexcept-&gt;type )
  {
    case 1:
      v1 = &#34;Argument domain error (DOMAIN)&#34;;
      break;
    case 2:
      v1 = &#34;Argument singularity (SIGN)&#34;;
      break;
    case 3:
      v1 = &#34;Overflow range error (OVERFLOW)&#34;;
      break;
    case 4:
      v1 = &#34;The result is too small to be represented (UNDERFLOW)&#34;;
      break;
    case 5:
      v1 = &#34;Total loss of significance (TLOSS)&#34;;
      break;
    case 6:
      v1 = &#34;Partial loss of significance (PLOSS)&#34;;
      break;
    default:
      v1 = &#34;Unknown error&#34;;
      break;
  }
  retval = pexcept-&gt;retval;
  name = pexcept-&gt;name;
  arg2 = pexcept-&gt;arg2;
  arg1 = pexcept-&gt;arg1;
  v6 = _iob_func();
  fprintf(v6 &#43; 2, &#34;_matherr(): %s in %s(%g, %g)  (retval=%g)\n&#34;, v1, name, arg1, arg2, retval);
  return 0;
}

//----- (0000000000401D30) ----------------------------------------------------
void __noreturn _report_error(const char *msg, ...)
{
  FILE *v2; // rax
  FILE *v3; // rax
  va_list va; // [rsp&#43;58h] [rbp&#43;10h] BYREF

  va_start(va, msg);
  v2 = _iob_func();
  fwrite(&#34;Mingw-w64 runtime failure:\n&#34;, 1uLL, 0x1BuLL, v2 &#43; 2);
  v3 = _iob_func();
  vfprintf(v3 &#43; 2, msg, va);
  abort();
}

//----- (0000000000401DA0) ----------------------------------------------------
void __fastcall _write_memory_part_0(void *addr, const void *src, size_t len)
{
  __int64 v3; // rbp
  int v7; // r9d
  PBYTE *p_sec_start; // rax
  PIMAGE_SECTION_HEADER SectionForAddress; // rax
  PIMAGE_SECTION_HEADER v10; // r12
  __int64 v11; // rbp
  sSecInfo *v12; // r13
  DWORD LastError; // eax
  struct _MEMORY_BASIC_INFORMATION Buffer; // [rsp&#43;20h] [rbp-68h] BYREF

  v3 = maxSections;
  if ( maxSections &lt;= 0 )
  {
    v3 = 0LL;
LABEL_6:
    SectionForAddress = _mingw_GetSectionForAddress(addr);
    v10 = SectionForAddress;
    if ( !SectionForAddress )
      _report_error(&#34;Address %p has no image-section&#34;, addr);
    v11 = v3;
    v12 = &amp;the_secs[v11];
    v12-&gt;hash = SectionForAddress;
    v12-&gt;old_protect = 0;
    v12-&gt;sec_start = &amp;GetPEImageBase()[SectionForAddress-&gt;VirtualAddress];
    if ( !VirtualQuery(the_secs[v11].sec_start, &amp;Buffer, 0x30uLL) )
      _report_error(
        &#34;  VirtualQuery failed for %d bytes at address %p&#34;,
        v10-&gt;Misc.PhysicalAddress,
        the_secs[v11].sec_start);
    if ( ((Buffer.Protect - 4) &amp; 0xFFFFFFFB) != 0
      &amp;&amp; ((Buffer.Protect - 64) &amp; 0xFFFFFFBF) != 0
      &amp;&amp; !VirtualProtect(Buffer.BaseAddress, Buffer.RegionSize, 0x40u, &amp;the_secs[v11].old_protect) )
    {
      LastError = GetLastError();
      _report_error(&#34;  VirtualProtect failed with code 0x%x&#34;, LastError);
    }
    &#43;&#43;maxSections;
  }
  else
  {
    v7 = 0;
    p_sec_start = &amp;the_secs-&gt;sec_start;
    while ( addr &lt; *p_sec_start || addr &gt;= &amp;(*p_sec_start)[*(p_sec_start[1] &#43; 2)] )
    {
      &#43;&#43;v7;
      p_sec_start &#43;= 3;
      if ( v7 == maxSections )
        goto LABEL_6;
    }
  }
  memcpy(addr, src, len);
}

//----- (0000000000401F10) ----------------------------------------------------
void __cdecl pei386_runtime_relocator()
{
  unsigned __int64 v0; // rax
  void *v1; // rsp
  _DWORD *v2; // rbx
  void *v3; // rsp
  int v4; // edx
  unsigned int *v5; // rbx
  unsigned int v6; // edx
  BYTE *v7; // rax
  BYTE *v8; // rcx
  __int64 v9; // r8
  __int64 v10; // rbx
  int i; // esi
  __int64 v12; // rcx
  int v13; // eax
  BYTE *v14; // rcx
  unsigned __int64 v15; // rdx
  unsigned __int64 v16; // rdx
  unsigned __int64 v17; // rdx
  char v18; // [rsp&#43;20h] [rbp-40h] BYREF
  DWORD flOldProtect; // [rsp&#43;2Ch] [rbp-34h] BYREF
  struct _MEMORY_BASIC_INFORMATION src; // [rsp&#43;30h] [rbp-30h] BYREF

  if ( was_init_73980 )
    return;
  was_init_73980 = 1;
  v0 = (24LL * _mingw_GetSectionCount() &#43; 30) &amp; 0xFFFFFFFFFFFFFFF0uLL;
  v1 = alloca(v0);
  v2 = refptr___RUNTIME_PSEUDO_RELOC_LIST__;
  v3 = alloca(v0);
  maxSections = 0;
  the_secs = &amp;v18;
  if ( refptr___RUNTIME_PSEUDO_RELOC_LIST_END__ - refptr___RUNTIME_PSEUDO_RELOC_LIST__ &lt;= 7 )
    return;
  if ( refptr___RUNTIME_PSEUDO_RELOC_LIST_END__ - refptr___RUNTIME_PSEUDO_RELOC_LIST__ &gt; 11 )
  {
    if ( *refptr___RUNTIME_PSEUDO_RELOC_LIST__ || *(refptr___RUNTIME_PSEUDO_RELOC_LIST__ &#43; 1) )
      goto LABEL_25;
    if ( *(refptr___RUNTIME_PSEUDO_RELOC_LIST__ &#43; 2) )
      goto LABEL_11;
    v2 = (refptr___RUNTIME_PSEUDO_RELOC_LIST__ &#43; 12);
  }
  if ( *v2 || v2[1] )
  {
LABEL_25:
    if ( v2 &gt;= refptr___RUNTIME_PSEUDO_RELOC_LIST_END__ )
      return;
    do
    {
      v12 = v2[1];
      v13 = *v2;
      v2 &#43;= 2;
      v14 = &amp;refptr___image_base__[v12];
      LODWORD(src.BaseAddress) = *v14 &#43; v13;
      _write_memory_part_0(v14, &amp;src, 4uLL);
    }
    while ( v2 &lt; refptr___RUNTIME_PSEUDO_RELOC_LIST_END__ );
    goto LABEL_19;
  }
LABEL_11:
  v4 = v2[2];
  if ( v4 != 1 )
    _report_error(&#34;  Unknown pseudo relocation protocol version %d.\n&#34;, v4);
  v5 = v2 &#43; 3;
  if ( v5 &lt; refptr___RUNTIME_PSEUDO_RELOC_LIST_END__ )
  {
    do
    {
      v6 = *(v5 &#43; 8);
      v7 = &amp;refptr___image_base__[*v5];
      v8 = &amp;refptr___image_base__[v5[1]];
      v9 = *v7;
      if ( v6 == 16 )
      {
        v16 = *v8;
        if ( (v16 &amp; 0x8000u) != 0LL )
          v16 = *v8 | 0xFFFFFFFFFFFF0000uLL;
        src.BaseAddress = (v9 &#43; v16 - v7);
        _write_memory_part_0(v8, &amp;src, 2uLL);
      }
      else if ( v6 &lt;= 0x10 )
      {
        if ( v6 != 8 )
        {
LABEL_35:
          src.BaseAddress = 0LL;
          _report_error(&#34;  Unknown pseudo relocation bit size %d.\n&#34;, v6);
        }
        v15 = *v8;
        if ( (v15 &amp; 0x80u) != 0LL )
          v15 = *v8 | 0xFFFFFFFFFFFFFF00uLL;
        src.BaseAddress = (v9 &#43; v15 - v7);
        _write_memory_part_0(v8, &amp;src, 1uLL);
      }
      else if ( v6 == 32 )
      {
        v17 = *v8;
        if ( (v17 &amp; 0x80000000) != 0LL )
          v17 = *v8 | 0xFFFFFFFF00000000uLL;
        src.BaseAddress = (v9 &#43; v17 - v7);
        _write_memory_part_0(v8, &amp;src, 4uLL);
      }
      else
      {
        if ( v6 != 64 )
          goto LABEL_35;
        src.BaseAddress = (*v8 &#43; v9 - v7);
        _write_memory_part_0(v8, &amp;src, 8uLL);
      }
      v5 &#43;= 3;
    }
    while ( v5 &lt; refptr___RUNTIME_PSEUDO_RELOC_LIST_END__ );
LABEL_19:
    v10 = 0LL;
    for ( i = 0; i &lt; maxSections; &#43;&#43;v10 )
    {
      if ( the_secs[v10].old_protect )
      {
        if ( !VirtualQuery(the_secs[v10].sec_start, &amp;src, 0x30uLL) )
          _report_error(
            &#34;  VirtualQuery failed for %d bytes at address %p&#34;,
            the_secs[v10].hash-&gt;Misc.PhysicalAddress,
            the_secs[v10].sec_start);
        VirtualProtect(src.BaseAddress, src.RegionSize, the_secs[v10].old_protect, &amp;flOldProtect);
      }
      &#43;&#43;i;
    }
  }
}
// 405390: using guessed type _UNKNOWN *refptr___RUNTIME_PSEUDO_RELOC_LIST_END__;
// 4053A0: using guessed type _UNKNOWN *refptr___RUNTIME_PSEUDO_RELOC_LIST__;

//----- (0000000000402210) ----------------------------------------------------
int __fastcall _mingw_SEH_error_handler(
        _EXCEPTION_RECORD *ExceptionRecord,
        void *EstablisherFrame,
        _CONTEXT *ContextRecord,
        void *DispatcherContext)
{
  DWORD ExceptionCode; // eax
  _crt_signal_t v5; // rax
  int result; // eax
  _crt_signal_t v7; // rdx
  _crt_signal_t v8; // rax

  ExceptionCode = ExceptionRecord-&gt;ExceptionCode;
  if ( ExceptionRecord-&gt;ExceptionCode &gt; 0xC0000091 )
  {
    if ( ExceptionCode == -1073741676 )
    {
      v7 = signal(8, 0LL);
      if ( v7 == 1 )
      {
        signal(8, 1);
        return 0;
      }
      goto LABEL_16;
    }
    if ( ExceptionCode &gt; 0xC0000094 )
    {
      if ( ExceptionCode == -1073741675 )
        return 0;
      if ( ExceptionCode != -1073741674 )
        return 1;
      goto LABEL_20;
    }
    if ( ExceptionCode == -1073741678 )
      return 0;
    if ( ExceptionCode != -1073741677 )
      return 1;
  }
  else if ( ExceptionCode &lt; 0xC000008D )
  {
    if ( ExceptionCode == -1073741816 )
      return 0;
    if ( ExceptionCode &lt;= 0xC0000008 )
    {
      if ( ExceptionCode != -2147483646 )
      {
        if ( ExceptionCode == -1073741819 )
        {
          v5 = signal(11, 0LL);
          if ( v5 == 1 )
          {
            signal(11, 1);
            return 0;
          }
          if ( v5 )
          {
            (v5)(11LL);
            return 0;
          }
          return 4;
        }
        return 1;
      }
      return 0;
    }
    if ( ExceptionCode != -1073741795 )
      return ExceptionCode != -1073741684;
LABEL_20:
    v8 = signal(4, 0LL);
    if ( v8 == 1 )
    {
      signal(4, 1);
      return 0;
    }
    if ( v8 )
    {
      (v8)(4LL);
      return 0;
    }
    return 4;
  }
  v7 = signal(8, 0LL);
  if ( v7 == 1 )
  {
    signal(8, 1);
    fpreset();
    return 0;
  }
LABEL_16:
  result = 1;
  if ( v7 )
  {
    (v7)(8LL);
    return 0;
  }
  return result;
}

//----- (00000000004023C0) ----------------------------------------------------
int __cdecl _mingw_init_ehandler()
{
  PBYTE PEImageBase; // rbp
  int result; // eax
  RUNTIME_FUNCTION *v2; // rbx
  size_t v3; // rsi
  UNWIND_INFO *v4; // rdi
  DWORD VirtualAddress; // edx
  DWORD v6; // edx
  DWORD v7; // eax
  PIMAGE_SECTION_HEADER PESectionExec; // rax
  ULONG v9; // edx

  PEImageBase = GetPEImageBase();
  result = was_here_73812;
  if ( !was_here_73812 &amp;&amp; PEImageBase )
  {
    was_here_73812 = 1;
    if ( !FindPESectionByName(&#34;.pdata&#34;) )
    {
      v2 = emu_pdata;
      v3 = 0LL;
      memset(emu_pdata, 0, sizeof(emu_pdata));
      memset(emu_xdata, 0, sizeof(emu_xdata));
      v4 = emu_xdata;
      while ( 1 )
      {
        PESectionExec = FindPESectionExec(v3);
        if ( !PESectionExec )
          break;
        v4-&gt;VersionAndFlags = 9;
        v4-&gt;AddressOfExceptionHandler = _mingw_SEH_error_handler - PEImageBase;
        &#43;&#43;v3;
        VirtualAddress = PESectionExec-&gt;VirtualAddress;
        &#43;&#43;v2;
        v2[-1].BeginAddress = VirtualAddress;
        v6 = PESectionExec-&gt;Misc.PhysicalAddress &#43; VirtualAddress;
        v7 = v4&#43;&#43; - PEImageBase;
        v2[-1].UnwindData = v7;
        v2[-1].EndAddress = v6;
        if ( v3 == 32 )
        {
          v9 = 32;
          goto LABEL_11;
        }
      }
      if ( !v3 )
        return 1;
      v9 = v3;
LABEL_11:
      RtlAddFunctionTable(emu_pdata, v9, PEImageBase);
    }
    return 1;
  }
  return result;
}

//----- (0000000000402670) ----------------------------------------------------
void __cdecl fpreset()
{
  __asm { fninit }
}

//----- (0000000000402680) ----------------------------------------------------
void __cdecl _do_global_dtors()
{
  void (*i)(void); // rax

  for ( i = *p_73208; i; &#43;&#43;p_73208 )
  {
    i();
    i = p_73208[1];
  }
}

//----- (00000000004026C0) ----------------------------------------------------
void __cdecl _do_global_ctors()
{
  int i; // ebx

  i = (*refptr___CTOR_LIST__)[0];
  if ( i == -1 )
  {
    for ( i = 0; (*refptr___CTOR_LIST__)[i &#43; 1]; &#43;&#43;i )
      ;
  }
  for ( ; i; --i )
    ((*refptr___CTOR_LIST__)[i])();
  atexit(_do_global_dtors);
}
// 405380: using guessed type __int64 (*refptr___CTOR_LIST__)[2];

//----- (0000000000402720) ----------------------------------------------------
void __cdecl _main()
{
  if ( !initialized )
  {
    initialized = 1;
    _do_global_ctors();
  }
}

//----- (0000000000402740) ----------------------------------------------------
void __cdecl _security_init_cookie()
{
  FT v0; // r12
  __int64 CurrentProcessId; // rbp
  DWORD CurrentThreadId; // edi
  DWORD TickCount; // esi
  LONGLONG v4; // rsi
  UINT_PTR v5; // rax
  FT systime; // [rsp&#43;20h] [rbp-48h] BYREF
  LARGE_INTEGER perfctr; // [rsp&#43;30h] [rbp-38h] BYREF

  systime.ft_scalar = 0LL;
  if ( _security_cookie == 0x2B992DDFA232LL )
  {
    GetSystemTimeAsFileTime(&amp;systime);
    v0.ft_scalar = systime.ft_scalar;
    CurrentProcessId = GetCurrentProcessId();
    CurrentThreadId = GetCurrentThreadId();
    TickCount = GetTickCount();
    QueryPerformanceCounter(&amp;perfctr);
    v4 = (TickCount ^ CurrentThreadId ^ perfctr.QuadPart ^ v0.ft_scalar ^ CurrentProcessId) &amp; 0xFFFFFFFFFFFFLL;
    if ( v4 == 0x2B992DDFA232LL )
    {
      v5 = 0xFFFFD466D2205DCCuLL;
      v4 = 0x2B992DDFA233LL;
    }
    else
    {
      v5 = ~v4;
    }
    _security_cookie = v4;
    _security_cookie_complement = v5;
  }
  else
  {
    _security_cookie_complement = ~_security_cookie;
  }
}

//----- (0000000000402820) ----------------------------------------------------
void __fastcall __noreturn _report_gsfailure(ULONG_PTR StackCookie)
{
  ULONG64 Rip; // rbx
  _RUNTIME_FUNCTION *v3; // r9
  HANDLE CurrentProcess; // rax
  ULONG64 imgBase; // [rsp&#43;48h] [rbp-28h] BYREF
  ULONG64 establisherFrame; // [rsp&#43;50h] [rbp-20h] BYREF
  PVOID hndData; // [rsp&#43;58h] [rbp-18h] BYREF
  UINT_PTR cookie[2]; // [rsp&#43;60h] [rbp-10h]
  char vars8; // [rsp&#43;78h] [rbp&#43;8h] BYREF
  DWORD64 retaddr; // [rsp&#43;88h] [rbp&#43;18h]

  RtlCaptureContext(&amp;GS_ContextRecord);
  Rip = GS_ContextRecord.Rip;
  v3 = RtlLookupFunctionEntry(GS_ContextRecord.Rip, &amp;imgBase, 0LL);
  if ( v3 )
  {
    RtlVirtualUnwind(0, imgBase, Rip, v3, &amp;GS_ContextRecord, &amp;hndData, &amp;establisherFrame, 0LL);
  }
  else
  {
    GS_ContextRecord.Rip = retaddr;
    GS_ContextRecord.Rsp = &amp;vars8;
  }
  GS_ContextRecord.Rcx = StackCookie;
  GS_ExceptionRecord.ExceptionCode = -1073740791;
  GS_ExceptionRecord.ExceptionFlags = 1;
  GS_ExceptionRecord.ExceptionAddress = GS_ContextRecord.Rip;
  cookie[1] = _security_cookie_complement;
  SetUnhandledExceptionFilter(0LL);
  UnhandledExceptionFilter(&amp;GS_ExceptionPointers);
  CurrentProcess = GetCurrentProcess();
  TerminateProcess(CurrentProcess, 0xC0000409);
  abort();
}

//----- (0000000000402920) ----------------------------------------------------
BOOL __fastcall _dyn_tls_dtor(HANDLE hDllHandle, DWORD dwReason, LPVOID lpreserved)
{
  if ( dwReason &amp;&amp; dwReason != 3 )
    return 1;
  _mingw_TLScallback(hDllHandle, dwReason, lpreserved);
  return 1;
}

//----- (0000000000402950) ----------------------------------------------------
BOOL __fastcall _dyn_tls_init(HANDLE hDllHandle, DWORD dwReason, LPVOID lpreserved)
{
  if ( *refptr__CRT_MT != 2 )
    *refptr__CRT_MT = 2;
  if ( dwReason == 1 )
    _mingw_TLScallback(hDllHandle, 1u, lpreserved);
  return 1;
}
// 405360: using guessed type int *refptr__CRT_MT;

//----- (00000000004029C0) ----------------------------------------------------
int __fastcall _tlregdtor(_PVFV func)
{
  return 0;
}

//----- (00000000004029D0) ----------------------------------------------------
_onexit_t __fastcall mingw_onexit(_onexit_t func)
{
  int (*v2)(void); // rbx
  _PVFV *onexitbegin; // [rsp&#43;20h] [rbp-18h] BYREF
  _PVFV *onexitend; // [rsp&#43;28h] [rbp-10h] BYREF

  onexitbegin = decode_pointer(_onexitbegin);
  if ( onexitbegin == -1LL )
    return (*refptr___imp__onexit)(func);
  lock(8LL);
  onexitbegin = decode_pointer(_onexitbegin);
  onexitend = decode_pointer(_onexitend);
  v2 = _dllonexit(func, &amp;onexitbegin, &amp;onexitend);
  _onexitbegin = encode_pointer(onexitbegin);
  _onexitend = encode_pointer(onexitend);
  unlock(8LL);
  return v2;
}
// 403180: using guessed type __int64 __fastcall lock(_QWORD);
// 403188: using guessed type __int64 __fastcall _dllonexit(_QWORD, _QWORD, _QWORD);
// 403190: using guessed type __int64 __fastcall unlock(_QWORD);
// 405400: using guessed type _UNKNOWN *refptr___imp__onexit;

//----- (0000000000402A80) ----------------------------------------------------
int __fastcall atexit(_PVFV func)
{
  return -(mingw_onexit(func) == 0LL);
}

//----- (0000000000402AA0) ----------------------------------------------------
int __cdecl my_lconv_init()
{
  return __lconv_init();
}
// 409350: using guessed type __int64 __lconv_init(void);

//----- (0000000000402AB0) ----------------------------------------------------
WINBOOL __fastcall ValidateImageBase_part_0(PBYTE pImageBase)
{
  BYTE *v1; // rcx
  WINBOOL result; // eax

  v1 = &amp;pImageBase[*(pImageBase &#43; 15)];
  result = 0;
  if ( *v1 == 17744 )
    return *(v1 &#43; 12) == 523;
  return result;
}

//----- (0000000000402AD0) ----------------------------------------------------
WINBOOL __fastcall ValidateImageBase(PBYTE pImageBase)
{
  if ( *pImageBase == 23117 )
    return ValidateImageBase_part_0(pImageBase);
  else
    return 0;
}

//----- (0000000000402AF0) ----------------------------------------------------
PIMAGE_SECTION_HEADER __fastcall FindPESection(PBYTE pImageBase, DWORD_PTR rva)
{
  BYTE *v2; // rcx
  PIMAGE_SECTION_HEADER result; // rax
  int v4; // ecx
  _IMAGE_SECTION_HEADER *v5; // r9

  v2 = &amp;pImageBase[*(pImageBase &#43; 15)];
  result = &amp;v2[*(v2 &#43; 10) &#43; 24];
  v4 = *(v2 &#43; 3);
  if ( !v4 )
    return 0LL;
  v5 = &amp;result[(v4 - 1) &#43; 1];
  while ( result-&gt;VirtualAddress &gt; rva || rva &gt;= result-&gt;Misc.PhysicalAddress &#43; result-&gt;VirtualAddress )
  {
    if ( &#43;&#43;result == v5 )
      return 0LL;
  }
  return result;
}

//----- (0000000000402B40) ----------------------------------------------------
PIMAGE_SECTION_HEADER __fastcall FindPESectionByName(const char *pName)
{
  BYTE *v3; // rdx
  _IMAGE_SECTION_HEADER *v4; // rbx
  int v5; // edx
  __int64 v6; // rdi

  if ( strlen(pName) &gt; 8 )
    return 0LL;
  if ( *refptr___image_base__ != 23117 )
    return 0LL;
  if ( !ValidateImageBase_part_0(refptr___image_base__) )
    return 0LL;
  v3 = &amp;refptr___image_base__[*(refptr___image_base__ &#43; 15)];
  v4 = &amp;v3[*(v3 &#43; 10) &#43; 24];
  v5 = *(v3 &#43; 3);
  if ( !v5 )
    return 0LL;
  v6 = &amp;v4[(v5 - 1) &#43; 1];
  while ( strncmp(v4, pName, 8uLL) )
  {
    if ( &#43;&#43;v4 == v6 )
      return 0LL;
  }
  return v4;
}

//----- (0000000000402BE0) ----------------------------------------------------
PIMAGE_SECTION_HEADER __fastcall _mingw_GetSectionForAddress(LPVOID p)
{
  if ( *refptr___image_base__ == 23117 &amp;&amp; ValidateImageBase_part_0(refptr___image_base__) )
    return FindPESection(refptr___image_base__, p - refptr___image_base__);
  else
    return 0LL;
}

//----- (0000000000402C30) ----------------------------------------------------
int __cdecl _mingw_GetSectionCount()
{
  int result; // eax

  result = 0;
  if ( *refptr___image_base__ == 23117 )
  {
    result = ValidateImageBase_part_0(refptr___image_base__);
    if ( result )
      return *&amp;refptr___image_base__[*(refptr___image_base__ &#43; 15) &#43; 6];
  }
  return result;
}

//----- (0000000000402C70) ----------------------------------------------------
PIMAGE_SECTION_HEADER __fastcall FindPESectionExec(size_t eNo)
{
  BYTE *v3; // rsi
  __int64 v4; // rdx
  __int64 v5; // rax

  if ( *refptr___image_base__ != 23117 )
    return 0LL;
  if ( !ValidateImageBase_part_0(refptr___image_base__) )
    return 0LL;
  v3 = &amp;refptr___image_base__[*(refptr___image_base__ &#43; 15)];
  v4 = &amp;v3[*(v3 &#43; 10) &#43; 24];
  if ( !*(v3 &#43; 3) )
    return 0LL;
  v5 = v4 &#43; 40LL * (*(v3 &#43; 3) - 1) &#43; 40;
  while ( (*(v4 &#43; 39) &amp; 0x20) == 0 )
  {
LABEL_9:
    v4 &#43;= 40LL;
    if ( v4 == v5 )
      return 0LL;
  }
  if ( eNo )
  {
    --eNo;
    goto LABEL_9;
  }
  return v4;
}

//----- (0000000000402D00) ----------------------------------------------------
PBYTE __cdecl GetPEImageBase()
{
  BYTE *v0; // rbx

  v0 = 0LL;
  if ( *refptr___image_base__ != 23117 )
    return 0LL;
  if ( ValidateImageBase_part_0(refptr___image_base__) )
    return refptr___image_base__;
  return v0;
}

//----- (0000000000402D40) ----------------------------------------------------
WINBOOL __fastcall IsNonwritableInCurrentImage(PBYTE pTarget)
{
  WINBOOL result; // eax
  PIMAGE_SECTION_HEADER PESection; // rax

  result = 0;
  if ( *refptr___image_base__ == 23117 )
  {
    result = ValidateImageBase_part_0(refptr___image_base__);
    if ( result )
    {
      PESection = FindPESection(refptr___image_base__, pTarget - refptr___image_base__);
      return PESection &amp;&amp; (PESection-&gt;Characteristics &amp; 0x80000000) == 0;
    }
  }
  return result;
}

//----- (0000000000402DA0) ----------------------------------------------------
const char *__fastcall _mingw_enum_import_library_names(int i)
{
  unsigned int v3; // edx
  __int64 v4; // rbx
  BYTE *v5; // rdx

  if ( *refptr___image_base__ != 23117 )
    return 0LL;
  if ( !ValidateImageBase_part_0(refptr___image_base__) )
    return 0LL;
  v3 = *&amp;refptr___image_base__[*(refptr___image_base__ &#43; 15) &#43; 144];
  if ( !v3 )
    return 0LL;
  v4 = v3;
  if ( !FindPESection(refptr___image_base__, v3) )
    return 0LL;
  v5 = &amp;refptr___image_base__[v4];
  if ( !&amp;refptr___image_base__[v4] )
    return 0LL;
  while ( *(v5 &#43; 1) || *(v5 &#43; 3) )
  {
    if ( i &lt;= 0 )
      return &amp;refptr___image_base__[*(v5 &#43; 3)];
    --i;
    v5 &#43;= 20;
  }
  return 0LL;
}

//----- (0000000000402E50) ----------------------------------------------------
void __cdecl _mingwthr_run_key_dtors_part_0()
{
  volatile __mingwthr_key_t *i; // rbx
  LPVOID Value; // rsi

  EnterCriticalSection(&amp;_mingwthr_cs);
  for ( i = key_dtor_list; i; i = i-&gt;next )
  {
    Value = TlsGetValue(i-&gt;key);
    if ( !GetLastError() &amp;&amp; Value )
      i-&gt;dtor(Value);
  }
  LeaveCriticalSection(&amp;_mingwthr_cs);
}

//----- (0000000000402EC0) ----------------------------------------------------
int __fastcall __w64_mingwthr_add_key_dtor(DWORD key, void (*dtor)(void *))
{
  int result; // eax
  volatile __mingwthr_key_t *v5; // rax
  volatile __mingwthr_key_t *v6; // rbx
  volatile __mingwthr_key_t *v7; // rax

  result = _mingwthr_cs_init;
  if ( _mingwthr_cs_init )
  {
    v5 = calloc(1uLL, 0x18uLL);
    v6 = v5;
    if ( v5 )
    {
      v5-&gt;key = key;
      v5-&gt;dtor = dtor;
      EnterCriticalSection(&amp;_mingwthr_cs);
      v7 = key_dtor_list;
      key_dtor_list = v6;
      v6-&gt;next = v7;
      LeaveCriticalSection(&amp;_mingwthr_cs);
      return 0;
    }
    else
    {
      return -1;
    }
  }
  return result;
}

//----- (0000000000402F40) ----------------------------------------------------
int __fastcall __w64_mingwthr_remove_key_dtor(DWORD key)
{
  volatile __mingwthr_key_t *v3; // rdx
  volatile __mingwthr_key_t *next; // rax
  volatile __mingwthr_key_t *v5; // rcx

  if ( !_mingwthr_cs_init )
    return 0;
  EnterCriticalSection(&amp;_mingwthr_cs);
  v3 = key_dtor_list;
  if ( key_dtor_list )
  {
    if ( key_dtor_list-&gt;key == key )
    {
      v5 = key_dtor_list;
      key_dtor_list = key_dtor_list-&gt;next;
LABEL_12:
      free(v5);
      LeaveCriticalSection(&amp;_mingwthr_cs);
      return 0;
    }
    while ( 1 )
    {
      next = v3-&gt;next;
      if ( !next )
        break;
      if ( next-&gt;key == key )
      {
        v5 = v3-&gt;next;
        v3-&gt;next = next-&gt;next;
        goto LABEL_12;
      }
      v3 = v3-&gt;next;
    }
  }
  LeaveCriticalSection(&amp;_mingwthr_cs);
  return 0;
}

//----- (0000000000402FE0) ----------------------------------------------------
// local variable allocation has failed, the output may be wrong!
WINBOOL __fastcall _mingw_TLScallback(HANDLE hDllHandle, DWORD reason, LPVOID reserved)
{
  WINBOOL result; // eax

  if ( reason == 1 )
  {
    if ( !_mingwthr_cs_init )
      InitializeCriticalSection(&amp;_mingwthr_cs);
    result = 1;
    _mingwthr_cs_init = 1;
  }
  else
  {
    if ( reason )
    {
      if ( reason == 3 )
      {
        if ( _mingwthr_cs_init )
          _mingwthr_run_key_dtors_part_0();
      }
    }
    else
    {
      if ( _mingwthr_cs_init )
        _mingwthr_run_key_dtors_part_0();
      if ( _mingwthr_cs_init == 1 )
      {
        _mingwthr_cs_init = 0;
        _IAT_start__(&amp;_mingwthr_cs, *&amp;reason, reserved);
      }
    }
    return 1;
  }
  return result;
}
// 402FE0: variables would overlap: edx.4 and rdx.8
// 409268: using guessed type __int64 __fastcall _IAT_start__(_QWORD, _QWORD, _QWORD);

//----- (00000000004030E0) ----------------------------------------------------
void (*__cdecl get_invalid_parameter_handler())(const wchar_t *, const wchar_t *, const wchar_t *, unsigned int, uintptr_t)
{
  return handler;
}

//----- (00000000004030F0) ----------------------------------------------------
void (*__fastcall set_invalid_parameter_handler(
        void (*new_handler)(const wchar_t *, const wchar_t *, const wchar_t *, unsigned int, uintptr_t)))(const wchar_t *, const wchar_t *, const wchar_t *, unsigned int, uintptr_t)
{
  return _InterlockedExchange64(&amp;handler, new_handler);
}

// nfuncs=114 queued=48 decompiled=48 lumina nreq=0 worse=0 better=0
// ALL OK, 48 function(s) have been successfully decompiled
Exploit:">
</head>
<body><nav class="navbar is-transparent " role="navigation" aria-label="main navigation">
  <div class="navbar-brand">
    <a class="navbar-item" href="https://imlauera.github.io/">
      <figure class="image">
        <img alt="" class="is-rounded" src="/img/memememe.jpg">
      </figure>
    </a>
    <a class="navbar-item" href="https://imlauera.github.io/">
      Imlauer
    </a>
    <a class="navbar-item" href="/acerca/">
      Acerca de Mi
    </a>
  </div>
  
  
</nav>

  <section>
    <section class='hero is-small is-link is-fullwidth'>
      <div class="hero-body">
<div class="container">
  <h1 class="title">
    Keygen si puedes
  </h1>
  <h2 class="subtitle">
    <time datetime='2024-09-09T06:41:05-03:00'>
      September 09, 2024
    </time>
    
    <br>
    
    
    
    <a class="tag is-info" href="https://imlauera.github.io/tags/reversing/">Reversing</a>
    
    
    
    
    <a class="tag is-info" href="https://imlauera.github.io/tags/ida/">Ida</a>
    
    
    
  </h2>
</div>

      </div>
    </section>
    <section class="section">
      <div class="container">
<div class="content is-medium">
  <p>El keygen se encuentra en: <a href="https://drive.google.com/file/d/1QRIk3zBGGXH54nSZorX3jnuNmURCHw6K/view?pli=1">https://drive.google.com/file/d/1QRIk3zBGGXH54nSZorX3jnuNmURCHw6K/view?pli=1</a></p>
<p>El c贸digo que me gener贸 el ida es:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;windows.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;defs.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdarg.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//-------------------------------------------------------------------------
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Function declarations
</span></span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#66d9ef">__fastcall</span> <span style="color:#a6e22e">_mingw_invalidParameterHandler</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">wchar_t</span> <span style="color:#f92672">*</span>expression, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">wchar_t</span> <span style="color:#f92672">*</span>function, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">wchar_t</span> <span style="color:#f92672">*</span>file, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> line, <span style="color:#66d9ef">uintptr_t</span> pReserved);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#66d9ef">__cdecl</span> <span style="color:#a6e22e">pre_c_init</span>();
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#66d9ef">__cdecl</span> <span style="color:#a6e22e">pre_cpp_init</span>();
</span></span><span style="display:flex;"><span><span style="color:#75715e">// int __cdecl _tmainCRTStartup();
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// int __cdecl WinMainCRTStartup();
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#66d9ef">__cdecl</span> <span style="color:#a6e22e">mainCRTStartup</span>();
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">__fastcall</span> <span style="color:#a6e22e">generaLetras</span>(<span style="color:#66d9ef">int</span> a1, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>a2);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">__int64</span> <span style="color:#66d9ef">__fastcall</span> <span style="color:#a6e22e">generaNumero</span>(<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>a1); <span style="color:#75715e">// idb
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#66d9ef">__fastcall</span> <span style="color:#a6e22e">generaSerial</span>(<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>a1, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>a2);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#66d9ef">__fastcall</span> <span style="color:#a6e22e">checkSerial</span>(<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>a1, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>a2);
</span></span><span style="display:flex;"><span>INT_PTR <span style="color:#66d9ef">__fastcall</span> <span style="color:#a6e22e">DialogProc</span>(HWND a1, <span style="color:#66d9ef">int</span> a2, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">__int16</span> a3);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#66d9ef">__stdcall</span> <span style="color:#a6e22e">WinMain</span>(HINSTANCE hInst, HINSTANCE hPreInst, LPSTR lpszCmdLine, <span style="color:#66d9ef">int</span> nCmdShow);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">__fastcall</span> <span style="color:#a6e22e">decode_pointer</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>codedptr);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">__fastcall</span> <span style="color:#a6e22e">encode_pointer</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>ptr);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#66d9ef">__cdecl</span> <span style="color:#a6e22e">setargv</span>();
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#66d9ef">__fastcall</span> <span style="color:#a6e22e">_mingw_raise_matherr</span>(<span style="color:#66d9ef">int</span> typ, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>name, <span style="color:#66d9ef">double</span> a3, <span style="color:#66d9ef">double</span> a1, <span style="color:#66d9ef">double</span> rslt);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#66d9ef">__fastcall</span> <span style="color:#a6e22e">_mingw_setusermatherr</span>(<span style="color:#66d9ef">int</span> (<span style="color:#f92672">*</span>f)(_exception <span style="color:#f92672">*</span>));
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#66d9ef">__fastcall</span> <span style="color:#a6e22e">matherr</span>(_exception <span style="color:#f92672">*</span>pexcept);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">_report_error</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>msg, ...);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#66d9ef">__fastcall</span> <span style="color:#a6e22e">_write_memory_part_0</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>addr, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>src, <span style="color:#66d9ef">size_t</span> len);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#66d9ef">__cdecl</span> <span style="color:#a6e22e">pei386_runtime_relocator</span>();
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#66d9ef">__fastcall</span> <span style="color:#a6e22e">_mingw_SEH_error_handler</span>(_EXCEPTION_RECORD <span style="color:#f92672">*</span>ExceptionRecord, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>EstablisherFrame, _CONTEXT <span style="color:#f92672">*</span>ContextRecord, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>DispatcherContext);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#66d9ef">__cdecl</span> <span style="color:#a6e22e">_mingw_init_ehandler</span>();
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#66d9ef">__fastcall</span> <span style="color:#a6e22e">gnu_exception_handler</span>(EXCEPTION_POINTERS <span style="color:#f92672">*</span>exception_data);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#66d9ef">__cdecl</span> <span style="color:#a6e22e">fpreset</span>();
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#66d9ef">__cdecl</span> <span style="color:#a6e22e">_do_global_dtors</span>();
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#66d9ef">__cdecl</span> <span style="color:#a6e22e">_do_global_ctors</span>();
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#66d9ef">__cdecl</span> <span style="color:#a6e22e">_main</span>();
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#66d9ef">__cdecl</span> <span style="color:#a6e22e">_security_init_cookie</span>();
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#66d9ef">__fastcall</span> <span style="color:#a6e22e">_report_gsfailure</span>(ULONG_PTR StackCookie);
</span></span><span style="display:flex;"><span>BOOL <span style="color:#66d9ef">__fastcall</span> <span style="color:#a6e22e">_dyn_tls_dtor</span>(HANDLE hDllHandle, DWORD dwReason, LPVOID lpreserved);
</span></span><span style="display:flex;"><span>BOOL <span style="color:#66d9ef">__fastcall</span> <span style="color:#a6e22e">_dyn_tls_init</span>(HANDLE hDllHandle, DWORD dwReason, LPVOID lpreserved);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#66d9ef">__fastcall</span> <span style="color:#a6e22e">_tlregdtor</span>(_PVFV func);
</span></span><span style="display:flex;"><span>_onexit_t <span style="color:#66d9ef">__fastcall</span> <span style="color:#a6e22e">mingw_onexit</span>(_onexit_t func);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#66d9ef">__fastcall</span> <span style="color:#a6e22e">atexit</span>(_PVFV func);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#66d9ef">__cdecl</span> <span style="color:#a6e22e">my_lconv_init</span>();
</span></span><span style="display:flex;"><span>WINBOOL <span style="color:#66d9ef">__fastcall</span> <span style="color:#a6e22e">ValidateImageBase_part_0</span>(PBYTE pImageBase);
</span></span><span style="display:flex;"><span>WINBOOL <span style="color:#66d9ef">__fastcall</span> <span style="color:#a6e22e">ValidateImageBase</span>(PBYTE pImageBase);
</span></span><span style="display:flex;"><span>PIMAGE_SECTION_HEADER <span style="color:#66d9ef">__fastcall</span> <span style="color:#a6e22e">FindPESection</span>(PBYTE pImageBase, DWORD_PTR rva);
</span></span><span style="display:flex;"><span>PIMAGE_SECTION_HEADER <span style="color:#66d9ef">__fastcall</span> <span style="color:#a6e22e">FindPESectionByName</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>pName);
</span></span><span style="display:flex;"><span>PIMAGE_SECTION_HEADER <span style="color:#66d9ef">__fastcall</span> <span style="color:#a6e22e">_mingw_GetSectionForAddress</span>(LPVOID p);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#66d9ef">__cdecl</span> <span style="color:#a6e22e">_mingw_GetSectionCount</span>();
</span></span><span style="display:flex;"><span>PIMAGE_SECTION_HEADER <span style="color:#66d9ef">__fastcall</span> <span style="color:#a6e22e">FindPESectionExec</span>(<span style="color:#66d9ef">size_t</span> eNo);
</span></span><span style="display:flex;"><span>PBYTE <span style="color:#66d9ef">__cdecl</span> <span style="color:#a6e22e">GetPEImageBase</span>();
</span></span><span style="display:flex;"><span>WINBOOL <span style="color:#66d9ef">__fastcall</span> <span style="color:#a6e22e">IsNonwritableInCurrentImage</span>(PBYTE pTarget);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">__fastcall</span> <span style="color:#a6e22e">_mingw_enum_import_library_names</span>(<span style="color:#66d9ef">int</span> i);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#66d9ef">__cdecl</span> <span style="color:#a6e22e">_mingwthr_run_key_dtors_part_0</span>();
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#66d9ef">__fastcall</span> <span style="color:#a6e22e">__w64_mingwthr_add_key_dtor</span>(DWORD key, <span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>dtor)(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>));
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#66d9ef">__fastcall</span> <span style="color:#a6e22e">__w64_mingwthr_remove_key_dtor</span>(DWORD key);
</span></span><span style="display:flex;"><span>WINBOOL <span style="color:#66d9ef">__fastcall</span> <span style="color:#a6e22e">_mingw_TLScallback</span>(HANDLE hDllHandle, DWORD reason, LPVOID reserved);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// void __cdecl _set_app_type(_crt_app_type Type);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// __int64 __fastcall _getmainargs(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span><span style="color:#66d9ef">__cdecl</span> <span style="color:#a6e22e">get_invalid_parameter_handler</span>())(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">wchar_t</span> <span style="color:#f92672">*</span>, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">wchar_t</span> <span style="color:#f92672">*</span>, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">wchar_t</span> <span style="color:#f92672">*</span>, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">uintptr_t</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span><span style="color:#66d9ef">__fastcall</span> <span style="color:#a6e22e">set_invalid_parameter_handler</span>(<span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>new_handler)(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">wchar_t</span> <span style="color:#f92672">*</span>, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">wchar_t</span> <span style="color:#f92672">*</span>, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">wchar_t</span> <span style="color:#f92672">*</span>, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">uintptr_t</span>)))(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">wchar_t</span> <span style="color:#f92672">*</span>, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">wchar_t</span> <span style="color:#f92672">*</span>, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">wchar_t</span> <span style="color:#f92672">*</span>, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">uintptr_t</span>);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// void *__cdecl malloc(size_t Size);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// size_t __cdecl strlen(const char *Str);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// void *__cdecl memcpy(void *, const void *Src, size_t Size);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// void __cdecl cexit();
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// __int64 __fastcall amsg_exit(_QWORD); weak
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// void __cdecl initterm(_PVFV *First, _PVFV *Last);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// void __cdecl __noreturn exit(int Code);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// int printf(const char *const Format, ...);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// int sprintf(char *const Buffer, const char *const Format, ...);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// void __cdecl _setusermatherr(_UserMathErrorFunctionPointer UserMathErrorFunction);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// FILE *__cdecl _iob_func();
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// int fprintf(FILE *const Stream, const char *const Format, ...);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// size_t __cdecl fwrite(const void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// int __cdecl vfprintf(FILE *const Stream, const char *const Format, va_list ArgList);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// void __cdecl __noreturn abort();
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// _crt_signal_t __cdecl signal(int Signal, _crt_signal_t Function);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// __int64 __fastcall lock(_QWORD); weak
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// __int64 __fastcall _dllonexit(_QWORD, _QWORD, _QWORD); weak
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// __int64 __fastcall unlock(_QWORD); weak
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// int __cdecl strncmp(const char *Str1, const char *Str2, size_t MaxCount);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// void *__cdecl calloc(size_t Count, size_t Size);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// void __cdecl free(void *Block);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// int __fastcall main(int flags, char **cmdline, char **inst); idb
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// __int64 __fastcall _IAT_start__(_QWORD, _QWORD, _QWORD); weak
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// __int64 __lconv_init(void); weak
</span></span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//-------------------------------------------------------------------------
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Data declarations
</span></span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>func_ptr <span style="color:#f92672">*</span>p_73208 <span style="color:#f92672">=</span> (func_ptr <span style="color:#f92672">*</span>)<span style="color:#ae81ff">0x403338LL</span>; <span style="color:#75715e">// idb
</span></span></span><span style="display:flex;"><span>UINT_PTR _security_cookie <span style="color:#f92672">=</span> <span style="color:#ae81ff">47936899621426uLL</span>; <span style="color:#75715e">// idb
</span></span></span><span style="display:flex;"><span>UINT_PTR _security_cookie_complement <span style="color:#f92672">=</span> <span style="color:#ae81ff">18446696136809930189uLL</span>; <span style="color:#75715e">// idb
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">char</span> aSfmsilqzdxajhn[<span style="color:#ae81ff">53</span>] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;sfMSiLQzdXajhnZKrPyAoHbTDNREWtuVOcGIxkYemgBClvwFUpqJ&#34;</span>; <span style="color:#75715e">// weak
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> EXCEPTION_POINTERS GS_ExceptionPointers <span style="color:#f92672">=</span> { <span style="color:#f92672">&amp;</span>GS_ExceptionRecord, <span style="color:#f92672">&amp;</span>GS_ContextRecord }; <span style="color:#75715e">// idb
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>refptr__CRT_MT <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>CRT_MT; <span style="color:#75715e">// weak
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>refptr__MINGW_INSTALL_DEBUG_MATHERR <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>MINGW_INSTALL_DEBUG_MATHERR; <span style="color:#75715e">// weak
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">__int64</span> (<span style="color:#f92672">*</span>refptr___CTOR_LIST__)[<span style="color:#ae81ff">2</span>] <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>__CTOR_LIST__; <span style="color:#75715e">// weak
</span></span></span><span style="display:flex;"><span>_UNKNOWN <span style="color:#f92672">*</span>refptr___RUNTIME_PSEUDO_RELOC_LIST_END__ <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>_RUNTIME_PSEUDO_RELOC_LIST_END___0; <span style="color:#75715e">// weak
</span></span></span><span style="display:flex;"><span>_UNKNOWN <span style="color:#f92672">*</span>refptr___RUNTIME_PSEUDO_RELOC_LIST__ <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>_RUNTIME_PSEUDO_RELOC_LIST_END___0; <span style="color:#75715e">// weak
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> PBYTE refptr___image_base__ <span style="color:#f92672">=</span> (<span style="color:#66d9ef">const</span> PBYTE)<span style="color:#ae81ff">0x400000LL</span>; <span style="color:#75715e">// idb
</span></span></span><span style="display:flex;"><span>_UNKNOWN <span style="color:#f92672">*</span>refptr___imp__fmode <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>_fmode; <span style="color:#75715e">// weak
</span></span></span><span style="display:flex;"><span>_UNKNOWN <span style="color:#f92672">*</span>refptr___imp__onexit <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>_onexit; <span style="color:#75715e">// weak
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">__int64</span> <span style="color:#f92672">*</span>refptr___onexitbegin <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>_onexitbegin; <span style="color:#75715e">// weak
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">__int64</span> <span style="color:#f92672">*</span>refptr___onexitend <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>_onexitend; <span style="color:#75715e">// weak
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>refptr__dowildcard <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>dowildcard; <span style="color:#75715e">// weak
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>refptr__fmode <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>fmode; <span style="color:#75715e">// weak
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>refptr__newmode <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>newmode; <span style="color:#75715e">// weak
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>refptr_mingw_app_type <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>mingw_app_type; <span style="color:#75715e">// weak
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>refptr_mingw_initcharmax <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>mingw_initcharmax; <span style="color:#75715e">// weak
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>refptr_mingw_initltsdrot_force <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>mingw_initltsdrot_force; <span style="color:#75715e">// weak
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>refptr_mingw_initltsdyn_force <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>mingw_initltsdyn_force; <span style="color:#75715e">// weak
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>refptr_mingw_initltssuo_force <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>mingw_initltssuo_force; <span style="color:#75715e">// weak
</span></span></span><span style="display:flex;"><span>_startupinfo _bss_start__; <span style="color:#75715e">// idb
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> managedapp; <span style="color:#75715e">// idb
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> argret; <span style="color:#75715e">// idb
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">char</span> <span style="color:#f92672">**</span>envp; <span style="color:#75715e">// idb
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">char</span> <span style="color:#f92672">**</span>argv; <span style="color:#75715e">// idb
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> argc; <span style="color:#75715e">// idb
</span></span></span><span style="display:flex;"><span>fUserMathErr stUserMathErr; <span style="color:#75715e">// idb
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> was_init_73980; <span style="color:#75715e">// idb
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> maxSections; <span style="color:#75715e">// idb
</span></span></span><span style="display:flex;"><span>sSecInfo <span style="color:#f92672">*</span>the_secs; <span style="color:#75715e">// idb
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> was_here_73812; <span style="color:#75715e">// idb
</span></span></span><span style="display:flex;"><span>UNWIND_INFO emu_xdata[<span style="color:#ae81ff">32</span>]; <span style="color:#75715e">// idb
</span></span></span><span style="display:flex;"><span>RUNTIME_FUNCTION emu_pdata[<span style="color:#ae81ff">32</span>]; <span style="color:#75715e">// idb
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> initialized; <span style="color:#75715e">// idb
</span></span></span><span style="display:flex;"><span>CONTEXT GS_ContextRecord; <span style="color:#75715e">// idb
</span></span></span><span style="display:flex;"><span>EXCEPTION_RECORD GS_ExceptionRecord; <span style="color:#75715e">// idb
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">volatile</span> __mingwthr_key_t <span style="color:#f92672">*</span>key_dtor_list; <span style="color:#75715e">// idb
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">volatile</span> <span style="color:#66d9ef">int</span> _mingwthr_cs_init; <span style="color:#75715e">// idb
</span></span></span><span style="display:flex;"><span>CRITICAL_SECTION _mingwthr_cs; <span style="color:#75715e">// idb
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>handler)(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">wchar_t</span> <span style="color:#f92672">*</span>, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">wchar_t</span> <span style="color:#f92672">*</span>, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">wchar_t</span> <span style="color:#f92672">*</span>, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">uintptr_t</span>); <span style="color:#75715e">// idb
</span></span></span><span style="display:flex;"><span>_PVFV <span style="color:#f92672">*</span>_onexitbegin; <span style="color:#75715e">// idb
</span></span></span><span style="display:flex;"><span>_PVFV <span style="color:#f92672">*</span>_onexitend; <span style="color:#75715e">// idb
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// extern void (__stdcall *EnterCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// extern HANDLE (__stdcall *GetCurrentProcess)();
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// extern DWORD (__stdcall *GetCurrentProcessId)();
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// extern DWORD (__stdcall *GetCurrentThreadId)();
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// extern DWORD (__stdcall *GetLastError)();
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// extern void (__stdcall *GetSystemTimeAsFileTime)(LPFILETIME lpSystemTimeAsFileTime);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// extern DWORD (__stdcall *GetTickCount)();
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// extern void (__stdcall *InitializeCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// extern void (__stdcall *LeaveCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// extern BOOL (__stdcall *QueryPerformanceCounter)(LARGE_INTEGER *lpPerformanceCount);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// extern BOOLEAN (__cdecl *RtlAddFunctionTable)(PRUNTIME_FUNCTION FunctionTable, ULONG EntryCount, ULONG64 BaseAddress);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// extern void (__stdcall *RtlCaptureContext)(PCONTEXT ContextRecord);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// extern PRUNTIME_FUNCTION (__stdcall *RtlLookupFunctionEntry)(ULONG64 ControlPc, PULONG64 ImageBase, PUNWIND_HISTORY_TABLE HistoryTable);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// extern PEXCEPTION_ROUTINE (__stdcall *RtlVirtualUnwind)(ULONG HandlerType, ULONG64 ImageBase, ULONG64 ControlPc, PRUNTIME_FUNCTION FunctionEntry, PCONTEXT ContextRecord, PVOID *HandlerData, PULONG64 EstablisherFrame, PKNONVOLATILE_CONTEXT_POINTERS ContextPointers);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// extern LPTOP_LEVEL_EXCEPTION_FILTER (__stdcall *SetUnhandledExceptionFilter)(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// extern BOOL (__stdcall *TerminateProcess)(HANDLE hProcess, UINT uExitCode);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// extern LPVOID (__stdcall *TlsGetValue)(DWORD dwTlsIndex);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// extern LONG (__stdcall *UnhandledExceptionFilter)(struct _EXCEPTION_POINTERS *ExceptionInfo);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// extern BOOL (__stdcall *VirtualProtect)(LPVOID lpAddress, SIZE_T dwSize, DWORD flNewProtect, PDWORD lpflOldProtect);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// extern SIZE_T (__stdcall *VirtualQuery)(LPCVOID lpAddress, PMEMORY_BASIC_INFORMATION lpBuffer, SIZE_T dwLength);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// extern HWND (__stdcall *CreateDialogParamA)(HINSTANCE hInstance, LPCSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// extern LRESULT (__stdcall *DispatchMessageA)(const MSG *lpMsg);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// extern BOOL (__stdcall *EndDialog)(HWND hDlg, INT_PTR nResult);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// extern UINT (__stdcall *GetDlgItemTextA)(HWND hDlg, int nIDDlgItem, LPSTR lpString, int cchMax);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// extern BOOL (__stdcall *GetMessageA)(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// extern BOOL (__stdcall *IsDialogMessageA)(HWND hDlg, LPMSG lpMsg);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// extern HMENU (__stdcall *LoadMenuA)(HINSTANCE hInstance, LPCSTR lpMenuName);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// extern int (__stdcall *MessageBoxA)(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// extern BOOL (__stdcall *SetMenu)(HWND hWnd, HMENU hMenu);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// extern BOOL (__stdcall *ShowWindow)(HWND hWnd, int nCmdShow);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// extern BOOL (__stdcall *TranslateMessage)(const MSG *lpMsg);
</span></span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//----- (0000000000401010) ----------------------------------------------------
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#66d9ef">__cdecl</span> <span style="color:#a6e22e">pre_c_init</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  _BOOL8 v0; <span style="color:#75715e">// rdx
</span></span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>v1; <span style="color:#75715e">// rax
</span></span></span><span style="display:flex;"><span>  BYTE <span style="color:#f92672">*</span>v3; <span style="color:#75715e">// rax
</span></span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">__int16</span> v4; <span style="color:#75715e">// cx
</span></span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">LODWORD</span>(v0) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">*</span>refptr_mingw_initltsdrot_force <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">*</span>refptr_mingw_initltsdyn_force <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">*</span>refptr_mingw_initltssuo_force <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">*</span>refptr_mingw_initcharmax <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> ( <span style="color:#f92672">*</span>refptr___image_base__ <span style="color:#f92672">==</span> <span style="color:#ae81ff">23117</span> )
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    v3 <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>refptr___image_base__[<span style="color:#f92672">*</span>(refptr___image_base__ <span style="color:#f92672">+</span> <span style="color:#ae81ff">15</span>)];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ( <span style="color:#f92672">*</span>v3 <span style="color:#f92672">==</span> <span style="color:#ae81ff">17744</span> )
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>      v4 <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>(v3 <span style="color:#f92672">+</span> <span style="color:#ae81ff">12</span>);
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> ( v4 <span style="color:#f92672">==</span> <span style="color:#ae81ff">267</span> )
</span></span><span style="display:flex;"><span>      {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> ( <span style="color:#f92672">*</span>(v3 <span style="color:#f92672">+</span> <span style="color:#ae81ff">29</span>) <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0xEu</span> )
</span></span><span style="display:flex;"><span>          v0 <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>(v3 <span style="color:#f92672">+</span> <span style="color:#ae81ff">58</span>) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> ( v4 <span style="color:#f92672">==</span> <span style="color:#ae81ff">523</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">*</span>(v3 <span style="color:#f92672">+</span> <span style="color:#ae81ff">33</span>) <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0xEu</span> )
</span></span><span style="display:flex;"><span>      {
</span></span><span style="display:flex;"><span>        v0 <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>(v3 <span style="color:#f92672">+</span> <span style="color:#ae81ff">62</span>) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  managedapp <span style="color:#f92672">=</span> v0;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> ( <span style="color:#f92672">*</span>refptr_mingw_app_type )
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">_set_app_type</span>(_crt_gui_app);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">_set_app_type</span>(_crt_console_app);
</span></span><span style="display:flex;"><span>  v1 <span style="color:#f92672">=</span> <span style="color:#a6e22e">encode_pointer</span>(<span style="color:#ae81ff">0xFFFFFFFFFFFFFFFFLL</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">*</span>refptr___onexitend <span style="color:#f92672">=</span> v1;
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">*</span>refptr___onexitbegin <span style="color:#f92672">=</span> v1;
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">**</span>refptr___imp__fmode <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>refptr__fmode;
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">setargv</span>();
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> ( <span style="color:#f92672">*</span>refptr__MINGW_INSTALL_DEBUG_MATHERR <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> )
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">_mingw_setusermatherr</span>(matherr);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 405370: using guessed type int *refptr__MINGW_INSTALL_DEBUG_MATHERR;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 4053F0: using guessed type _UNKNOWN *refptr___imp__fmode;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 405470: using guessed type __int64 *refptr___onexitbegin;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 405480: using guessed type __int64 *refptr___onexitend;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 4054E0: using guessed type int *refptr__fmode;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 405520: using guessed type int *refptr_mingw_app_type;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 405530: using guessed type int *refptr_mingw_initcharmax;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 405540: using guessed type int *refptr_mingw_initltsdrot_force;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 405550: using guessed type int *refptr_mingw_initltsdyn_force;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 405560: using guessed type int *refptr_mingw_initltssuo_force;
</span></span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//----- (0000000000401160) ----------------------------------------------------
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#66d9ef">__cdecl</span> <span style="color:#a6e22e">pre_cpp_init</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  _bss_start__.newmode <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>refptr__newmode;
</span></span><span style="display:flex;"><span>  argret <span style="color:#f92672">=</span> <span style="color:#a6e22e">_getmainargs</span>(<span style="color:#f92672">&amp;</span>argc, <span style="color:#f92672">&amp;</span>argv, <span style="color:#f92672">&amp;</span>envp, <span style="color:#f92672">*</span>refptr__dowildcard, <span style="color:#f92672">&amp;</span>_bss_start__);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 4030D0: using guessed type __int64 __fastcall _getmainargs(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 4054D0: using guessed type int *refptr__dowildcard;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 405510: using guessed type int *refptr__newmode;
</span></span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//----- (0000000000401500) ----------------------------------------------------
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#66d9ef">__cdecl</span> <span style="color:#a6e22e">mainCRTStartup</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">*</span>refptr_mingw_app_type <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">_security_init_cookie</span>();
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">_tmainCRTStartup</span>();
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 405520: using guessed type int *refptr_mingw_app_type;
</span></span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//----- (0000000000401530) ----------------------------------------------------
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">__fastcall</span> <span style="color:#a6e22e">generaLetras</span>(<span style="color:#66d9ef">int</span> a1, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>a2)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">size_t</span> v2; <span style="color:#75715e">// rax
</span></span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>result; <span style="color:#75715e">// rax
</span></span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> v4; <span style="color:#75715e">// [rsp+28h] [rbp-58h]
</span></span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> v5; <span style="color:#75715e">// [rsp+2Ch] [rbp-54h]
</span></span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> v6; <span style="color:#75715e">// [rsp+30h] [rbp-50h]
</span></span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> v7; <span style="color:#75715e">// [rsp+34h] [rbp-4Ch]
</span></span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  v7 <span style="color:#f92672">=</span> (a1 <span style="color:#f92672">+</span> <span style="color:#ae81ff">15</span>) <span style="color:#f92672">%</span> <span style="color:#a6e22e">strlen</span>(<span style="color:#e6db74">&#34;sfMSiLQzdXajhnZKrPyAoHbTDNREWtuVOcGIxkYemgBClvwFUpqJ&#34;</span>);
</span></span><span style="display:flex;"><span>  v6 <span style="color:#f92672">=</span> (a1 <span style="color:#f92672">+</span> <span style="color:#ae81ff">22</span>) <span style="color:#f92672">%</span> <span style="color:#a6e22e">strlen</span>(<span style="color:#e6db74">&#34;sfMSiLQzdXajhnZKrPyAoHbTDNREWtuVOcGIxkYemgBClvwFUpqJ&#34;</span>);
</span></span><span style="display:flex;"><span>  v5 <span style="color:#f92672">=</span> (a1 <span style="color:#f92672">+</span> <span style="color:#ae81ff">32</span>) <span style="color:#f92672">%</span> <span style="color:#a6e22e">strlen</span>(<span style="color:#e6db74">&#34;sfMSiLQzdXajhnZKrPyAoHbTDNREWtuVOcGIxkYemgBClvwFUpqJ&#34;</span>);
</span></span><span style="display:flex;"><span>  v4 <span style="color:#f92672">=</span> (a1 <span style="color:#f92672">+</span> <span style="color:#ae81ff">17</span>) <span style="color:#f92672">%</span> <span style="color:#a6e22e">strlen</span>(<span style="color:#e6db74">&#34;sfMSiLQzdXajhnZKrPyAoHbTDNREWtuVOcGIxkYemgBClvwFUpqJ&#34;</span>);
</span></span><span style="display:flex;"><span>  v2 <span style="color:#f92672">=</span> <span style="color:#a6e22e">strlen</span>(<span style="color:#e6db74">&#34;sfMSiLQzdXajhnZKrPyAoHbTDNREWtuVOcGIxkYemgBClvwFUpqJ&#34;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">*</span>a2 <span style="color:#f92672">=</span> aSfmsilqzdxajhn[v7];
</span></span><span style="display:flex;"><span>  a2[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> aSfmsilqzdxajhn[v6];
</span></span><span style="display:flex;"><span>  a2[<span style="color:#ae81ff">2</span>] <span style="color:#f92672">=</span> aSfmsilqzdxajhn[v5];
</span></span><span style="display:flex;"><span>  a2[<span style="color:#ae81ff">3</span>] <span style="color:#f92672">=</span> aSfmsilqzdxajhn[v4];
</span></span><span style="display:flex;"><span>  a2[<span style="color:#ae81ff">4</span>] <span style="color:#f92672">=</span> aSfmsilqzdxajhn[((a1 <span style="color:#f92672">+</span> <span style="color:#ae81ff">4</span>) <span style="color:#f92672">%</span> v2)];
</span></span><span style="display:flex;"><span>  result <span style="color:#f92672">=</span> a2 <span style="color:#f92672">+</span> <span style="color:#ae81ff">5</span>;
</span></span><span style="display:flex;"><span>  a2[<span style="color:#ae81ff">5</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//----- (00000000004016AD) ----------------------------------------------------
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">__int64</span> <span style="color:#66d9ef">__fastcall</span> <span style="color:#a6e22e">generaNumero</span>(<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>a1)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> i; <span style="color:#75715e">// [rsp+28h] [rbp-58h]
</span></span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> v3; <span style="color:#75715e">// [rsp+2Ch] [rbp-54h]
</span></span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  v3 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> ( i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#a6e22e">strlen</span>(a1); <span style="color:#f92672">++</span>i )
</span></span><span style="display:flex;"><span>    v3 <span style="color:#f92672">+=</span> a1[i];
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Numero: %d&#34;</span>, v3 <span style="color:#f92672">+</span> <span style="color:#ae81ff">6572</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> (v3 <span style="color:#f92672">+</span> <span style="color:#ae81ff">6572</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//----- (0000000000401746) ----------------------------------------------------
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#66d9ef">__fastcall</span> <span style="color:#a6e22e">generaSerial</span>(<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>a1, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>a2)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">char</span> v3[<span style="color:#ae81ff">16</span>]; <span style="color:#75715e">// [rsp+40h] [rbp-50h] BYREF
</span></span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">char</span> v4[<span style="color:#ae81ff">16</span>]; <span style="color:#75715e">// [rsp+50h] [rbp-40h] BYREF
</span></span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">char</span> v5[<span style="color:#ae81ff">16</span>]; <span style="color:#75715e">// [rsp+60h] [rbp-30h] BYREF
</span></span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">char</span> v6[<span style="color:#ae81ff">16</span>]; <span style="color:#75715e">// [rsp+70h] [rbp-20h] BYREF
</span></span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">char</span> v7[<span style="color:#ae81ff">12</span>]; <span style="color:#75715e">// [rsp+80h] [rbp-10h] BYREF
</span></span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> v8; <span style="color:#75715e">// [rsp+8Ch] [rbp-4h]
</span></span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  v8 <span style="color:#f92672">=</span> <span style="color:#a6e22e">generaNumero</span>(a1);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">generaLetras</span>(v8, v7);
</span></span><span style="display:flex;"><span>  v8 <span style="color:#f92672">=</span> <span style="color:#a6e22e">generaNumero</span>(v7);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">generaLetras</span>(v8, v6);
</span></span><span style="display:flex;"><span>  v8 <span style="color:#f92672">=</span> <span style="color:#a6e22e">generaNumero</span>(v6);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">generaLetras</span>(v8, v5);
</span></span><span style="display:flex;"><span>  v8 <span style="color:#f92672">=</span> <span style="color:#a6e22e">generaNumero</span>(v5);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">generaLetras</span>(v8, v4);
</span></span><span style="display:flex;"><span>  v8 <span style="color:#f92672">=</span> <span style="color:#a6e22e">generaNumero</span>(v4);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">generaLetras</span>(v8, v3);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">sprintf</span>(a2, <span style="color:#e6db74">&#34;%s-%s-%s-%s-%s&#34;</span>, v7, v6, v5, v4, v3);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//----- (000000000040182D) ----------------------------------------------------
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#66d9ef">__fastcall</span> <span style="color:#a6e22e">checkSerial</span>(<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>a1, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>a2)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">size_t</span> v2; <span style="color:#75715e">// rbx
</span></span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">size_t</span> v3; <span style="color:#75715e">// rax
</span></span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> i; <span style="color:#75715e">// [rsp+28h] [rbp-58h]
</span></span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">char</span> v6; <span style="color:#75715e">// [rsp+2Fh] [rbp-51h]
</span></span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  v6 <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  v2 <span style="color:#f92672">=</span> <span style="color:#a6e22e">strlen</span>(a1);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> ( v2 <span style="color:#f92672">==</span> <span style="color:#a6e22e">strlen</span>(a2) )
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> ( i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; ; <span style="color:#f92672">++</span>i )
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>      v3 <span style="color:#f92672">=</span> <span style="color:#a6e22e">strlen</span>(a2);
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> ( i <span style="color:#f92672">&gt;=</span> v3 )
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> ( a1[i] <span style="color:#f92672">!=</span> a2[i] )
</span></span><span style="display:flex;"><span>      {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">LODWORD</span>(v3) <span style="color:#f92672">=</span> <span style="color:#a6e22e">MessageBoxA</span>(<span style="color:#ae81ff">0LL</span>, <span style="color:#e6db74">&#34;Nope sigue intentando&#34;</span>, <span style="color:#e6db74">&#34;Nop&#34;</span>, <span style="color:#ae81ff">0x30u</span>);
</span></span><span style="display:flex;"><span>        v6 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ( v6 )
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">LODWORD</span>(v3) <span style="color:#f92672">=</span> <span style="color:#a6e22e">MessageBoxA</span>(<span style="color:#ae81ff">0LL</span>, <span style="color:#e6db74">&#34;Genial lo lograste&#34;</span>, <span style="color:#e6db74">&#34;Felicitaciones&#34;</span>, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">MessageBoxA</span>(<span style="color:#ae81ff">0LL</span>, <span style="color:#e6db74">&#34;Nope sigue intentando&#34;</span>, <span style="color:#e6db74">&#34;Nop&#34;</span>, <span style="color:#ae81ff">0x30u</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">LODWORD</span>(v3) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> v3;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//----- (000000000040192F) ----------------------------------------------------
</span></span></span><span style="display:flex;"><span>INT_PTR <span style="color:#66d9ef">__fastcall</span> <span style="color:#a6e22e">DialogProc</span>(HWND a1, <span style="color:#66d9ef">int</span> a2, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">__int16</span> a3)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">char</span> v4[<span style="color:#ae81ff">32</span>]; <span style="color:#75715e">// [rsp+20h] [rbp-60h] BYREF
</span></span></span><span style="display:flex;"><span>  CHAR v5[<span style="color:#ae81ff">32</span>]; <span style="color:#75715e">// [rsp+40h] [rbp-40h] BYREF
</span></span></span><span style="display:flex;"><span>  CHAR String[<span style="color:#ae81ff">28</span>]; <span style="color:#75715e">// [rsp+60h] [rbp-20h] BYREF
</span></span></span><span style="display:flex;"><span>  UINT DlgItemTextA; <span style="color:#75715e">// [rsp+7Ch] [rbp-4h]
</span></span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  DlgItemTextA <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">switch</span> ( a2 )
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">272</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1LL</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">273</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> ( a3 <span style="color:#f92672">==</span> <span style="color:#ae81ff">40000</span> )
</span></span><span style="display:flex;"><span>      {
</span></span><span style="display:flex;"><span>        DlgItemTextA <span style="color:#f92672">=</span> <span style="color:#a6e22e">GetDlgItemTextA</span>(a1, <span style="color:#ae81ff">40002</span>, String, <span style="color:#ae81ff">20</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> ( DlgItemTextA )
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>          DlgItemTextA <span style="color:#f92672">=</span> <span style="color:#a6e22e">GetDlgItemTextA</span>(a1, <span style="color:#ae81ff">40003</span>, v5, <span style="color:#ae81ff">30</span>);
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">if</span> ( DlgItemTextA )
</span></span><span style="display:flex;"><span>          {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">generaSerial</span>(String, v4);
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">checkSerial</span>(v5, v4);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1LL</span>;
</span></span><span style="display:flex;"><span>          }
</span></span><span style="display:flex;"><span>          <span style="color:#a6e22e">MessageBoxA</span>(a1, <span style="color:#e6db74">&#34;Nope sigue intentando&#34;</span>, <span style="color:#e6db74">&#34;Nop&#34;</span>, <span style="color:#ae81ff">0x30u</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>          <span style="color:#a6e22e">MessageBoxA</span>(a1, <span style="color:#e6db74">&#34;Nope sigue intentando&#34;</span>, <span style="color:#e6db74">&#34;Nop&#34;</span>, <span style="color:#ae81ff">0x30u</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> ( a3 <span style="color:#f92672">==</span> <span style="color:#ae81ff">40006</span> )
</span></span><span style="display:flex;"><span>      {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">MessageBoxA</span>(a1, <span style="color:#e6db74">&#34;keygeneame si puedes</span><span style="color:#ae81ff">\n\n</span><span style="color:#e6db74">El objetivo es crear el keygen sin parchear nada&#34;</span>, <span style="color:#e6db74">&#34;About&#34;</span>, <span style="color:#ae81ff">0x40u</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1LL</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1LL</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">16</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">EndDialog</span>(a1, <span style="color:#ae81ff">0LL</span>);
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1LL</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">default</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0LL</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//----- (0000000000401AA6) ----------------------------------------------------
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#66d9ef">__stdcall</span> <span style="color:#a6e22e">WinMain</span>(HINSTANCE hInst, HINSTANCE hPreInst, LPSTR lpszCmdLine, <span style="color:#66d9ef">int</span> nCmdShow)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  tagMSG Msg; <span style="color:#75715e">// [rsp+30h] [rbp-40h] BYREF
</span></span></span><span style="display:flex;"><span>  HMENU hMenu; <span style="color:#75715e">// [rsp+60h] [rbp-10h]
</span></span></span><span style="display:flex;"><span>  HWND hWnd; <span style="color:#75715e">// [rsp+68h] [rbp-8h]
</span></span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  hWnd <span style="color:#f92672">=</span> <span style="color:#a6e22e">CreateDialogParamA</span>(hInst, <span style="color:#ae81ff">102</span>, <span style="color:#ae81ff">0LL</span>, DialogProc, <span style="color:#ae81ff">0LL</span>);
</span></span><span style="display:flex;"><span>  hMenu <span style="color:#f92672">=</span> <span style="color:#a6e22e">LoadMenuA</span>(hInst, <span style="color:#ae81ff">0x69</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">SetMenu</span>(hWnd, hMenu);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">ShowWindow</span>(hWnd, <span style="color:#ae81ff">10</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">while</span> ( <span style="color:#a6e22e">GetMessageA</span>(<span style="color:#f92672">&amp;</span>Msg, <span style="color:#ae81ff">0LL</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>) <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> )
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ( <span style="color:#f92672">!</span><span style="color:#a6e22e">IsDialogMessageA</span>(hWnd, <span style="color:#f92672">&amp;</span>Msg) )
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">TranslateMessage</span>(<span style="color:#f92672">&amp;</span>Msg);
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">DispatchMessageA</span>(<span style="color:#f92672">&amp;</span>Msg);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//----- (0000000000401BA0) ----------------------------------------------------
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">__fastcall</span> <span style="color:#a6e22e">decode_pointer</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>codedptr)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> codedptr;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//----- (0000000000401BB0) ----------------------------------------------------
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">__fastcall</span> <span style="color:#a6e22e">encode_pointer</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>ptr)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> ptr;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//----- (0000000000401BC0) ----------------------------------------------------
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#66d9ef">__cdecl</span> <span style="color:#a6e22e">setargv</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//----- (0000000000401BD0) ----------------------------------------------------
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#66d9ef">__fastcall</span> <span style="color:#a6e22e">_mingw_raise_matherr</span>(<span style="color:#66d9ef">int</span> typ, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>name, <span style="color:#66d9ef">double</span> a3, <span style="color:#66d9ef">double</span> a1, <span style="color:#66d9ef">double</span> rslt)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  _exception ex; <span style="color:#75715e">// [rsp+20h] [rbp-38h] BYREF
</span></span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> ( stUserMathErr )
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    ex.type <span style="color:#f92672">=</span> typ;
</span></span><span style="display:flex;"><span>    ex.name <span style="color:#f92672">=</span> name;
</span></span><span style="display:flex;"><span>    ex.arg1 <span style="color:#f92672">=</span> a3;
</span></span><span style="display:flex;"><span>    ex.arg2 <span style="color:#f92672">=</span> a1;
</span></span><span style="display:flex;"><span>    ex.retval <span style="color:#f92672">=</span> rslt;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">stUserMathErr</span>(<span style="color:#f92672">&amp;</span>ex);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//----- (0000000000401C20) ----------------------------------------------------
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#66d9ef">__fastcall</span> <span style="color:#a6e22e">_mingw_setusermatherr</span>(<span style="color:#66d9ef">int</span> (<span style="color:#f92672">*</span>f)(_exception <span style="color:#f92672">*</span>))
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  stUserMathErr <span style="color:#f92672">=</span> f;
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">_setusermatherr</span>(f);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//----- (0000000000401C30) ----------------------------------------------------
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#66d9ef">__fastcall</span> <span style="color:#a6e22e">matherr</span>(_exception <span style="color:#f92672">*</span>pexcept)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>v1; <span style="color:#75715e">// rbx
</span></span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">double</span> retval; <span style="color:#75715e">// xmm8_8
</span></span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>name; <span style="color:#75715e">// rsi
</span></span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">double</span> arg2; <span style="color:#75715e">// xmm7_8
</span></span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">double</span> arg1; <span style="color:#75715e">// xmm6_8
</span></span></span><span style="display:flex;"><span>  FILE <span style="color:#f92672">*</span>v6; <span style="color:#75715e">// rax
</span></span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">switch</span> ( pexcept<span style="color:#f92672">-&gt;</span>type )
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>      v1 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Argument domain error (DOMAIN)&#34;</span>;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">2</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>      v1 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Argument singularity (SIGN)&#34;</span>;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">3</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>      v1 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Overflow range error (OVERFLOW)&#34;</span>;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">4</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>      v1 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;The result is too small to be represented (UNDERFLOW)&#34;</span>;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">5</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>      v1 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Total loss of significance (TLOSS)&#34;</span>;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">6</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>      v1 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Partial loss of significance (PLOSS)&#34;</span>;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">default</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>      v1 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Unknown error&#34;</span>;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  retval <span style="color:#f92672">=</span> pexcept<span style="color:#f92672">-&gt;</span>retval;
</span></span><span style="display:flex;"><span>  name <span style="color:#f92672">=</span> pexcept<span style="color:#f92672">-&gt;</span>name;
</span></span><span style="display:flex;"><span>  arg2 <span style="color:#f92672">=</span> pexcept<span style="color:#f92672">-&gt;</span>arg2;
</span></span><span style="display:flex;"><span>  arg1 <span style="color:#f92672">=</span> pexcept<span style="color:#f92672">-&gt;</span>arg1;
</span></span><span style="display:flex;"><span>  v6 <span style="color:#f92672">=</span> <span style="color:#a6e22e">_iob_func</span>();
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">fprintf</span>(v6 <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span>, <span style="color:#e6db74">&#34;_matherr(): %s in %s(%g, %g)  (retval=%g)</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, v1, name, arg1, arg2, retval);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//----- (0000000000401D30) ----------------------------------------------------
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> __noreturn <span style="color:#a6e22e">_report_error</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>msg, ...)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  FILE <span style="color:#f92672">*</span>v2; <span style="color:#75715e">// rax
</span></span></span><span style="display:flex;"><span>  FILE <span style="color:#f92672">*</span>v3; <span style="color:#75715e">// rax
</span></span></span><span style="display:flex;"><span>  va_list va; <span style="color:#75715e">// [rsp+58h] [rbp+10h] BYREF
</span></span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">va_start</span>(va, msg);
</span></span><span style="display:flex;"><span>  v2 <span style="color:#f92672">=</span> <span style="color:#a6e22e">_iob_func</span>();
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">fwrite</span>(<span style="color:#e6db74">&#34;Mingw-w64 runtime failure:</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#ae81ff">1uLL</span>, <span style="color:#ae81ff">0x1BuLL</span>, v2 <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>  v3 <span style="color:#f92672">=</span> <span style="color:#a6e22e">_iob_func</span>();
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">vfprintf</span>(v3 <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span>, msg, va);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">abort</span>();
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//----- (0000000000401DA0) ----------------------------------------------------
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#66d9ef">__fastcall</span> <span style="color:#a6e22e">_write_memory_part_0</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>addr, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>src, <span style="color:#66d9ef">size_t</span> len)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">__int64</span> v3; <span style="color:#75715e">// rbp
</span></span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> v7; <span style="color:#75715e">// r9d
</span></span></span><span style="display:flex;"><span>  PBYTE <span style="color:#f92672">*</span>p_sec_start; <span style="color:#75715e">// rax
</span></span></span><span style="display:flex;"><span>  PIMAGE_SECTION_HEADER SectionForAddress; <span style="color:#75715e">// rax
</span></span></span><span style="display:flex;"><span>  PIMAGE_SECTION_HEADER v10; <span style="color:#75715e">// r12
</span></span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">__int64</span> v11; <span style="color:#75715e">// rbp
</span></span></span><span style="display:flex;"><span>  sSecInfo <span style="color:#f92672">*</span>v12; <span style="color:#75715e">// r13
</span></span></span><span style="display:flex;"><span>  DWORD LastError; <span style="color:#75715e">// eax
</span></span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">struct</span> _MEMORY_BASIC_INFORMATION Buffer; <span style="color:#75715e">// [rsp+20h] [rbp-68h] BYREF
</span></span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  v3 <span style="color:#f92672">=</span> maxSections;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> ( maxSections <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span> )
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    v3 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0LL</span>;
</span></span><span style="display:flex;"><span>LABEL_6:
</span></span><span style="display:flex;"><span>    SectionForAddress <span style="color:#f92672">=</span> <span style="color:#a6e22e">_mingw_GetSectionForAddress</span>(addr);
</span></span><span style="display:flex;"><span>    v10 <span style="color:#f92672">=</span> SectionForAddress;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ( <span style="color:#f92672">!</span>SectionForAddress )
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">_report_error</span>(<span style="color:#e6db74">&#34;Address %p has no image-section&#34;</span>, addr);
</span></span><span style="display:flex;"><span>    v11 <span style="color:#f92672">=</span> v3;
</span></span><span style="display:flex;"><span>    v12 <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>the_secs[v11];
</span></span><span style="display:flex;"><span>    v12<span style="color:#f92672">-&gt;</span>hash <span style="color:#f92672">=</span> SectionForAddress;
</span></span><span style="display:flex;"><span>    v12<span style="color:#f92672">-&gt;</span>old_protect <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    v12<span style="color:#f92672">-&gt;</span>sec_start <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">GetPEImageBase</span>()[SectionForAddress<span style="color:#f92672">-&gt;</span>VirtualAddress];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ( <span style="color:#f92672">!</span><span style="color:#a6e22e">VirtualQuery</span>(the_secs[v11].sec_start, <span style="color:#f92672">&amp;</span>Buffer, <span style="color:#ae81ff">0x30uLL</span>) )
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">_report_error</span>(
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;  VirtualQuery failed for %d bytes at address %p&#34;</span>,
</span></span><span style="display:flex;"><span>        v10<span style="color:#f92672">-&gt;</span>Misc.PhysicalAddress,
</span></span><span style="display:flex;"><span>        the_secs[v11].sec_start);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ( ((Buffer.Protect <span style="color:#f92672">-</span> <span style="color:#ae81ff">4</span>) <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0xFFFFFFFB</span>) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">&amp;&amp;</span> ((Buffer.Protect <span style="color:#f92672">-</span> <span style="color:#ae81ff">64</span>) <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0xFFFFFFBF</span>) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span><span style="color:#a6e22e">VirtualProtect</span>(Buffer.BaseAddress, Buffer.RegionSize, <span style="color:#ae81ff">0x40u</span>, <span style="color:#f92672">&amp;</span>the_secs[v11].old_protect) )
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>      LastError <span style="color:#f92672">=</span> <span style="color:#a6e22e">GetLastError</span>();
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">_report_error</span>(<span style="color:#e6db74">&#34;  VirtualProtect failed with code 0x%x&#34;</span>, LastError);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">++</span>maxSections;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    v7 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    p_sec_start <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>the_secs<span style="color:#f92672">-&gt;</span>sec_start;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> ( addr <span style="color:#f92672">&lt;</span> <span style="color:#f92672">*</span>p_sec_start <span style="color:#f92672">||</span> addr <span style="color:#f92672">&gt;=</span> <span style="color:#f92672">&amp;</span>(<span style="color:#f92672">*</span>p_sec_start)[<span style="color:#f92672">*</span>(p_sec_start[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span>)] )
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">++</span>v7;
</span></span><span style="display:flex;"><span>      p_sec_start <span style="color:#f92672">+=</span> <span style="color:#ae81ff">3</span>;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> ( v7 <span style="color:#f92672">==</span> maxSections )
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">goto</span> LABEL_6;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">memcpy</span>(addr, src, len);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//----- (0000000000401F10) ----------------------------------------------------
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#66d9ef">__cdecl</span> <span style="color:#a6e22e">pei386_runtime_relocator</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">__int64</span> v0; <span style="color:#75715e">// rax
</span></span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>v1; <span style="color:#75715e">// rsp
</span></span></span><span style="display:flex;"><span>  _DWORD <span style="color:#f92672">*</span>v2; <span style="color:#75715e">// rbx
</span></span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>v3; <span style="color:#75715e">// rsp
</span></span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> v4; <span style="color:#75715e">// edx
</span></span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>v5; <span style="color:#75715e">// rbx
</span></span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> v6; <span style="color:#75715e">// edx
</span></span></span><span style="display:flex;"><span>  BYTE <span style="color:#f92672">*</span>v7; <span style="color:#75715e">// rax
</span></span></span><span style="display:flex;"><span>  BYTE <span style="color:#f92672">*</span>v8; <span style="color:#75715e">// rcx
</span></span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">__int64</span> v9; <span style="color:#75715e">// r8
</span></span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">__int64</span> v10; <span style="color:#75715e">// rbx
</span></span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> i; <span style="color:#75715e">// esi
</span></span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">__int64</span> v12; <span style="color:#75715e">// rcx
</span></span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> v13; <span style="color:#75715e">// eax
</span></span></span><span style="display:flex;"><span>  BYTE <span style="color:#f92672">*</span>v14; <span style="color:#75715e">// rcx
</span></span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">__int64</span> v15; <span style="color:#75715e">// rdx
</span></span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">__int64</span> v16; <span style="color:#75715e">// rdx
</span></span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">__int64</span> v17; <span style="color:#75715e">// rdx
</span></span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">char</span> v18; <span style="color:#75715e">// [rsp+20h] [rbp-40h] BYREF
</span></span></span><span style="display:flex;"><span>  DWORD flOldProtect; <span style="color:#75715e">// [rsp+2Ch] [rbp-34h] BYREF
</span></span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">struct</span> _MEMORY_BASIC_INFORMATION src; <span style="color:#75715e">// [rsp+30h] [rbp-30h] BYREF
</span></span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> ( was_init_73980 )
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>  was_init_73980 <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  v0 <span style="color:#f92672">=</span> (<span style="color:#ae81ff">24LL</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">_mingw_GetSectionCount</span>() <span style="color:#f92672">+</span> <span style="color:#ae81ff">30</span>) <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0xFFFFFFFFFFFFFFF0uLL</span>;
</span></span><span style="display:flex;"><span>  v1 <span style="color:#f92672">=</span> <span style="color:#a6e22e">alloca</span>(v0);
</span></span><span style="display:flex;"><span>  v2 <span style="color:#f92672">=</span> refptr___RUNTIME_PSEUDO_RELOC_LIST__;
</span></span><span style="display:flex;"><span>  v3 <span style="color:#f92672">=</span> <span style="color:#a6e22e">alloca</span>(v0);
</span></span><span style="display:flex;"><span>  maxSections <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  the_secs <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>v18;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> ( refptr___RUNTIME_PSEUDO_RELOC_LIST_END__ <span style="color:#f92672">-</span> refptr___RUNTIME_PSEUDO_RELOC_LIST__ <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">7</span> )
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> ( refptr___RUNTIME_PSEUDO_RELOC_LIST_END__ <span style="color:#f92672">-</span> refptr___RUNTIME_PSEUDO_RELOC_LIST__ <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">11</span> )
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ( <span style="color:#f92672">*</span>refptr___RUNTIME_PSEUDO_RELOC_LIST__ <span style="color:#f92672">||</span> <span style="color:#f92672">*</span>(refptr___RUNTIME_PSEUDO_RELOC_LIST__ <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) )
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">goto</span> LABEL_25;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ( <span style="color:#f92672">*</span>(refptr___RUNTIME_PSEUDO_RELOC_LIST__ <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span>) )
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">goto</span> LABEL_11;
</span></span><span style="display:flex;"><span>    v2 <span style="color:#f92672">=</span> (refptr___RUNTIME_PSEUDO_RELOC_LIST__ <span style="color:#f92672">+</span> <span style="color:#ae81ff">12</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> ( <span style="color:#f92672">*</span>v2 <span style="color:#f92672">||</span> v2[<span style="color:#ae81ff">1</span>] )
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>LABEL_25:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ( v2 <span style="color:#f92672">&gt;=</span> refptr___RUNTIME_PSEUDO_RELOC_LIST_END__ )
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">do</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>      v12 <span style="color:#f92672">=</span> v2[<span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>      v13 <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>v2;
</span></span><span style="display:flex;"><span>      v2 <span style="color:#f92672">+=</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>      v14 <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>refptr___image_base__[v12];
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">LODWORD</span>(src.BaseAddress) <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>v14 <span style="color:#f92672">+</span> v13;
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">_write_memory_part_0</span>(v14, <span style="color:#f92672">&amp;</span>src, <span style="color:#ae81ff">4uLL</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> ( v2 <span style="color:#f92672">&lt;</span> refptr___RUNTIME_PSEUDO_RELOC_LIST_END__ );
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">goto</span> LABEL_19;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>LABEL_11:
</span></span><span style="display:flex;"><span>  v4 <span style="color:#f92672">=</span> v2[<span style="color:#ae81ff">2</span>];
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> ( v4 <span style="color:#f92672">!=</span> <span style="color:#ae81ff">1</span> )
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">_report_error</span>(<span style="color:#e6db74">&#34;  Unknown pseudo relocation protocol version %d.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, v4);
</span></span><span style="display:flex;"><span>  v5 <span style="color:#f92672">=</span> v2 <span style="color:#f92672">+</span> <span style="color:#ae81ff">3</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> ( v5 <span style="color:#f92672">&lt;</span> refptr___RUNTIME_PSEUDO_RELOC_LIST_END__ )
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">do</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>      v6 <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>(v5 <span style="color:#f92672">+</span> <span style="color:#ae81ff">8</span>);
</span></span><span style="display:flex;"><span>      v7 <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>refptr___image_base__[<span style="color:#f92672">*</span>v5];
</span></span><span style="display:flex;"><span>      v8 <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>refptr___image_base__[v5[<span style="color:#ae81ff">1</span>]];
</span></span><span style="display:flex;"><span>      v9 <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>v7;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> ( v6 <span style="color:#f92672">==</span> <span style="color:#ae81ff">16</span> )
</span></span><span style="display:flex;"><span>      {
</span></span><span style="display:flex;"><span>        v16 <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>v8;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> ( (v16 <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0x8000u</span>) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0LL</span> )
</span></span><span style="display:flex;"><span>          v16 <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>v8 <span style="color:#f92672">|</span> <span style="color:#ae81ff">0xFFFFFFFFFFFF0000uLL</span>;
</span></span><span style="display:flex;"><span>        src.BaseAddress <span style="color:#f92672">=</span> (v9 <span style="color:#f92672">+</span> v16 <span style="color:#f92672">-</span> v7);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">_write_memory_part_0</span>(v8, <span style="color:#f92672">&amp;</span>src, <span style="color:#ae81ff">2uLL</span>);
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> ( v6 <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0x10</span> )
</span></span><span style="display:flex;"><span>      {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> ( v6 <span style="color:#f92672">!=</span> <span style="color:#ae81ff">8</span> )
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>LABEL_35:
</span></span><span style="display:flex;"><span>          src.BaseAddress <span style="color:#f92672">=</span> <span style="color:#ae81ff">0LL</span>;
</span></span><span style="display:flex;"><span>          <span style="color:#a6e22e">_report_error</span>(<span style="color:#e6db74">&#34;  Unknown pseudo relocation bit size %d.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, v6);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        v15 <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>v8;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> ( (v15 <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0x80u</span>) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0LL</span> )
</span></span><span style="display:flex;"><span>          v15 <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>v8 <span style="color:#f92672">|</span> <span style="color:#ae81ff">0xFFFFFFFFFFFFFF00uLL</span>;
</span></span><span style="display:flex;"><span>        src.BaseAddress <span style="color:#f92672">=</span> (v9 <span style="color:#f92672">+</span> v15 <span style="color:#f92672">-</span> v7);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">_write_memory_part_0</span>(v8, <span style="color:#f92672">&amp;</span>src, <span style="color:#ae81ff">1uLL</span>);
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> ( v6 <span style="color:#f92672">==</span> <span style="color:#ae81ff">32</span> )
</span></span><span style="display:flex;"><span>      {
</span></span><span style="display:flex;"><span>        v17 <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>v8;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> ( (v17 <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0x80000000</span>) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0LL</span> )
</span></span><span style="display:flex;"><span>          v17 <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>v8 <span style="color:#f92672">|</span> <span style="color:#ae81ff">0xFFFFFFFF00000000uLL</span>;
</span></span><span style="display:flex;"><span>        src.BaseAddress <span style="color:#f92672">=</span> (v9 <span style="color:#f92672">+</span> v17 <span style="color:#f92672">-</span> v7);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">_write_memory_part_0</span>(v8, <span style="color:#f92672">&amp;</span>src, <span style="color:#ae81ff">4uLL</span>);
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>      {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> ( v6 <span style="color:#f92672">!=</span> <span style="color:#ae81ff">64</span> )
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">goto</span> LABEL_35;
</span></span><span style="display:flex;"><span>        src.BaseAddress <span style="color:#f92672">=</span> (<span style="color:#f92672">*</span>v8 <span style="color:#f92672">+</span> v9 <span style="color:#f92672">-</span> v7);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">_write_memory_part_0</span>(v8, <span style="color:#f92672">&amp;</span>src, <span style="color:#ae81ff">8uLL</span>);
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      v5 <span style="color:#f92672">+=</span> <span style="color:#ae81ff">3</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> ( v5 <span style="color:#f92672">&lt;</span> refptr___RUNTIME_PSEUDO_RELOC_LIST_END__ );
</span></span><span style="display:flex;"><span>LABEL_19:
</span></span><span style="display:flex;"><span>    v10 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0LL</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> ( i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> maxSections; <span style="color:#f92672">++</span>v10 )
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> ( the_secs[v10].old_protect )
</span></span><span style="display:flex;"><span>      {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> ( <span style="color:#f92672">!</span><span style="color:#a6e22e">VirtualQuery</span>(the_secs[v10].sec_start, <span style="color:#f92672">&amp;</span>src, <span style="color:#ae81ff">0x30uLL</span>) )
</span></span><span style="display:flex;"><span>          <span style="color:#a6e22e">_report_error</span>(
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;  VirtualQuery failed for %d bytes at address %p&#34;</span>,
</span></span><span style="display:flex;"><span>            the_secs[v10].hash<span style="color:#f92672">-&gt;</span>Misc.PhysicalAddress,
</span></span><span style="display:flex;"><span>            the_secs[v10].sec_start);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">VirtualProtect</span>(src.BaseAddress, src.RegionSize, the_secs[v10].old_protect, <span style="color:#f92672">&amp;</span>flOldProtect);
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">++</span>i;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 405390: using guessed type _UNKNOWN *refptr___RUNTIME_PSEUDO_RELOC_LIST_END__;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 4053A0: using guessed type _UNKNOWN *refptr___RUNTIME_PSEUDO_RELOC_LIST__;
</span></span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//----- (0000000000402210) ----------------------------------------------------
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#66d9ef">__fastcall</span> <span style="color:#a6e22e">_mingw_SEH_error_handler</span>(
</span></span><span style="display:flex;"><span>        _EXCEPTION_RECORD <span style="color:#f92672">*</span>ExceptionRecord,
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>EstablisherFrame,
</span></span><span style="display:flex;"><span>        _CONTEXT <span style="color:#f92672">*</span>ContextRecord,
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>DispatcherContext)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  DWORD ExceptionCode; <span style="color:#75715e">// eax
</span></span></span><span style="display:flex;"><span>  _crt_signal_t v5; <span style="color:#75715e">// rax
</span></span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> result; <span style="color:#75715e">// eax
</span></span></span><span style="display:flex;"><span>  _crt_signal_t v7; <span style="color:#75715e">// rdx
</span></span></span><span style="display:flex;"><span>  _crt_signal_t v8; <span style="color:#75715e">// rax
</span></span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  ExceptionCode <span style="color:#f92672">=</span> ExceptionRecord<span style="color:#f92672">-&gt;</span>ExceptionCode;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> ( ExceptionRecord<span style="color:#f92672">-&gt;</span>ExceptionCode <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0xC0000091</span> )
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ( ExceptionCode <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1073741676</span> )
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>      v7 <span style="color:#f92672">=</span> <span style="color:#a6e22e">signal</span>(<span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">0LL</span>);
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> ( v7 <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> )
</span></span><span style="display:flex;"><span>      {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">signal</span>(<span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">goto</span> LABEL_16;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ( ExceptionCode <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0xC0000094</span> )
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> ( ExceptionCode <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1073741675</span> )
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> ( ExceptionCode <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1073741674</span> )
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">goto</span> LABEL_20;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ( ExceptionCode <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1073741678</span> )
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ( ExceptionCode <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1073741677</span> )
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> ( ExceptionCode <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0xC000008D</span> )
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ( ExceptionCode <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1073741816</span> )
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ( ExceptionCode <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0xC0000008</span> )
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> ( ExceptionCode <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">2147483646</span> )
</span></span><span style="display:flex;"><span>      {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> ( ExceptionCode <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1073741819</span> )
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>          v5 <span style="color:#f92672">=</span> <span style="color:#a6e22e">signal</span>(<span style="color:#ae81ff">11</span>, <span style="color:#ae81ff">0LL</span>);
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">if</span> ( v5 <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> )
</span></span><span style="display:flex;"><span>          {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">signal</span>(<span style="color:#ae81ff">11</span>, <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>          }
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">if</span> ( v5 )
</span></span><span style="display:flex;"><span>          {
</span></span><span style="display:flex;"><span>            (v5)(<span style="color:#ae81ff">11LL</span>);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>          }
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">4</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ( ExceptionCode <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1073741795</span> )
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> ExceptionCode <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1073741684</span>;
</span></span><span style="display:flex;"><span>LABEL_20:
</span></span><span style="display:flex;"><span>    v8 <span style="color:#f92672">=</span> <span style="color:#a6e22e">signal</span>(<span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">0LL</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ( v8 <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> )
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">signal</span>(<span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ( v8 )
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>      (v8)(<span style="color:#ae81ff">4LL</span>);
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">4</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  v7 <span style="color:#f92672">=</span> <span style="color:#a6e22e">signal</span>(<span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">0LL</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> ( v7 <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> )
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">signal</span>(<span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fpreset</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>LABEL_16:
</span></span><span style="display:flex;"><span>  result <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> ( v7 )
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    (v7)(<span style="color:#ae81ff">8LL</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//----- (00000000004023C0) ----------------------------------------------------
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#66d9ef">__cdecl</span> <span style="color:#a6e22e">_mingw_init_ehandler</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  PBYTE PEImageBase; <span style="color:#75715e">// rbp
</span></span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> result; <span style="color:#75715e">// eax
</span></span></span><span style="display:flex;"><span>  RUNTIME_FUNCTION <span style="color:#f92672">*</span>v2; <span style="color:#75715e">// rbx
</span></span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">size_t</span> v3; <span style="color:#75715e">// rsi
</span></span></span><span style="display:flex;"><span>  UNWIND_INFO <span style="color:#f92672">*</span>v4; <span style="color:#75715e">// rdi
</span></span></span><span style="display:flex;"><span>  DWORD VirtualAddress; <span style="color:#75715e">// edx
</span></span></span><span style="display:flex;"><span>  DWORD v6; <span style="color:#75715e">// edx
</span></span></span><span style="display:flex;"><span>  DWORD v7; <span style="color:#75715e">// eax
</span></span></span><span style="display:flex;"><span>  PIMAGE_SECTION_HEADER PESectionExec; <span style="color:#75715e">// rax
</span></span></span><span style="display:flex;"><span>  ULONG v9; <span style="color:#75715e">// edx
</span></span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  PEImageBase <span style="color:#f92672">=</span> <span style="color:#a6e22e">GetPEImageBase</span>();
</span></span><span style="display:flex;"><span>  result <span style="color:#f92672">=</span> was_here_73812;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> ( <span style="color:#f92672">!</span>was_here_73812 <span style="color:#f92672">&amp;&amp;</span> PEImageBase )
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    was_here_73812 <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ( <span style="color:#f92672">!</span><span style="color:#a6e22e">FindPESectionByName</span>(<span style="color:#e6db74">&#34;.pdata&#34;</span>) )
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>      v2 <span style="color:#f92672">=</span> emu_pdata;
</span></span><span style="display:flex;"><span>      v3 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0LL</span>;
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">memset</span>(emu_pdata, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(emu_pdata));
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">memset</span>(emu_xdata, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(emu_xdata));
</span></span><span style="display:flex;"><span>      v4 <span style="color:#f92672">=</span> emu_xdata;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">while</span> ( <span style="color:#ae81ff">1</span> )
</span></span><span style="display:flex;"><span>      {
</span></span><span style="display:flex;"><span>        PESectionExec <span style="color:#f92672">=</span> <span style="color:#a6e22e">FindPESectionExec</span>(v3);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> ( <span style="color:#f92672">!</span>PESectionExec )
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        v4<span style="color:#f92672">-&gt;</span>VersionAndFlags <span style="color:#f92672">=</span> <span style="color:#ae81ff">9</span>;
</span></span><span style="display:flex;"><span>        v4<span style="color:#f92672">-&gt;</span>AddressOfExceptionHandler <span style="color:#f92672">=</span> _mingw_SEH_error_handler <span style="color:#f92672">-</span> PEImageBase;
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">++</span>v3;
</span></span><span style="display:flex;"><span>        VirtualAddress <span style="color:#f92672">=</span> PESectionExec<span style="color:#f92672">-&gt;</span>VirtualAddress;
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">++</span>v2;
</span></span><span style="display:flex;"><span>        v2[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>].BeginAddress <span style="color:#f92672">=</span> VirtualAddress;
</span></span><span style="display:flex;"><span>        v6 <span style="color:#f92672">=</span> PESectionExec<span style="color:#f92672">-&gt;</span>Misc.PhysicalAddress <span style="color:#f92672">+</span> VirtualAddress;
</span></span><span style="display:flex;"><span>        v7 <span style="color:#f92672">=</span> v4<span style="color:#f92672">++</span> <span style="color:#f92672">-</span> PEImageBase;
</span></span><span style="display:flex;"><span>        v2[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>].UnwindData <span style="color:#f92672">=</span> v7;
</span></span><span style="display:flex;"><span>        v2[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>].EndAddress <span style="color:#f92672">=</span> v6;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> ( v3 <span style="color:#f92672">==</span> <span style="color:#ae81ff">32</span> )
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>          v9 <span style="color:#f92672">=</span> <span style="color:#ae81ff">32</span>;
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">goto</span> LABEL_11;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> ( <span style="color:#f92672">!</span>v3 )
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>      v9 <span style="color:#f92672">=</span> v3;
</span></span><span style="display:flex;"><span>LABEL_11:
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">RtlAddFunctionTable</span>(emu_pdata, v9, PEImageBase);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//----- (0000000000402670) ----------------------------------------------------
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#66d9ef">__cdecl</span> <span style="color:#a6e22e">fpreset</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">__asm</span> { fninit }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//----- (0000000000402680) ----------------------------------------------------
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#66d9ef">__cdecl</span> <span style="color:#a6e22e">_do_global_dtors</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>i)(<span style="color:#66d9ef">void</span>); <span style="color:#75715e">// rax
</span></span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> ( i <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>p_73208; i; <span style="color:#f92672">++</span>p_73208 )
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">i</span>();
</span></span><span style="display:flex;"><span>    i <span style="color:#f92672">=</span> p_73208[<span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//----- (00000000004026C0) ----------------------------------------------------
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#66d9ef">__cdecl</span> <span style="color:#a6e22e">_do_global_ctors</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> i; <span style="color:#75715e">// ebx
</span></span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  i <span style="color:#f92672">=</span> (<span style="color:#f92672">*</span>refptr___CTOR_LIST__)[<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> ( i <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> )
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> ( i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; (<span style="color:#f92672">*</span>refptr___CTOR_LIST__)[i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>]; <span style="color:#f92672">++</span>i )
</span></span><span style="display:flex;"><span>      ;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> ( ; i; <span style="color:#f92672">--</span>i )
</span></span><span style="display:flex;"><span>    ((<span style="color:#f92672">*</span>refptr___CTOR_LIST__)[i])();
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">atexit</span>(_do_global_dtors);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 405380: using guessed type __int64 (*refptr___CTOR_LIST__)[2];
</span></span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//----- (0000000000402720) ----------------------------------------------------
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#66d9ef">__cdecl</span> <span style="color:#a6e22e">_main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> ( <span style="color:#f92672">!</span>initialized )
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    initialized <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">_do_global_ctors</span>();
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//----- (0000000000402740) ----------------------------------------------------
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#66d9ef">__cdecl</span> <span style="color:#a6e22e">_security_init_cookie</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  FT v0; <span style="color:#75715e">// r12
</span></span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">__int64</span> CurrentProcessId; <span style="color:#75715e">// rbp
</span></span></span><span style="display:flex;"><span>  DWORD CurrentThreadId; <span style="color:#75715e">// edi
</span></span></span><span style="display:flex;"><span>  DWORD TickCount; <span style="color:#75715e">// esi
</span></span></span><span style="display:flex;"><span>  LONGLONG v4; <span style="color:#75715e">// rsi
</span></span></span><span style="display:flex;"><span>  UINT_PTR v5; <span style="color:#75715e">// rax
</span></span></span><span style="display:flex;"><span>  FT systime; <span style="color:#75715e">// [rsp+20h] [rbp-48h] BYREF
</span></span></span><span style="display:flex;"><span>  LARGE_INTEGER perfctr; <span style="color:#75715e">// [rsp+30h] [rbp-38h] BYREF
</span></span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  systime.ft_scalar <span style="color:#f92672">=</span> <span style="color:#ae81ff">0LL</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> ( _security_cookie <span style="color:#f92672">==</span> <span style="color:#ae81ff">0x2B992DDFA232LL</span> )
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">GetSystemTimeAsFileTime</span>(<span style="color:#f92672">&amp;</span>systime);
</span></span><span style="display:flex;"><span>    v0.ft_scalar <span style="color:#f92672">=</span> systime.ft_scalar;
</span></span><span style="display:flex;"><span>    CurrentProcessId <span style="color:#f92672">=</span> <span style="color:#a6e22e">GetCurrentProcessId</span>();
</span></span><span style="display:flex;"><span>    CurrentThreadId <span style="color:#f92672">=</span> <span style="color:#a6e22e">GetCurrentThreadId</span>();
</span></span><span style="display:flex;"><span>    TickCount <span style="color:#f92672">=</span> <span style="color:#a6e22e">GetTickCount</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">QueryPerformanceCounter</span>(<span style="color:#f92672">&amp;</span>perfctr);
</span></span><span style="display:flex;"><span>    v4 <span style="color:#f92672">=</span> (TickCount <span style="color:#f92672">^</span> CurrentThreadId <span style="color:#f92672">^</span> perfctr.QuadPart <span style="color:#f92672">^</span> v0.ft_scalar <span style="color:#f92672">^</span> CurrentProcessId) <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0xFFFFFFFFFFFFLL</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ( v4 <span style="color:#f92672">==</span> <span style="color:#ae81ff">0x2B992DDFA232LL</span> )
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>      v5 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0xFFFFD466D2205DCCuLL</span>;
</span></span><span style="display:flex;"><span>      v4 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x2B992DDFA233LL</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>      v5 <span style="color:#f92672">=</span> <span style="color:#f92672">~</span>v4;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    _security_cookie <span style="color:#f92672">=</span> v4;
</span></span><span style="display:flex;"><span>    _security_cookie_complement <span style="color:#f92672">=</span> v5;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    _security_cookie_complement <span style="color:#f92672">=</span> <span style="color:#f92672">~</span>_security_cookie;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//----- (0000000000402820) ----------------------------------------------------
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#66d9ef">__fastcall</span> __noreturn <span style="color:#a6e22e">_report_gsfailure</span>(ULONG_PTR StackCookie)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  ULONG64 Rip; <span style="color:#75715e">// rbx
</span></span></span><span style="display:flex;"><span>  _RUNTIME_FUNCTION <span style="color:#f92672">*</span>v3; <span style="color:#75715e">// r9
</span></span></span><span style="display:flex;"><span>  HANDLE CurrentProcess; <span style="color:#75715e">// rax
</span></span></span><span style="display:flex;"><span>  ULONG64 imgBase; <span style="color:#75715e">// [rsp+48h] [rbp-28h] BYREF
</span></span></span><span style="display:flex;"><span>  ULONG64 establisherFrame; <span style="color:#75715e">// [rsp+50h] [rbp-20h] BYREF
</span></span></span><span style="display:flex;"><span>  PVOID hndData; <span style="color:#75715e">// [rsp+58h] [rbp-18h] BYREF
</span></span></span><span style="display:flex;"><span>  UINT_PTR cookie[<span style="color:#ae81ff">2</span>]; <span style="color:#75715e">// [rsp+60h] [rbp-10h]
</span></span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">char</span> vars8; <span style="color:#75715e">// [rsp+78h] [rbp+8h] BYREF
</span></span></span><span style="display:flex;"><span>  DWORD64 retaddr; <span style="color:#75715e">// [rsp+88h] [rbp+18h]
</span></span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">RtlCaptureContext</span>(<span style="color:#f92672">&amp;</span>GS_ContextRecord);
</span></span><span style="display:flex;"><span>  Rip <span style="color:#f92672">=</span> GS_ContextRecord.Rip;
</span></span><span style="display:flex;"><span>  v3 <span style="color:#f92672">=</span> <span style="color:#a6e22e">RtlLookupFunctionEntry</span>(GS_ContextRecord.Rip, <span style="color:#f92672">&amp;</span>imgBase, <span style="color:#ae81ff">0LL</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> ( v3 )
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">RtlVirtualUnwind</span>(<span style="color:#ae81ff">0</span>, imgBase, Rip, v3, <span style="color:#f92672">&amp;</span>GS_ContextRecord, <span style="color:#f92672">&amp;</span>hndData, <span style="color:#f92672">&amp;</span>establisherFrame, <span style="color:#ae81ff">0LL</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    GS_ContextRecord.Rip <span style="color:#f92672">=</span> retaddr;
</span></span><span style="display:flex;"><span>    GS_ContextRecord.Rsp <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>vars8;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  GS_ContextRecord.Rcx <span style="color:#f92672">=</span> StackCookie;
</span></span><span style="display:flex;"><span>  GS_ExceptionRecord.ExceptionCode <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1073740791</span>;
</span></span><span style="display:flex;"><span>  GS_ExceptionRecord.ExceptionFlags <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  GS_ExceptionRecord.ExceptionAddress <span style="color:#f92672">=</span> GS_ContextRecord.Rip;
</span></span><span style="display:flex;"><span>  cookie[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> _security_cookie_complement;
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">SetUnhandledExceptionFilter</span>(<span style="color:#ae81ff">0LL</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">UnhandledExceptionFilter</span>(<span style="color:#f92672">&amp;</span>GS_ExceptionPointers);
</span></span><span style="display:flex;"><span>  CurrentProcess <span style="color:#f92672">=</span> <span style="color:#a6e22e">GetCurrentProcess</span>();
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">TerminateProcess</span>(CurrentProcess, <span style="color:#ae81ff">0xC0000409</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">abort</span>();
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//----- (0000000000402920) ----------------------------------------------------
</span></span></span><span style="display:flex;"><span>BOOL <span style="color:#66d9ef">__fastcall</span> <span style="color:#a6e22e">_dyn_tls_dtor</span>(HANDLE hDllHandle, DWORD dwReason, LPVOID lpreserved)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> ( dwReason <span style="color:#f92672">&amp;&amp;</span> dwReason <span style="color:#f92672">!=</span> <span style="color:#ae81ff">3</span> )
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">_mingw_TLScallback</span>(hDllHandle, dwReason, lpreserved);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//----- (0000000000402950) ----------------------------------------------------
</span></span></span><span style="display:flex;"><span>BOOL <span style="color:#66d9ef">__fastcall</span> <span style="color:#a6e22e">_dyn_tls_init</span>(HANDLE hDllHandle, DWORD dwReason, LPVOID lpreserved)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> ( <span style="color:#f92672">*</span>refptr__CRT_MT <span style="color:#f92672">!=</span> <span style="color:#ae81ff">2</span> )
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>refptr__CRT_MT <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> ( dwReason <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> )
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">_mingw_TLScallback</span>(hDllHandle, <span style="color:#ae81ff">1u</span>, lpreserved);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 405360: using guessed type int *refptr__CRT_MT;
</span></span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//----- (00000000004029C0) ----------------------------------------------------
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#66d9ef">__fastcall</span> <span style="color:#a6e22e">_tlregdtor</span>(_PVFV func)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//----- (00000000004029D0) ----------------------------------------------------
</span></span></span><span style="display:flex;"><span>_onexit_t <span style="color:#66d9ef">__fastcall</span> <span style="color:#a6e22e">mingw_onexit</span>(_onexit_t func)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> (<span style="color:#f92672">*</span>v2)(<span style="color:#66d9ef">void</span>); <span style="color:#75715e">// rbx
</span></span></span><span style="display:flex;"><span>  _PVFV <span style="color:#f92672">*</span>onexitbegin; <span style="color:#75715e">// [rsp+20h] [rbp-18h] BYREF
</span></span></span><span style="display:flex;"><span>  _PVFV <span style="color:#f92672">*</span>onexitend; <span style="color:#75715e">// [rsp+28h] [rbp-10h] BYREF
</span></span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  onexitbegin <span style="color:#f92672">=</span> <span style="color:#a6e22e">decode_pointer</span>(_onexitbegin);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> ( onexitbegin <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1LL</span> )
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> (<span style="color:#f92672">*</span>refptr___imp__onexit)(func);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">lock</span>(<span style="color:#ae81ff">8LL</span>);
</span></span><span style="display:flex;"><span>  onexitbegin <span style="color:#f92672">=</span> <span style="color:#a6e22e">decode_pointer</span>(_onexitbegin);
</span></span><span style="display:flex;"><span>  onexitend <span style="color:#f92672">=</span> <span style="color:#a6e22e">decode_pointer</span>(_onexitend);
</span></span><span style="display:flex;"><span>  v2 <span style="color:#f92672">=</span> <span style="color:#a6e22e">_dllonexit</span>(func, <span style="color:#f92672">&amp;</span>onexitbegin, <span style="color:#f92672">&amp;</span>onexitend);
</span></span><span style="display:flex;"><span>  _onexitbegin <span style="color:#f92672">=</span> <span style="color:#a6e22e">encode_pointer</span>(onexitbegin);
</span></span><span style="display:flex;"><span>  _onexitend <span style="color:#f92672">=</span> <span style="color:#a6e22e">encode_pointer</span>(onexitend);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">unlock</span>(<span style="color:#ae81ff">8LL</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> v2;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 403180: using guessed type __int64 __fastcall lock(_QWORD);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 403188: using guessed type __int64 __fastcall _dllonexit(_QWORD, _QWORD, _QWORD);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 403190: using guessed type __int64 __fastcall unlock(_QWORD);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 405400: using guessed type _UNKNOWN *refptr___imp__onexit;
</span></span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//----- (0000000000402A80) ----------------------------------------------------
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#66d9ef">__fastcall</span> <span style="color:#a6e22e">atexit</span>(_PVFV func)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>(<span style="color:#a6e22e">mingw_onexit</span>(func) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0LL</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//----- (0000000000402AA0) ----------------------------------------------------
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#66d9ef">__cdecl</span> <span style="color:#a6e22e">my_lconv_init</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">__lconv_init</span>();
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 409350: using guessed type __int64 __lconv_init(void);
</span></span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//----- (0000000000402AB0) ----------------------------------------------------
</span></span></span><span style="display:flex;"><span>WINBOOL <span style="color:#66d9ef">__fastcall</span> <span style="color:#a6e22e">ValidateImageBase_part_0</span>(PBYTE pImageBase)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  BYTE <span style="color:#f92672">*</span>v1; <span style="color:#75715e">// rcx
</span></span></span><span style="display:flex;"><span>  WINBOOL result; <span style="color:#75715e">// eax
</span></span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  v1 <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>pImageBase[<span style="color:#f92672">*</span>(pImageBase <span style="color:#f92672">+</span> <span style="color:#ae81ff">15</span>)];
</span></span><span style="display:flex;"><span>  result <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> ( <span style="color:#f92672">*</span>v1 <span style="color:#f92672">==</span> <span style="color:#ae81ff">17744</span> )
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span>(v1 <span style="color:#f92672">+</span> <span style="color:#ae81ff">12</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">523</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//----- (0000000000402AD0) ----------------------------------------------------
</span></span></span><span style="display:flex;"><span>WINBOOL <span style="color:#66d9ef">__fastcall</span> <span style="color:#a6e22e">ValidateImageBase</span>(PBYTE pImageBase)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> ( <span style="color:#f92672">*</span>pImageBase <span style="color:#f92672">==</span> <span style="color:#ae81ff">23117</span> )
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">ValidateImageBase_part_0</span>(pImageBase);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//----- (0000000000402AF0) ----------------------------------------------------
</span></span></span><span style="display:flex;"><span>PIMAGE_SECTION_HEADER <span style="color:#66d9ef">__fastcall</span> <span style="color:#a6e22e">FindPESection</span>(PBYTE pImageBase, DWORD_PTR rva)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  BYTE <span style="color:#f92672">*</span>v2; <span style="color:#75715e">// rcx
</span></span></span><span style="display:flex;"><span>  PIMAGE_SECTION_HEADER result; <span style="color:#75715e">// rax
</span></span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> v4; <span style="color:#75715e">// ecx
</span></span></span><span style="display:flex;"><span>  _IMAGE_SECTION_HEADER <span style="color:#f92672">*</span>v5; <span style="color:#75715e">// r9
</span></span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  v2 <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>pImageBase[<span style="color:#f92672">*</span>(pImageBase <span style="color:#f92672">+</span> <span style="color:#ae81ff">15</span>)];
</span></span><span style="display:flex;"><span>  result <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>v2[<span style="color:#f92672">*</span>(v2 <span style="color:#f92672">+</span> <span style="color:#ae81ff">10</span>) <span style="color:#f92672">+</span> <span style="color:#ae81ff">24</span>];
</span></span><span style="display:flex;"><span>  v4 <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>(v2 <span style="color:#f92672">+</span> <span style="color:#ae81ff">3</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> ( <span style="color:#f92672">!</span>v4 )
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0LL</span>;
</span></span><span style="display:flex;"><span>  v5 <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>result[(v4 <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">while</span> ( result<span style="color:#f92672">-&gt;</span>VirtualAddress <span style="color:#f92672">&gt;</span> rva <span style="color:#f92672">||</span> rva <span style="color:#f92672">&gt;=</span> result<span style="color:#f92672">-&gt;</span>Misc.PhysicalAddress <span style="color:#f92672">+</span> result<span style="color:#f92672">-&gt;</span>VirtualAddress )
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ( <span style="color:#f92672">++</span>result <span style="color:#f92672">==</span> v5 )
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0LL</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//----- (0000000000402B40) ----------------------------------------------------
</span></span></span><span style="display:flex;"><span>PIMAGE_SECTION_HEADER <span style="color:#66d9ef">__fastcall</span> <span style="color:#a6e22e">FindPESectionByName</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>pName)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  BYTE <span style="color:#f92672">*</span>v3; <span style="color:#75715e">// rdx
</span></span></span><span style="display:flex;"><span>  _IMAGE_SECTION_HEADER <span style="color:#f92672">*</span>v4; <span style="color:#75715e">// rbx
</span></span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> v5; <span style="color:#75715e">// edx
</span></span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">__int64</span> v6; <span style="color:#75715e">// rdi
</span></span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> ( <span style="color:#a6e22e">strlen</span>(pName) <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">8</span> )
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0LL</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> ( <span style="color:#f92672">*</span>refptr___image_base__ <span style="color:#f92672">!=</span> <span style="color:#ae81ff">23117</span> )
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0LL</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> ( <span style="color:#f92672">!</span><span style="color:#a6e22e">ValidateImageBase_part_0</span>(refptr___image_base__) )
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0LL</span>;
</span></span><span style="display:flex;"><span>  v3 <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>refptr___image_base__[<span style="color:#f92672">*</span>(refptr___image_base__ <span style="color:#f92672">+</span> <span style="color:#ae81ff">15</span>)];
</span></span><span style="display:flex;"><span>  v4 <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>v3[<span style="color:#f92672">*</span>(v3 <span style="color:#f92672">+</span> <span style="color:#ae81ff">10</span>) <span style="color:#f92672">+</span> <span style="color:#ae81ff">24</span>];
</span></span><span style="display:flex;"><span>  v5 <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>(v3 <span style="color:#f92672">+</span> <span style="color:#ae81ff">3</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> ( <span style="color:#f92672">!</span>v5 )
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0LL</span>;
</span></span><span style="display:flex;"><span>  v6 <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>v4[(v5 <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">while</span> ( <span style="color:#a6e22e">strncmp</span>(v4, pName, <span style="color:#ae81ff">8uLL</span>) )
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ( <span style="color:#f92672">++</span>v4 <span style="color:#f92672">==</span> v6 )
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0LL</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> v4;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//----- (0000000000402BE0) ----------------------------------------------------
</span></span></span><span style="display:flex;"><span>PIMAGE_SECTION_HEADER <span style="color:#66d9ef">__fastcall</span> <span style="color:#a6e22e">_mingw_GetSectionForAddress</span>(LPVOID p)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> ( <span style="color:#f92672">*</span>refptr___image_base__ <span style="color:#f92672">==</span> <span style="color:#ae81ff">23117</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">ValidateImageBase_part_0</span>(refptr___image_base__) )
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">FindPESection</span>(refptr___image_base__, p <span style="color:#f92672">-</span> refptr___image_base__);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0LL</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//----- (0000000000402C30) ----------------------------------------------------
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#66d9ef">__cdecl</span> <span style="color:#a6e22e">_mingw_GetSectionCount</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> result; <span style="color:#75715e">// eax
</span></span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  result <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> ( <span style="color:#f92672">*</span>refptr___image_base__ <span style="color:#f92672">==</span> <span style="color:#ae81ff">23117</span> )
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    result <span style="color:#f92672">=</span> <span style="color:#a6e22e">ValidateImageBase_part_0</span>(refptr___image_base__);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ( result )
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> <span style="color:#f92672">*&amp;</span>refptr___image_base__[<span style="color:#f92672">*</span>(refptr___image_base__ <span style="color:#f92672">+</span> <span style="color:#ae81ff">15</span>) <span style="color:#f92672">+</span> <span style="color:#ae81ff">6</span>];
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//----- (0000000000402C70) ----------------------------------------------------
</span></span></span><span style="display:flex;"><span>PIMAGE_SECTION_HEADER <span style="color:#66d9ef">__fastcall</span> <span style="color:#a6e22e">FindPESectionExec</span>(<span style="color:#66d9ef">size_t</span> eNo)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  BYTE <span style="color:#f92672">*</span>v3; <span style="color:#75715e">// rsi
</span></span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">__int64</span> v4; <span style="color:#75715e">// rdx
</span></span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">__int64</span> v5; <span style="color:#75715e">// rax
</span></span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> ( <span style="color:#f92672">*</span>refptr___image_base__ <span style="color:#f92672">!=</span> <span style="color:#ae81ff">23117</span> )
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0LL</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> ( <span style="color:#f92672">!</span><span style="color:#a6e22e">ValidateImageBase_part_0</span>(refptr___image_base__) )
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0LL</span>;
</span></span><span style="display:flex;"><span>  v3 <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>refptr___image_base__[<span style="color:#f92672">*</span>(refptr___image_base__ <span style="color:#f92672">+</span> <span style="color:#ae81ff">15</span>)];
</span></span><span style="display:flex;"><span>  v4 <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>v3[<span style="color:#f92672">*</span>(v3 <span style="color:#f92672">+</span> <span style="color:#ae81ff">10</span>) <span style="color:#f92672">+</span> <span style="color:#ae81ff">24</span>];
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> ( <span style="color:#f92672">!*</span>(v3 <span style="color:#f92672">+</span> <span style="color:#ae81ff">3</span>) )
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0LL</span>;
</span></span><span style="display:flex;"><span>  v5 <span style="color:#f92672">=</span> v4 <span style="color:#f92672">+</span> <span style="color:#ae81ff">40LL</span> <span style="color:#f92672">*</span> (<span style="color:#f92672">*</span>(v3 <span style="color:#f92672">+</span> <span style="color:#ae81ff">3</span>) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">+</span> <span style="color:#ae81ff">40</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">while</span> ( (<span style="color:#f92672">*</span>(v4 <span style="color:#f92672">+</span> <span style="color:#ae81ff">39</span>) <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0x20</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> )
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>LABEL_9:
</span></span><span style="display:flex;"><span>    v4 <span style="color:#f92672">+=</span> <span style="color:#ae81ff">40LL</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ( v4 <span style="color:#f92672">==</span> v5 )
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0LL</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> ( eNo )
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">--</span>eNo;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">goto</span> LABEL_9;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> v4;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//----- (0000000000402D00) ----------------------------------------------------
</span></span></span><span style="display:flex;"><span>PBYTE <span style="color:#66d9ef">__cdecl</span> <span style="color:#a6e22e">GetPEImageBase</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  BYTE <span style="color:#f92672">*</span>v0; <span style="color:#75715e">// rbx
</span></span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  v0 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0LL</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> ( <span style="color:#f92672">*</span>refptr___image_base__ <span style="color:#f92672">!=</span> <span style="color:#ae81ff">23117</span> )
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0LL</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> ( <span style="color:#a6e22e">ValidateImageBase_part_0</span>(refptr___image_base__) )
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> refptr___image_base__;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> v0;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//----- (0000000000402D40) ----------------------------------------------------
</span></span></span><span style="display:flex;"><span>WINBOOL <span style="color:#66d9ef">__fastcall</span> <span style="color:#a6e22e">IsNonwritableInCurrentImage</span>(PBYTE pTarget)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  WINBOOL result; <span style="color:#75715e">// eax
</span></span></span><span style="display:flex;"><span>  PIMAGE_SECTION_HEADER PESection; <span style="color:#75715e">// rax
</span></span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  result <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> ( <span style="color:#f92672">*</span>refptr___image_base__ <span style="color:#f92672">==</span> <span style="color:#ae81ff">23117</span> )
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    result <span style="color:#f92672">=</span> <span style="color:#a6e22e">ValidateImageBase_part_0</span>(refptr___image_base__);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ( result )
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>      PESection <span style="color:#f92672">=</span> <span style="color:#a6e22e">FindPESection</span>(refptr___image_base__, pTarget <span style="color:#f92672">-</span> refptr___image_base__);
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> PESection <span style="color:#f92672">&amp;&amp;</span> (PESection<span style="color:#f92672">-&gt;</span>Characteristics <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0x80000000</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//----- (0000000000402DA0) ----------------------------------------------------
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">__fastcall</span> <span style="color:#a6e22e">_mingw_enum_import_library_names</span>(<span style="color:#66d9ef">int</span> i)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> v3; <span style="color:#75715e">// edx
</span></span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">__int64</span> v4; <span style="color:#75715e">// rbx
</span></span></span><span style="display:flex;"><span>  BYTE <span style="color:#f92672">*</span>v5; <span style="color:#75715e">// rdx
</span></span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> ( <span style="color:#f92672">*</span>refptr___image_base__ <span style="color:#f92672">!=</span> <span style="color:#ae81ff">23117</span> )
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0LL</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> ( <span style="color:#f92672">!</span><span style="color:#a6e22e">ValidateImageBase_part_0</span>(refptr___image_base__) )
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0LL</span>;
</span></span><span style="display:flex;"><span>  v3 <span style="color:#f92672">=</span> <span style="color:#f92672">*&amp;</span>refptr___image_base__[<span style="color:#f92672">*</span>(refptr___image_base__ <span style="color:#f92672">+</span> <span style="color:#ae81ff">15</span>) <span style="color:#f92672">+</span> <span style="color:#ae81ff">144</span>];
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> ( <span style="color:#f92672">!</span>v3 )
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0LL</span>;
</span></span><span style="display:flex;"><span>  v4 <span style="color:#f92672">=</span> v3;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> ( <span style="color:#f92672">!</span><span style="color:#a6e22e">FindPESection</span>(refptr___image_base__, v3) )
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0LL</span>;
</span></span><span style="display:flex;"><span>  v5 <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>refptr___image_base__[v4];
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> ( <span style="color:#f92672">!&amp;</span>refptr___image_base__[v4] )
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0LL</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">while</span> ( <span style="color:#f92672">*</span>(v5 <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">||</span> <span style="color:#f92672">*</span>(v5 <span style="color:#f92672">+</span> <span style="color:#ae81ff">3</span>) )
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ( i <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span> )
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span>refptr___image_base__[<span style="color:#f92672">*</span>(v5 <span style="color:#f92672">+</span> <span style="color:#ae81ff">3</span>)];
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">--</span>i;
</span></span><span style="display:flex;"><span>    v5 <span style="color:#f92672">+=</span> <span style="color:#ae81ff">20</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0LL</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//----- (0000000000402E50) ----------------------------------------------------
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#66d9ef">__cdecl</span> <span style="color:#a6e22e">_mingwthr_run_key_dtors_part_0</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">volatile</span> __mingwthr_key_t <span style="color:#f92672">*</span>i; <span style="color:#75715e">// rbx
</span></span></span><span style="display:flex;"><span>  LPVOID Value; <span style="color:#75715e">// rsi
</span></span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">EnterCriticalSection</span>(<span style="color:#f92672">&amp;</span>_mingwthr_cs);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> ( i <span style="color:#f92672">=</span> key_dtor_list; i; i <span style="color:#f92672">=</span> i<span style="color:#f92672">-&gt;</span>next )
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    Value <span style="color:#f92672">=</span> <span style="color:#a6e22e">TlsGetValue</span>(i<span style="color:#f92672">-&gt;</span>key);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ( <span style="color:#f92672">!</span><span style="color:#a6e22e">GetLastError</span>() <span style="color:#f92672">&amp;&amp;</span> Value )
</span></span><span style="display:flex;"><span>      i<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">dtor</span>(Value);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">LeaveCriticalSection</span>(<span style="color:#f92672">&amp;</span>_mingwthr_cs);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//----- (0000000000402EC0) ----------------------------------------------------
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#66d9ef">__fastcall</span> <span style="color:#a6e22e">__w64_mingwthr_add_key_dtor</span>(DWORD key, <span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>dtor)(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>))
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> result; <span style="color:#75715e">// eax
</span></span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">volatile</span> __mingwthr_key_t <span style="color:#f92672">*</span>v5; <span style="color:#75715e">// rax
</span></span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">volatile</span> __mingwthr_key_t <span style="color:#f92672">*</span>v6; <span style="color:#75715e">// rbx
</span></span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">volatile</span> __mingwthr_key_t <span style="color:#f92672">*</span>v7; <span style="color:#75715e">// rax
</span></span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  result <span style="color:#f92672">=</span> _mingwthr_cs_init;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> ( _mingwthr_cs_init )
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    v5 <span style="color:#f92672">=</span> <span style="color:#a6e22e">calloc</span>(<span style="color:#ae81ff">1uLL</span>, <span style="color:#ae81ff">0x18uLL</span>);
</span></span><span style="display:flex;"><span>    v6 <span style="color:#f92672">=</span> v5;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ( v5 )
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>      v5<span style="color:#f92672">-&gt;</span>key <span style="color:#f92672">=</span> key;
</span></span><span style="display:flex;"><span>      v5<span style="color:#f92672">-&gt;</span>dtor <span style="color:#f92672">=</span> dtor;
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">EnterCriticalSection</span>(<span style="color:#f92672">&amp;</span>_mingwthr_cs);
</span></span><span style="display:flex;"><span>      v7 <span style="color:#f92672">=</span> key_dtor_list;
</span></span><span style="display:flex;"><span>      key_dtor_list <span style="color:#f92672">=</span> v6;
</span></span><span style="display:flex;"><span>      v6<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> v7;
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">LeaveCriticalSection</span>(<span style="color:#f92672">&amp;</span>_mingwthr_cs);
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//----- (0000000000402F40) ----------------------------------------------------
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#66d9ef">__fastcall</span> <span style="color:#a6e22e">__w64_mingwthr_remove_key_dtor</span>(DWORD key)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">volatile</span> __mingwthr_key_t <span style="color:#f92672">*</span>v3; <span style="color:#75715e">// rdx
</span></span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">volatile</span> __mingwthr_key_t <span style="color:#f92672">*</span>next; <span style="color:#75715e">// rax
</span></span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">volatile</span> __mingwthr_key_t <span style="color:#f92672">*</span>v5; <span style="color:#75715e">// rcx
</span></span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> ( <span style="color:#f92672">!</span>_mingwthr_cs_init )
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">EnterCriticalSection</span>(<span style="color:#f92672">&amp;</span>_mingwthr_cs);
</span></span><span style="display:flex;"><span>  v3 <span style="color:#f92672">=</span> key_dtor_list;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> ( key_dtor_list )
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ( key_dtor_list<span style="color:#f92672">-&gt;</span>key <span style="color:#f92672">==</span> key )
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>      v5 <span style="color:#f92672">=</span> key_dtor_list;
</span></span><span style="display:flex;"><span>      key_dtor_list <span style="color:#f92672">=</span> key_dtor_list<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>LABEL_12:
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">free</span>(v5);
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">LeaveCriticalSection</span>(<span style="color:#f92672">&amp;</span>_mingwthr_cs);
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> ( <span style="color:#ae81ff">1</span> )
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>      next <span style="color:#f92672">=</span> v3<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> ( <span style="color:#f92672">!</span>next )
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> ( next<span style="color:#f92672">-&gt;</span>key <span style="color:#f92672">==</span> key )
</span></span><span style="display:flex;"><span>      {
</span></span><span style="display:flex;"><span>        v5 <span style="color:#f92672">=</span> v3<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>        v3<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> next<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">goto</span> LABEL_12;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      v3 <span style="color:#f92672">=</span> v3<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">LeaveCriticalSection</span>(<span style="color:#f92672">&amp;</span>_mingwthr_cs);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//----- (0000000000402FE0) ----------------------------------------------------
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// local variable allocation has failed, the output may be wrong!
</span></span></span><span style="display:flex;"><span>WINBOOL <span style="color:#66d9ef">__fastcall</span> <span style="color:#a6e22e">_mingw_TLScallback</span>(HANDLE hDllHandle, DWORD reason, LPVOID reserved)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  WINBOOL result; <span style="color:#75715e">// eax
</span></span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> ( reason <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> )
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ( <span style="color:#f92672">!</span>_mingwthr_cs_init )
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">InitializeCriticalSection</span>(<span style="color:#f92672">&amp;</span>_mingwthr_cs);
</span></span><span style="display:flex;"><span>    result <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    _mingwthr_cs_init <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ( reason )
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> ( reason <span style="color:#f92672">==</span> <span style="color:#ae81ff">3</span> )
</span></span><span style="display:flex;"><span>      {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> ( _mingwthr_cs_init )
</span></span><span style="display:flex;"><span>          <span style="color:#a6e22e">_mingwthr_run_key_dtors_part_0</span>();
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> ( _mingwthr_cs_init )
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">_mingwthr_run_key_dtors_part_0</span>();
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> ( _mingwthr_cs_init <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> )
</span></span><span style="display:flex;"><span>      {
</span></span><span style="display:flex;"><span>        _mingwthr_cs_init <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">_IAT_start__</span>(<span style="color:#f92672">&amp;</span>_mingwthr_cs, <span style="color:#f92672">*&amp;</span>reason, reserved);
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 402FE0: variables would overlap: edx.4 and rdx.8
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 409268: using guessed type __int64 __fastcall _IAT_start__(_QWORD, _QWORD, _QWORD);
</span></span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//----- (00000000004030E0) ----------------------------------------------------
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span><span style="color:#66d9ef">__cdecl</span> <span style="color:#a6e22e">get_invalid_parameter_handler</span>())(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">wchar_t</span> <span style="color:#f92672">*</span>, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">wchar_t</span> <span style="color:#f92672">*</span>, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">wchar_t</span> <span style="color:#f92672">*</span>, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">uintptr_t</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> handler;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//----- (00000000004030F0) ----------------------------------------------------
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span><span style="color:#66d9ef">__fastcall</span> <span style="color:#a6e22e">set_invalid_parameter_handler</span>(
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>new_handler)(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">wchar_t</span> <span style="color:#f92672">*</span>, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">wchar_t</span> <span style="color:#f92672">*</span>, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">wchar_t</span> <span style="color:#f92672">*</span>, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">uintptr_t</span>)))(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">wchar_t</span> <span style="color:#f92672">*</span>, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">wchar_t</span> <span style="color:#f92672">*</span>, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">wchar_t</span> <span style="color:#f92672">*</span>, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">uintptr_t</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">_InterlockedExchange64</span>(<span style="color:#f92672">&amp;</span>handler, new_handler);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// nfuncs=114 queued=48 decompiled=48 lumina nreq=0 worse=0 better=0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// ALL OK, 48 function(s) have been successfully decompiled
</span></span></span></code></pre></div><p>Exploit:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">char</span> aSfmsilqzdxajhn[<span style="color:#ae81ff">53</span>] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;sfMSiLQzdXajhnZKrPyAoHbTDNREWtuVOcGIxkYemgBClvwFUpqJ&#34;</span>; <span style="color:#75715e">// weak
</span></span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">generaNumero</span>(<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>a1)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> i; <span style="color:#75715e">// [rsp+28h] [rbp-58h]
</span></span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> v3; <span style="color:#75715e">// [rsp+2Ch] [rbp-54h]
</span></span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  v3 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> ( i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#a6e22e">strlen</span>(a1); <span style="color:#f92672">++</span>i )
</span></span><span style="display:flex;"><span>    v3 <span style="color:#f92672">+=</span> a1[i];
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Numero: %d&#34;</span>, v3 <span style="color:#f92672">+</span> <span style="color:#ae81ff">6572</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> (v3 <span style="color:#f92672">+</span> <span style="color:#ae81ff">6572</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">generaLetras</span>(<span style="color:#66d9ef">int</span> a1, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>a2)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">size_t</span> v2; <span style="color:#75715e">// rax
</span></span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>result; <span style="color:#75715e">// rax
</span></span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> v4; <span style="color:#75715e">// [rsp+28h] [rbp-58h]
</span></span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> v5; <span style="color:#75715e">// [rsp+2Ch] [rbp-54h]
</span></span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> v6; <span style="color:#75715e">// [rsp+30h] [rbp-50h]
</span></span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> v7; <span style="color:#75715e">// [rsp+34h] [rbp-4Ch]
</span></span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  v7 <span style="color:#f92672">=</span> (a1 <span style="color:#f92672">+</span> <span style="color:#ae81ff">15</span>) <span style="color:#f92672">%</span> <span style="color:#a6e22e">strlen</span>(<span style="color:#e6db74">&#34;sfMSiLQzdXajhnZKrPyAoHbTDNREWtuVOcGIxkYemgBClvwFUpqJ&#34;</span>);
</span></span><span style="display:flex;"><span>  v6 <span style="color:#f92672">=</span> (a1 <span style="color:#f92672">+</span> <span style="color:#ae81ff">22</span>) <span style="color:#f92672">%</span> <span style="color:#a6e22e">strlen</span>(<span style="color:#e6db74">&#34;sfMSiLQzdXajhnZKrPyAoHbTDNREWtuVOcGIxkYemgBClvwFUpqJ&#34;</span>);
</span></span><span style="display:flex;"><span>  v5 <span style="color:#f92672">=</span> (a1 <span style="color:#f92672">+</span> <span style="color:#ae81ff">32</span>) <span style="color:#f92672">%</span> <span style="color:#a6e22e">strlen</span>(<span style="color:#e6db74">&#34;sfMSiLQzdXajhnZKrPyAoHbTDNREWtuVOcGIxkYemgBClvwFUpqJ&#34;</span>);
</span></span><span style="display:flex;"><span>  v4 <span style="color:#f92672">=</span> (a1 <span style="color:#f92672">+</span> <span style="color:#ae81ff">17</span>) <span style="color:#f92672">%</span> <span style="color:#a6e22e">strlen</span>(<span style="color:#e6db74">&#34;sfMSiLQzdXajhnZKrPyAoHbTDNREWtuVOcGIxkYemgBClvwFUpqJ&#34;</span>);
</span></span><span style="display:flex;"><span>  v2 <span style="color:#f92672">=</span> <span style="color:#a6e22e">strlen</span>(<span style="color:#e6db74">&#34;sfMSiLQzdXajhnZKrPyAoHbTDNREWtuVOcGIxkYemgBClvwFUpqJ&#34;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">*</span>a2 <span style="color:#f92672">=</span> aSfmsilqzdxajhn[v7];
</span></span><span style="display:flex;"><span>  a2[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> aSfmsilqzdxajhn[v6];
</span></span><span style="display:flex;"><span>  a2[<span style="color:#ae81ff">2</span>] <span style="color:#f92672">=</span> aSfmsilqzdxajhn[v5];
</span></span><span style="display:flex;"><span>  a2[<span style="color:#ae81ff">3</span>] <span style="color:#f92672">=</span> aSfmsilqzdxajhn[v4];
</span></span><span style="display:flex;"><span>  a2[<span style="color:#ae81ff">4</span>] <span style="color:#f92672">=</span> aSfmsilqzdxajhn[((a1 <span style="color:#f92672">+</span> <span style="color:#ae81ff">4</span>) <span style="color:#f92672">%</span> v2)];
</span></span><span style="display:flex;"><span>  result <span style="color:#f92672">=</span> a2 <span style="color:#f92672">+</span> <span style="color:#ae81ff">5</span>;
</span></span><span style="display:flex;"><span>  a2[<span style="color:#ae81ff">5</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">generaSerial</span>(<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>a1, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>a2)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">char</span> v3[<span style="color:#ae81ff">16</span>]; <span style="color:#75715e">// [rsp+40h] [rbp-50h] BYREF
</span></span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">char</span> v4[<span style="color:#ae81ff">16</span>]; <span style="color:#75715e">// [rsp+50h] [rbp-40h] BYREF
</span></span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">char</span> v5[<span style="color:#ae81ff">16</span>]; <span style="color:#75715e">// [rsp+60h] [rbp-30h] BYREF
</span></span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">char</span> v6[<span style="color:#ae81ff">16</span>]; <span style="color:#75715e">// [rsp+70h] [rbp-20h] BYREF
</span></span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">char</span> v7[<span style="color:#ae81ff">12</span>]; <span style="color:#75715e">// [rsp+80h] [rbp-10h] BYREF
</span></span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> v8; <span style="color:#75715e">// [rsp+8Ch] [rbp-4h]
</span></span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  v8 <span style="color:#f92672">=</span> <span style="color:#a6e22e">generaNumero</span>(a1);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">generaLetras</span>(v8, v7);
</span></span><span style="display:flex;"><span>  v8 <span style="color:#f92672">=</span> <span style="color:#a6e22e">generaNumero</span>(v7);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">generaLetras</span>(v8, v6);
</span></span><span style="display:flex;"><span>  v8 <span style="color:#f92672">=</span> <span style="color:#a6e22e">generaNumero</span>(v6);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">generaLetras</span>(v8, v5);
</span></span><span style="display:flex;"><span>  v8 <span style="color:#f92672">=</span> <span style="color:#a6e22e">generaNumero</span>(v5);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">generaLetras</span>(v8, v4);
</span></span><span style="display:flex;"><span>  v8 <span style="color:#f92672">=</span> <span style="color:#a6e22e">generaNumero</span>(v4);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">generaLetras</span>(v8, v3);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">El serial es: %s-%s-%s-%s-%s</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, v7, v6, v5, v4, v3);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">sprintf</span>(a2, <span style="color:#e6db74">&#34;%s-%s-%s-%s-%s&#34;</span>, v7, v6, v5, v4, v3);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>a1 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;A&#34;</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">char</span> serial[<span style="color:#ae81ff">32</span>]; 
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;El nombre es: %s</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,a1);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">generaSerial</span>(a1,serial);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><img src="/img/keygen_si_puedes.png" alt="keygen"></p>

</div>


      </div>
    </section>
  </section><script 
src="/quiz/quizdown.js">
</script>
<script 
src="/quiz/quizdownKatex.js">
</script>
<script 
src="/quiz/quizdownHighlight.js">
</script>
<script>quizdown.register(quizdownHighlight).register(quizdownKatex).init()</script> 
<footer class="footer">
  <div class="content has-text-centered">
    
    
    <p>
      
      <a class="" href="https://imlauera.github.io/index.xml" target="_blank">
        <span>
          RSS
        </span>
      </a>
      
      | <a href="https://imlauera.github.io" target="_blank">Andres Imlauer.</a> 

      
      
    </p>
    
  </div>




<script type="text/javascript"
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({ tex2jax: {inlineMath: [["$","$"],["\\(","\\)"]]} })
</script>
</footer>


</body>
</html>
